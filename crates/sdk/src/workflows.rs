//! Functionality related to defining and interacting with workflows
//!
//! This module contains traits and types for implementing workflows using the
//! `#[workflow]` and `#[workflow_methods]` macros.
//!
//! Example usage:
//! ```
//! use temporalio_macros::{workflow, workflow_methods};
//! use temporalio_sdk::{WfContext, WfExitValue, WorkflowResult};
//!
//! #[workflow]
//! pub struct MyWorkflow {
//!     counter: u32,
//! }
//!
//! #[workflow_methods]
//! impl MyWorkflow {
//!     #[init]
//!     pub fn new(ctx: &WfContext, input: String) -> Self {
//!         Self { counter: 0 }
//!     }
//!
//!     #[run]
//!     pub async fn run(&mut self, ctx: &mut WfContext) -> WorkflowResult<String> {
//!         Ok(WfExitValue::Normal(format!(
//!             "Done with counter: {}",
//!             self.counter
//!         )))
//!     }
//!
//!     #[signal]
//!     pub fn increment(&mut self, ctx: &mut WfContext, amount: u32) {
//!         self.counter += amount;
//!     }
//!
//!     #[query]
//!     pub fn get_counter(&self, ctx: &WfContext) -> u32 {
//!         self.counter
//!     }
//! }
//! ```

use futures_util::future::BoxFuture;
use std::{collections::HashMap, fmt::Debug, sync::Arc};
use temporalio_common::{
    QueryDefinition, SignalDefinition, UpdateDefinition, WorkflowDefinition,
    data_converters::{
        GenericPayloadConverter, PayloadConversionError, PayloadConverter, SerializationContext,
    },
    protos::temporal::api::common::v1::Payload,
};

use crate::WfContext;

/// Error type for workflow operations
#[derive(Debug, thiserror::Error)]
pub enum WorkflowError {
    /// Error during payload conversion
    #[error("Payload conversion error: {0}")]
    PayloadConversion(#[from] PayloadConversionError),

    /// Workflow execution error
    #[error("Workflow execution error: {0}")]
    Execution(#[from] anyhow::Error),
}

/// Trait implemented by workflow structs to enable execution by the worker.
///
/// This trait is typically generated by the `#[workflow_methods]` macro and should not
/// be implemented manually in most cases.
///
/// The `WorkflowImplementation` trait provides:
/// - Initialization from serialized input
/// - Execution of the main workflow function
#[doc(hidden)]
pub trait WorkflowImplementation: Sized + Send + 'static {
    /// The marker struct for the run method that implements `WorkflowDefinition`
    type Run: WorkflowDefinition;

    /// Whether the init method accepts the workflow input.
    /// If true, input goes to init. If false, input goes to run.
    const INIT_TAKES_INPUT: bool;

    /// Initialize the workflow instance.
    ///
    /// This is called when a new workflow execution starts. If `INIT_TAKES_INPUT` is true,
    /// `input` will be `Some`. Otherwise it's `None`.
    fn init(ctx: &WfContext, input: Option<<Self::Run as WorkflowDefinition>::Input>) -> Self;

    /// Execute the workflow's main run function.
    ///
    /// If `INIT_TAKES_INPUT` is false, `input` will be `Some`. Otherwise it's `None`.
    fn run(
        &mut self,
        ctx: WfContext,
        input: Option<<Self::Run as WorkflowDefinition>::Input>,
    ) -> BoxFuture<'_, Result<Payload, WorkflowError>>;
}

/// Trait for executing signal handlers on a workflow.
///
/// This trait is implemented for each signal method in a workflow and allows
/// the worker to dispatch incoming signals to the appropriate handler.
#[doc(hidden)]
pub trait ExecutableSignal<S: SignalDefinition>: WorkflowImplementation {
    /// Handle an incoming signal with the given input.
    ///
    /// Signals may be synchronous or asynchronous, but the trait always returns
    /// a boxed future for uniformity.
    fn handle(&mut self, ctx: &mut WfContext, input: S::Input) -> BoxFuture<'_, ()>;
}

/// Trait for executing query handlers on a workflow.
///
/// Queries are read-only operations that do not mutate workflow state.
/// They must be synchronous (not async).
#[doc(hidden)]
pub trait ExecutableQuery<Q: QueryDefinition>: WorkflowImplementation {
    /// Handle a query with the given input and return the result.
    ///
    /// Queries take `&self` (immutable) and cannot modify workflow state.
    fn handle(&self, ctx: &WfContext, input: Q::Input) -> Q::Output;
}

/// Trait for executing update handlers on a workflow.
///
/// Updates are operations that can mutate workflow state and return a result.
/// They may be synchronous or asynchronous.
#[doc(hidden)]
pub trait ExecutableUpdate<U: UpdateDefinition>: WorkflowImplementation {
    /// Handle an update with the given input and return the result.
    ///
    /// Updates take `&mut self` and can modify workflow state.
    fn handle(&mut self, ctx: &mut WfContext, input: U::Input) -> BoxFuture<'_, U::Output>;

    /// Validate an update before it is applied.
    ///
    /// The default implementation always accepts the update.
    /// Override this to add validation logic.
    fn validate(&self, _ctx: &WfContext, _input: &U::Input) -> Result<(), String> {
        Ok(())
    }
}

/// Trait implemented by workflow types to enable registration with workers.
///
/// This trait is automatically generated by the `#[workflow_methods]` macro.
#[doc(hidden)]
pub trait WorkflowImplementer: WorkflowImplementation {
    /// Register this workflow and all its handlers with the given definitions container.
    fn register_all(defs: &mut WorkflowDefinitions);
}

/// Type alias for workflow invocation functions
pub(crate) type WorkflowInvocation = Arc<
    dyn Fn(
            Payload,
            PayloadConverter,
            WfContext,
        )
            -> Result<BoxFuture<'static, Result<Payload, WorkflowError>>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for signal handler functions
pub(crate) type SignalHandler = Arc<
    dyn Fn(Payload, PayloadConverter) -> Result<BoxFuture<'static, ()>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for query handler functions
pub(crate) type QueryHandler =
    Arc<dyn Fn(Payload, PayloadConverter) -> Result<Payload, PayloadConversionError> + Send + Sync>;

/// Type alias for update handler functions
pub(crate) type UpdateHandler = Arc<
    dyn Fn(Payload, PayloadConverter) -> Result<BoxFuture<'static, Payload>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for update validator functions
pub(crate) type UpdateValidator =
    Arc<dyn Fn(&Payload, &PayloadConverter) -> Result<(), String> + Send + Sync>;

/// Contains all handlers for a single workflow type.
#[derive(Clone)]
struct WorkflowHandlers {
    run: WorkflowInvocation,
    signals: HashMap<&'static str, SignalHandler>,
    queries: HashMap<&'static str, QueryHandler>,
    updates: HashMap<&'static str, (UpdateHandler, UpdateValidator)>,
}

/// Contains workflow registrations in a form ready for execution by workers.
#[derive(Default, Clone)]
pub struct WorkflowDefinitions {
    /// Maps workflow type name to all handlers for that workflow
    workflows: HashMap<&'static str, WorkflowHandlers>,
}

impl WorkflowDefinitions {
    /// Creates a new empty `WorkflowDefinitions`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a workflow implementation.
    pub fn register_workflow<W: WorkflowImplementer>(&mut self) -> &mut Self {
        W::register_all(self);
        self
    }

    /// Register a specific workflow's run method.
    #[doc(hidden)]
    pub fn register_workflow_run<W: WorkflowImplementation>(&mut self) -> &mut Self
    where
        <W::Run as WorkflowDefinition>::Input: Send,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let run = Arc::new(move |payload, converter: PayloadConverter, ctx| {
            let input = converter.from_payload(&SerializationContext::Workflow, payload)?;
            let (init_input, run_input) = if W::INIT_TAKES_INPUT {
                (Some(input), None)
            } else {
                (None, Some(input))
            };
            let mut workflow = W::init(&ctx, init_input);
            Ok(
                Box::pin(async move { workflow.run(ctx.clone(), run_input).await })
                    as BoxFuture<'static, Result<Payload, WorkflowError>>,
            )
        });
        self.workflows.insert(
            workflow_name,
            WorkflowHandlers {
                run,
                signals: HashMap::new(),
                queries: HashMap::new(),
                updates: HashMap::new(),
            },
        );
        self
    }

    /// Register a signal handler for a workflow.
    #[doc(hidden)]
    pub fn register_signal<W, S>(&mut self) -> &mut Self
    where
        W: ExecutableSignal<S>,
        S: SignalDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let signal_name = S::name();

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before signals")
            .signals
            .insert(
                signal_name,
                Arc::new(move |_payload, _converter| {
                    // Signal handlers will be invoked through the workflow instance
                    // This is a placeholder - actual dispatch happens through the workflow
                    todo!("Signal dispatch implementation")
                }),
            );
        self
    }

    /// Register a query handler for a workflow.
    #[doc(hidden)]
    pub fn register_query<W, Q>(&mut self) -> &mut Self
    where
        W: ExecutableQuery<Q>,
        Q: QueryDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let query_name = Q::name();

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before queries")
            .queries
            .insert(
                query_name,
                Arc::new(move |_payload, _converter| {
                    // Query handlers will be invoked through the workflow instance
                    todo!("Query dispatch implementation")
                }),
            );
        self
    }

    /// Register an update handler for a workflow.
    #[doc(hidden)]
    pub fn register_update<W, U>(&mut self) -> &mut Self
    where
        W: ExecutableUpdate<U>,
        U: UpdateDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let update_name = U::name();

        let handler: UpdateHandler = Arc::new(move |_payload, _converter| {
            // Update handlers will be invoked through the workflow instance
            todo!("Update dispatch implementation")
        });
        let validator: UpdateValidator = Arc::new(move |_payload, _converter| {
            // Validation will be invoked through the workflow instance
            Ok(())
        });

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before updates")
            .updates
            .insert(update_name, (handler, validator));
        self
    }

    /// Check if any workflows are registered.
    pub fn is_empty(&self) -> bool {
        self.workflows.is_empty()
    }

    /// Get the workflow invocation function for a given workflow type.
    pub(crate) fn get_workflow(&self, workflow_type: &str) -> Option<WorkflowInvocation> {
        self.workflows.get(workflow_type).map(|h| h.run.clone())
    }

    /// Get the signal handler for a given workflow and signal type.
    pub(crate) fn get_signal(
        &self,
        workflow_type: &str,
        signal_name: &str,
    ) -> Option<SignalHandler> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.signals.get(signal_name))
            .cloned()
    }

    /// Get the query handler for a given workflow and query type.
    pub(crate) fn get_query(&self, workflow_type: &str, query_name: &str) -> Option<QueryHandler> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.queries.get(query_name))
            .cloned()
    }

    /// Get the update handler and validator for a given workflow and update type.
    pub(crate) fn get_update(
        &self,
        workflow_type: &str,
        update_name: &str,
    ) -> Option<(UpdateHandler, UpdateValidator)> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.updates.get(update_name))
            .cloned()
    }

    /// Returns an iterator over registered workflow type names.
    pub fn workflow_types(&self) -> impl Iterator<Item = &'static str> + '_ {
        self.workflows.keys().copied()
    }
}

impl Debug for WorkflowDefinitions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("WorkflowDefinitions")
            .field("workflows", &self.workflows.keys().collect::<Vec<_>>())
            .finish()
    }
}
