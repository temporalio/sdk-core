//! Functionality related to defining and interacting with workflows
//!
//! This module contains traits and types for implementing workflows using the
//! `#[workflow]` and `#[workflow_methods]` macros.
//!
//! Example usage:
//! ```
//! use temporalio_macros::{workflow, workflow_methods};
//! use temporalio_sdk::{WfExitValue, WorkflowContext, WorkflowContextView, WorkflowResult};
//!
//! #[workflow]
//! pub struct MyWorkflow {
//!     counter: u32,
//! }
//!
//! #[workflow_methods]
//! impl MyWorkflow {
//!     #[init]
//!     pub fn new(ctx: &WorkflowContextView, input: String) -> Self {
//!         Self { counter: 0 }
//!     }
//!
//!     // Async methods use &self - mutations go through ctx.state_mut()
//!     #[run]
//!     pub async fn run(&self, ctx: &mut WorkflowContext<Self>) -> WorkflowResult<String> {
//!         Ok(WfExitValue::Normal(format!(
//!             "Done with counter: {}",
//!             self.counter
//!         )))
//!     }
//!
//!     // Sync signals use &mut self for direct mutations
//!     #[signal]
//!     pub fn increment(&mut self, ctx: &mut WorkflowContext<Self>, amount: u32) {
//!         self.counter += amount;
//!     }
//!
//!     // Queries use &self with read-only context
//!     #[query]
//!     pub fn get_counter(&self, ctx: &WorkflowContextView) -> u32 {
//!         self.counter
//!     }
//! }
//! ```

use crate::{BaseWorkflowContext, WfExitValue, WorkflowContext, WorkflowContextView};
use futures_util::future::{Fuse, FutureExt, LocalBoxFuture};
use std::{
    cell::RefCell,
    collections::HashMap,
    fmt::Debug,
    pin::Pin,
    rc::Rc,
    sync::Arc,
    task::{Context as TaskContext, Poll},
};
use temporalio_common::{
    QueryDefinition, SignalDefinition, UpdateDefinition, WorkflowDefinition,
    data_converters::{
        GenericPayloadConverter, PayloadConversionError, PayloadConverter, SerializationContext,
        SerializationContextData,
    },
    protos::temporal::api::{
        common::v1::{Payload, Payloads},
        failure::v1::Failure,
    },
};

/// Error type for workflow operations
#[derive(Debug, thiserror::Error)]
pub enum WorkflowError {
    /// Error during payload conversion
    #[error("Payload conversion error: {0}")]
    PayloadConversion(#[from] PayloadConversionError),

    /// Workflow execution error
    #[error("Workflow execution error: {0}")]
    Execution(#[from] anyhow::Error),
}

impl From<WorkflowError> for Failure {
    fn from(err: WorkflowError) -> Self {
        Failure {
            message: err.to_string(),
            ..Default::default()
        }
    }
}

/// Trait implemented by workflow structs to enable execution by the worker.
///
/// This trait is typically generated by the `#[workflow_methods]` macro and should not
/// be implemented manually in most cases.
///
/// The `WorkflowImplementation` trait provides:
/// - Initialization from serialized input
/// - Execution of the main workflow function
#[doc(hidden)]
pub trait WorkflowImplementation: Sized + 'static {
    /// The marker struct for the run method that implements `WorkflowDefinition`
    type Run: WorkflowDefinition;

    /// Whether this workflow has a user-defined `#[init]` method.
    /// Set to `true` by the macro when `#[init]` is present, `false` otherwise.
    const HAS_INIT: bool;

    /// Whether the init method accepts the workflow input.
    /// If true, input goes to init. If false, input goes to run.
    const INIT_TAKES_INPUT: bool;

    /// Initialize the workflow instance.
    ///
    /// This is called when a new workflow execution starts. If `INIT_TAKES_INPUT` is true,
    /// `input` will be `Some`. Otherwise it's `None`.
    fn init(
        ctx: &WorkflowContextView,
        input: Option<<Self::Run as WorkflowDefinition>::Input>,
    ) -> Self;

    /// Execute the workflow's main run function.
    ///
    /// This is a static method - workflow state is accessed via `ctx.state()` or `ctx.state_mut()`.
    /// If `INIT_TAKES_INPUT` is false, `input` will be `Some`. Otherwise it's `None`.
    fn run(
        ctx: WorkflowContext<Self>,
        input: Option<<Self::Run as WorkflowDefinition>::Input>,
    ) -> LocalBoxFuture<'static, Result<WfExitValue<Payload>, WorkflowError>>;

    /// Dispatch an update request by name. Returns `None` if no handler for that name.
    ///
    /// The default implementation returns `None`. The macro generates an override with a
    /// match statement dispatching to all registered update handlers.
    fn dispatch_update(
        _ctx: WorkflowContext<Self>,
        _name: &str,
        _payloads: Payloads,
        _converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'static, Result<Payload, WorkflowError>>> {
        None
    }

    /// Validate an update request by name.
    ///
    /// Returns `None` if no handler for that name, `Some(Ok(()))` if valid,
    /// `Some(Err(...))` if validation failed.
    fn validate_update(
        &self,
        _ctx: &WorkflowContextView,
        _name: &str,
        _payloads: &Payloads,
        _converter: &PayloadConverter,
    ) -> Option<Result<(), WorkflowError>> {
        None
    }

    /// Dispatch a signal by name.
    ///
    /// Returns `None` if no handler for that name, `Some(Ok(future))` if handled,
    /// `Some(Err(...))` if the handler failed.
    /// For sync signals, the mutation happens immediately and returns a completed future.
    /// For async signals, returns a future that must be polled to completion.
    fn dispatch_signal(
        _ctx: WorkflowContext<Self>,
        _name: &str,
        _payloads: Payloads,
        _converter: &PayloadConverter,
    ) -> Option<Result<LocalBoxFuture<'static, ()>, WorkflowError>> {
        None
    }

    /// Dispatch a query by name.
    ///
    /// Returns `None` if no handler for that name, `Some(Ok(payload))` on success,
    /// `Some(Err(...))` on failure. Queries are synchronous and read-only.
    fn dispatch_query(
        &self,
        _ctx: &WorkflowContextView,
        _name: &str,
        _payloads: &Payloads,
        _converter: &PayloadConverter,
    ) -> Option<Result<Payload, WorkflowError>> {
        None
    }
}

/// Trait for executing synchronous signal handlers on a workflow.
///
/// Sync signal handlers take `&mut self` and execute without await points.
#[doc(hidden)]
pub trait ExecutableSyncSignal<S: SignalDefinition>: WorkflowImplementation {
    /// Handle an incoming signal with the given input.
    fn handle(&mut self, ctx: &mut WorkflowContext<Self>, input: S::Input);
}

/// Trait for executing asynchronous signal handlers on a workflow.
///
/// Async signal handlers access state via `ctx.state()` or `ctx.state_mut()`.
#[doc(hidden)]
pub trait ExecutableAsyncSignal<S: SignalDefinition>: WorkflowImplementation {
    /// Handle an incoming signal with the given input.
    fn handle(ctx: WorkflowContext<Self>, input: S::Input) -> LocalBoxFuture<'static, ()>;
}

/// Trait for executing query handlers on a workflow.
///
/// Queries are read-only operations that do not mutate workflow state.
/// They must be synchronous (not async).
#[doc(hidden)]
pub trait ExecutableQuery<Q: QueryDefinition>: WorkflowImplementation {
    /// Handle a query with the given input and return the result.
    ///
    /// Queries take `&self` (immutable) and cannot modify workflow state.
    fn handle(&self, ctx: &WorkflowContextView, input: Q::Input) -> Q::Output;
}

/// Trait for executing synchronous update handlers on a workflow.
///
/// Sync update handlers take `&mut self` and execute without await points.
#[doc(hidden)]
pub trait ExecutableSyncUpdate<U: UpdateDefinition>: WorkflowImplementation {
    /// Handle an update with the given input and return the result.
    fn handle(&mut self, ctx: &mut WorkflowContext<Self>, input: U::Input) -> U::Output;

    /// Validate an update before it is applied.
    fn validate(&self, _ctx: &WorkflowContextView, _input: &U::Input) -> Result<(), String> {
        Ok(())
    }
}

/// Trait for executing asynchronous update handlers on a workflow.
///
/// Async update handlers access state via `ctx.state()` or `ctx.state_mut()`.
#[doc(hidden)]
pub trait ExecutableAsyncUpdate<U: UpdateDefinition>: WorkflowImplementation {
    /// Handle an update with the given input and return the result.
    fn handle(ctx: WorkflowContext<Self>, input: U::Input) -> LocalBoxFuture<'static, U::Output>;

    /// Validate an update before it is applied.
    fn validate(&self, _ctx: &WorkflowContextView, _input: &U::Input) -> Result<(), String> {
        Ok(())
    }
}

/// Trait implemented by workflow types to enable registration with workers.
///
/// This trait is automatically generated by the `#[workflow_methods]` macro.
#[doc(hidden)]
pub trait WorkflowImplementer: WorkflowImplementation {
    /// Register this workflow and all its handlers with the given definitions container.
    fn register_all(defs: &mut WorkflowDefinitions);
}

/// Type-erased trait for workflow execution instances.
///
/// This allows storing different workflow types in the same container.
pub(crate) trait DynWorkflowExecution {
    /// Poll the run future.
    fn poll_run(
        &mut self,
        cx: &mut TaskContext<'_>,
    ) -> Poll<Result<WfExitValue<Payload>, WorkflowError>>;

    /// Validate an update request. Returns `None` if no handler.
    fn validate_update(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<(), WorkflowError>>;

    /// Start an update handler. Returns `None` if no handler for that name.
    fn start_update(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'static, Result<Payload, WorkflowError>>>;

    /// Dispatch a signal by name. Returns `None` if no handler.
    fn dispatch_signal(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<LocalBoxFuture<'static, ()>, WorkflowError>>;

    /// Dispatch a query by name. Returns `None` if no handler.
    fn dispatch_query(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<Payload, WorkflowError>>;
}

/// Manages a workflow execution, holding the context and run future.
pub(crate) struct WorkflowExecution<W: WorkflowImplementation> {
    ctx: WorkflowContext<W>,
    /// The run future, wrapped in Fuse to safely handle re-polling after completion.
    run_future: Fuse<LocalBoxFuture<'static, Result<WfExitValue<Payload>, WorkflowError>>>,
}

impl<W: WorkflowImplementation> WorkflowExecution<W>
where
    <W::Run as WorkflowDefinition>::Input: Send,
{
    /// Create a new workflow execution using the workflow's `init` method.
    pub(crate) fn new(
        base_ctx: BaseWorkflowContext,
        init_input: Option<<W::Run as WorkflowDefinition>::Input>,
        run_input: Option<<W::Run as WorkflowDefinition>::Input>,
    ) -> Self {
        let view = WorkflowContextView::new();
        let workflow = W::init(&view, init_input);
        Self::new_with_workflow(workflow, base_ctx, run_input)
    }

    /// Create a new workflow execution from an already-created workflow instance.
    pub(crate) fn new_with_workflow(
        workflow: W,
        base_ctx: BaseWorkflowContext,
        run_input: Option<<W::Run as WorkflowDefinition>::Input>,
    ) -> Self {
        let workflow = Rc::new(RefCell::new(workflow));
        let ctx = WorkflowContext::from_base(base_ctx, workflow);
        let run_future = W::run(ctx.clone(), run_input).fuse();

        Self { ctx, run_future }
    }
}

impl<W: WorkflowImplementation> DynWorkflowExecution for WorkflowExecution<W> {
    fn poll_run(
        &mut self,
        cx: &mut TaskContext<'_>,
    ) -> Poll<Result<WfExitValue<Payload>, WorkflowError>> {
        Pin::new(&mut self.run_future).poll(cx)
    }

    fn validate_update(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<(), WorkflowError>> {
        let view = WorkflowContextView::new();
        self.ctx
            .state(|wf| wf.validate_update(&view, name, payloads, converter))
    }

    fn start_update(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'static, Result<Payload, WorkflowError>>> {
        W::dispatch_update(self.ctx.clone(), name, payloads, converter)
    }

    fn dispatch_signal(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<LocalBoxFuture<'static, ()>, WorkflowError>> {
        W::dispatch_signal(self.ctx.clone(), name, payloads, converter)
    }

    fn dispatch_query(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Option<Result<Payload, WorkflowError>> {
        let view = WorkflowContextView::new();
        self.ctx
            .state(|wf| wf.dispatch_query(&view, name, payloads, converter))
    }
}

/// Type alias for workflow execution factory functions.
///
/// Creates a new `WorkflowExecution` instance from the input payloads and context.
pub(crate) type WorkflowExecutionFactory = Arc<
    dyn Fn(
            Vec<Payload>,
            PayloadConverter,
            BaseWorkflowContext,
        ) -> Result<Box<dyn DynWorkflowExecution>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Contains all handlers for a single workflow type.
#[derive(Clone)]
struct WorkflowHandlers {
    factory: WorkflowExecutionFactory,
}

/// Contains workflow registrations in a form ready for execution by workers.
#[derive(Default, Clone)]
pub struct WorkflowDefinitions {
    /// Maps workflow type name to all handlers for that workflow
    workflows: HashMap<&'static str, WorkflowHandlers>,
}

impl WorkflowDefinitions {
    /// Creates a new empty `WorkflowDefinitions`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a workflow implementation.
    pub fn register_workflow<W: WorkflowImplementer>(&mut self) -> &mut Self {
        W::register_all(self);
        self
    }

    /// Register a specific workflow's run method.
    #[doc(hidden)]
    pub fn register_workflow_run<W: WorkflowImplementation>(&mut self) -> &mut Self
    where
        <W::Run as WorkflowDefinition>::Input: Send,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let factory: WorkflowExecutionFactory =
            Arc::new(move |payloads, converter: PayloadConverter, base_ctx| {
                let ser_ctx = SerializationContext {
                    data: &SerializationContextData::Workflow,
                    converter: &converter,
                };
                let input = converter.from_payloads(&ser_ctx, payloads)?;
                let (init_input, run_input) = if W::INIT_TAKES_INPUT {
                    (Some(input), None)
                } else {
                    (None, Some(input))
                };
                Ok(
                    Box::new(WorkflowExecution::<W>::new(base_ctx, init_input, run_input))
                        as Box<dyn DynWorkflowExecution>,
                )
            });
        self.workflows
            .insert(workflow_name, WorkflowHandlers { factory });
        self
    }

    /// Register a workflow with a custom factory for instance creation.
    pub fn register_workflow_run_with_factory<W, F>(&mut self, user_factory: F) -> &mut Self
    where
        W: WorkflowImplementation,
        <W::Run as WorkflowDefinition>::Input: Send,
        F: Fn() -> W + Send + Sync + 'static,
    {
        assert!(
            !W::HAS_INIT,
            "Workflows registered with a factory must not define an #[init] method. \
             The factory replaces init for instance creation."
        );

        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let user_factory = Arc::new(user_factory);
        let factory: WorkflowExecutionFactory =
            Arc::new(move |payloads, converter: PayloadConverter, base_ctx| {
                let ser_ctx = SerializationContext {
                    data: &SerializationContextData::Workflow,
                    converter: &converter,
                };
                let input: <W::Run as WorkflowDefinition>::Input =
                    converter.from_payloads(&ser_ctx, payloads)?;

                // User factory creates the instance - input always goes to run()
                let workflow = user_factory();
                Ok(Box::new(WorkflowExecution::<W>::new_with_workflow(
                    workflow,
                    base_ctx,
                    Some(input),
                )) as Box<dyn DynWorkflowExecution>)
            });

        self.workflows
            .insert(workflow_name, WorkflowHandlers { factory });
        self
    }

    /// Check if any workflows are registered.
    pub fn is_empty(&self) -> bool {
        self.workflows.is_empty()
    }

    /// Get the workflow execution factory for a given workflow type.
    pub(crate) fn get_workflow(&self, workflow_type: &str) -> Option<WorkflowExecutionFactory> {
        self.workflows.get(workflow_type).map(|h| h.factory.clone())
    }

    /// Returns an iterator over registered workflow type names.
    pub fn workflow_types(&self) -> impl Iterator<Item = &'static str> + '_ {
        self.workflows.keys().copied()
    }
}

impl Debug for WorkflowDefinitions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("WorkflowDefinitions")
            .field("workflows", &self.workflows.keys().collect::<Vec<_>>())
            .finish()
    }
}
