//! Functionality related to defining and interacting with workflows
//!
//! This module contains traits and types for implementing workflows using the
//! `#[workflow]` and `#[workflow_methods]` macros.
//!
//! Example usage:
//! ```
//! use temporalio_macros::{workflow, workflow_methods};
//! use temporalio_sdk::{WfExitValue, WorkflowContext, WorkflowContextView, WorkflowResult};
//!
//! #[workflow]
//! pub struct MyWorkflow {
//!     counter: u32,
//! }
//!
//! #[workflow_methods]
//! impl MyWorkflow {
//!     #[init]
//!     pub fn new(ctx: &WorkflowContextView, input: String) -> Self {
//!         Self { counter: 0 }
//!     }
//!
//!     // Async methods use &self - mutations go through ctx.state_mut()
//!     #[run]
//!     pub async fn run(&self, ctx: &mut WorkflowContext<Self>) -> WorkflowResult<String> {
//!         Ok(WfExitValue::Normal(format!(
//!             "Done with counter: {}",
//!             self.counter
//!         )))
//!     }
//!
//!     // Sync signals use &mut self for direct mutations
//!     #[signal]
//!     pub fn increment(&mut self, ctx: &mut WorkflowContext<Self>, amount: u32) {
//!         self.counter += amount;
//!     }
//!
//!     // Queries use &self with read-only context
//!     #[query]
//!     pub fn get_counter(&self, ctx: &WorkflowContextView) -> u32 {
//!         self.counter
//!     }
//! }
//! ```

use crate::{BaseWorkflowContext, WfExitValue, WorkflowContext, WorkflowContextView};
use futures_util::future::{BoxFuture, Fuse, FutureExt, LocalBoxFuture};
use std::{
    cell::RefCell,
    collections::HashMap,
    fmt::Debug,
    pin::Pin,
    rc::Rc,
    sync::Arc,
    task::{Context as TaskContext, Poll},
};
use temporalio_common::{
    QueryDefinition, SignalDefinition, UpdateDefinition, WorkflowDefinition,
    data_converters::{
        GenericPayloadConverter, PayloadConversionError, PayloadConverter, SerializationContext,
        SerializationContextData,
    },
    protos::temporal::api::{
        common::v1::{Payload, Payloads},
        failure::v1::Failure,
    },
};

/// Error type for workflow operations
#[derive(Debug, thiserror::Error)]
pub enum WorkflowError {
    /// Error during payload conversion
    #[error("Payload conversion error: {0}")]
    PayloadConversion(#[from] PayloadConversionError),

    /// Workflow execution error
    #[error("Workflow execution error: {0}")]
    Execution(#[from] anyhow::Error),
}

impl From<WorkflowError> for Failure {
    fn from(err: WorkflowError) -> Self {
        Failure {
            message: err.to_string(),
            ..Default::default()
        }
    }
}

/// Trait implemented by workflow structs to enable execution by the worker.
///
/// This trait is typically generated by the `#[workflow_methods]` macro and should not
/// be implemented manually in most cases.
///
/// The `WorkflowImplementation` trait provides:
/// - Initialization from serialized input
/// - Execution of the main workflow function
#[doc(hidden)]
pub trait WorkflowImplementation: Sized + 'static {
    /// The marker struct for the run method that implements `WorkflowDefinition`
    type Run: WorkflowDefinition;

    /// Whether this workflow has a user-defined `#[init]` method.
    /// Set to `true` by the macro when `#[init]` is present, `false` otherwise.
    const HAS_INIT: bool;

    /// Whether the init method accepts the workflow input.
    /// If true, input goes to init. If false, input goes to run.
    const INIT_TAKES_INPUT: bool;

    /// Initialize the workflow instance.
    ///
    /// This is called when a new workflow execution starts. If `INIT_TAKES_INPUT` is true,
    /// `input` will be `Some`. Otherwise it's `None`.
    fn init(
        ctx: &WorkflowContextView,
        input: Option<<Self::Run as WorkflowDefinition>::Input>,
    ) -> Self;

    /// Execute the workflow's main run function.
    ///
    /// Takes `&self` instead of `&mut self`. For state mutations, use `ctx.state_mut()`.
    /// If `INIT_TAKES_INPUT` is false, `input` will be `Some`. Otherwise it's `None`.
    fn run(
        &self,
        ctx: WorkflowContext<Self>,
        input: Option<<Self::Run as WorkflowDefinition>::Input>,
    ) -> LocalBoxFuture<'_, Result<WfExitValue<Payload>, WorkflowError>>;

    /// Dispatch an update request by name. Returns `None` if no handler for that name.
    ///
    /// The default implementation returns `None`. The macro generates an override with a
    /// match statement dispatching to all registered update handlers.
    fn dispatch_update(
        &self,
        _ctx: WorkflowContext<Self>,
        _name: &str,
        _payloads: Payloads,
        _converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'_, Result<Payload, WorkflowError>>> {
        None
    }

    /// Validate an update request by name. Returns `Ok(true)` if valid, `Ok(false)` if no handler.
    ///
    /// The default implementation returns `Ok(false)`. The macro generates an override with a
    /// match statement dispatching to all registered update validators.
    fn validate_update(
        &self,
        _ctx: &WorkflowContextView,
        _name: &str,
        _payloads: &Payloads,
        _converter: &PayloadConverter,
    ) -> Result<bool, WorkflowError> {
        Ok(false)
    }

    /// Dispatch a signal by name. Returns `Ok(Some(future))` if handled, `Ok(None)` if no handler.
    ///
    /// For sync signals, the mutation happens immediately and returns a completed future.
    /// For async signals, returns a future that must be polled to completion.
    /// The default implementation returns `Ok(None)`. The macro generates an override.
    fn dispatch_signal(
        &self,
        _ctx: WorkflowContext<Self>,
        _name: &str,
        _payloads: Payloads,
        _converter: &PayloadConverter,
    ) -> Result<Option<LocalBoxFuture<'_, ()>>, WorkflowError> {
        Ok(None)
    }
}

/// Trait for executing synchronous signal handlers on a workflow.
///
/// Sync signal handlers take `&mut self` and execute without await points.
#[doc(hidden)]
pub trait ExecutableSyncSignal<S: SignalDefinition>: WorkflowImplementation {
    /// Handle an incoming signal with the given input.
    fn handle(&mut self, ctx: &mut WorkflowContext<Self>, input: S::Input);
}

/// Trait for executing asynchronous signal handlers on a workflow.
///
/// Async signal handlers take `&self` and use `ctx.state_mut()` for mutations.
#[doc(hidden)]
pub trait ExecutableAsyncSignal<S: SignalDefinition>: WorkflowImplementation {
    /// Handle an incoming signal with the given input.
    fn handle(&self, ctx: &mut WorkflowContext<Self>, input: S::Input) -> LocalBoxFuture<'_, ()>;
}

/// Trait for executing query handlers on a workflow.
///
/// Queries are read-only operations that do not mutate workflow state.
/// They must be synchronous (not async).
#[doc(hidden)]
pub trait ExecutableQuery<Q: QueryDefinition>: WorkflowImplementation {
    /// Handle a query with the given input and return the result.
    ///
    /// Queries take `&self` (immutable) and cannot modify workflow state.
    fn handle(&self, ctx: &WorkflowContextView, input: Q::Input) -> Q::Output;
}

/// Trait for executing synchronous update handlers on a workflow.
///
/// Sync update handlers take `&mut self` and execute without await points.
#[doc(hidden)]
pub trait ExecutableSyncUpdate<U: UpdateDefinition>: WorkflowImplementation {
    /// Handle an update with the given input and return the result.
    fn handle(&mut self, ctx: &mut WorkflowContext<Self>, input: U::Input) -> U::Output;

    /// Validate an update before it is applied.
    fn validate(&self, _ctx: &WorkflowContextView, _input: &U::Input) -> Result<(), String> {
        Ok(())
    }
}

/// Trait for executing asynchronous update handlers on a workflow.
///
/// Async update handlers take `&self` and use `ctx.state_mut()` for mutations.
#[doc(hidden)]
pub trait ExecutableAsyncUpdate<U: UpdateDefinition>: WorkflowImplementation {
    /// Handle an update with the given input and return the result.
    fn handle(
        &self,
        ctx: &mut WorkflowContext<Self>,
        input: U::Input,
    ) -> LocalBoxFuture<'_, U::Output>;

    /// Validate an update before it is applied.
    fn validate(&self, _ctx: &WorkflowContextView, _input: &U::Input) -> Result<(), String> {
        Ok(())
    }
}

/// Trait implemented by workflow types to enable registration with workers.
///
/// This trait is automatically generated by the `#[workflow_methods]` macro.
#[doc(hidden)]
pub trait WorkflowImplementer: WorkflowImplementation {
    /// Register this workflow and all its handlers with the given definitions container.
    fn register_all(defs: &mut WorkflowDefinitions);
}

/// Type-erased trait for workflow execution instances.
///
/// This allows storing different workflow types in the same container.
pub(crate) trait DynWorkflowExecution {
    /// Poll the run future.
    fn poll_run(
        &mut self,
        cx: &mut TaskContext<'_>,
    ) -> Poll<Result<WfExitValue<Payload>, WorkflowError>>;

    /// Validate an update request. Returns `Ok(true)` if valid, `Ok(false)` if no handler.
    fn validate_update(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Result<bool, WorkflowError>;

    /// Start an update handler. Returns `None` if no handler for that name.
    ///
    /// The returned future is transmuted to `'static` lifetime using the same safety
    /// guarantees as the run future.
    fn start_update(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'static, Result<Payload, WorkflowError>>>;

    /// Dispatch a signal by name. Returns `Ok(Some(future))` if handled, `Ok(None)` if no handler.
    ///
    /// The returned future is transmuted to `'static` lifetime using the same safety
    /// guarantees as the run future.
    fn dispatch_signal(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Result<Option<LocalBoxFuture<'static, ()>>, WorkflowError>;
}

/// Manages a workflow execution, holding the workflow state and the run future.
///
/// # Safety
///
/// This type uses unsafe code to store a future that borrows `&self` from the workflow.
/// The future is transmuted to `'static` lifetime for storage. This is safe because:
///
/// 1. The workflow state lives at a stable address inside `Rc<RefCell<W>>`
/// 2. The future's references to `&self` point to this stable location
/// 3. Between polls, the references in the future are "dormant" (not actively borrowed)
/// 4. `state_mut()` on `WorkflowContext` is only called between polls, never during
/// 5. Temporal's single-threaded execution model guarantees only one handler advances at a time
///
/// The key invariant: `borrow_mut()` on the RefCell only happens when the future is not
/// being polled, so there's never a conflict between the future's `&self` and a mutable borrow.
pub(crate) struct WorkflowExecution<W: WorkflowImplementation> {
    _workflow: Rc<RefCell<W>>,
    _ctx: WorkflowContext<W>,
    /// The run future, wrapped in Fuse to safely handle re-polling after completion.
    run_future: Fuse<LocalBoxFuture<'static, Result<WfExitValue<Payload>, WorkflowError>>>,
}

impl<W: WorkflowImplementation> WorkflowExecution<W>
where
    <W::Run as WorkflowDefinition>::Input: Send,
{
    /// Create a new workflow execution using the workflow's `init` method.
    pub(crate) fn new(
        base_ctx: BaseWorkflowContext,
        init_input: Option<<W::Run as WorkflowDefinition>::Input>,
        run_input: Option<<W::Run as WorkflowDefinition>::Input>,
    ) -> Self {
        let view = WorkflowContextView::new();
        let workflow = W::init(&view, init_input);
        Self::new_with_workflow(workflow, base_ctx, run_input)
    }

    /// Create a new workflow execution from an already-created workflow instance.
    pub(crate) fn new_with_workflow(
        workflow: W,
        base_ctx: BaseWorkflowContext,
        run_input: Option<<W::Run as WorkflowDefinition>::Input>,
    ) -> Self {
        let workflow = Rc::new(RefCell::new(workflow));
        let ctx = WorkflowContext::from_base(base_ctx, workflow.clone());

        // SAFETY: We bypass RefCell's borrow checking and transmute the lifetime to 'static.
        // This is safe because:
        // 1. The workflow data lives at a stable address inside the RefCell (heap-allocated)
        // 2. The Rc keeps the allocation alive for the lifetime of WorkflowExecution
        // 3. state_mut() uses borrow_mut() which is only called between polls, never during
        // 4. Temporal's single-threaded execution model ensures handlers don't overlap
        //
        // We use as_ptr() instead of borrow() because borrow() creates a Ref<W> that would
        // be dropped at the end of this block, invalidating the borrow.
        let run_future = {
            let wf_ptr = workflow.as_ptr();
            // SAFETY: The pointer remains valid because the Rc<RefCell<W>> is stored in self.
            let wf_ref: &W = unsafe { &*wf_ptr };
            let fut = wf_ref.run(ctx.clone(), run_input);
            // SAFETY: Transmute the lifetime from '_ (tied to wf_ref) to 'static.
            // See struct-level safety documentation for the full invariants.
            let static_fut = unsafe {
                std::mem::transmute::<
                    LocalBoxFuture<'_, Result<WfExitValue<Payload>, WorkflowError>>,
                    LocalBoxFuture<'static, Result<WfExitValue<Payload>, WorkflowError>>,
                >(fut)
            };
            // Fuse ensures polling after completion returns Pending instead of panicking
            static_fut.fuse()
        };

        Self {
            _workflow: workflow,
            _ctx: ctx,
            run_future,
        }
    }
}

impl<W: WorkflowImplementation> DynWorkflowExecution for WorkflowExecution<W> {
    fn poll_run(
        &mut self,
        cx: &mut TaskContext<'_>,
    ) -> Poll<Result<WfExitValue<Payload>, WorkflowError>> {
        Pin::new(&mut self.run_future).poll(cx)
    }

    fn validate_update(
        &self,
        name: &str,
        payloads: &Payloads,
        converter: &PayloadConverter,
    ) -> Result<bool, WorkflowError> {
        let wf = self._workflow.borrow();
        let view = WorkflowContextView::new();
        wf.validate_update(&view, name, payloads, converter)
    }

    fn start_update(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Option<LocalBoxFuture<'static, Result<Payload, WorkflowError>>> {
        // SAFETY: Same lifetime transmutation pattern as run_future.
        // The workflow lives in Rc<RefCell<W>> at a stable address.
        // Update futures borrow &self from this stable location.
        // state_mut() is only called between polls, never during.
        let wf_ptr = self._workflow.as_ptr();
        let wf_ref: &W = unsafe { &*wf_ptr };
        let ctx = self._ctx.clone();

        wf_ref
            .dispatch_update(ctx, name, payloads, converter)
            .map(|local_fut| {
                // SAFETY: Transmute to 'static. See struct-level safety docs.
                unsafe { std::mem::transmute(local_fut) }
            })
    }

    fn dispatch_signal(
        &mut self,
        name: &str,
        payloads: Payloads,
        converter: &PayloadConverter,
    ) -> Result<Option<LocalBoxFuture<'static, ()>>, WorkflowError> {
        // SAFETY: Same lifetime transmutation pattern as run_future and updates.
        let wf_ptr = self._workflow.as_ptr();
        let wf_ref: &W = unsafe { &*wf_ptr };
        let ctx = self._ctx.clone();

        wf_ref
            .dispatch_signal(ctx, name, payloads, converter)
            .map(|opt| {
                opt.map(|local_fut| {
                    // SAFETY: Transmute to 'static. See struct-level safety docs.
                    unsafe { std::mem::transmute(local_fut) }
                })
            })
    }
}

/// Type alias for workflow execution factory functions.
///
/// Creates a new `WorkflowExecution` instance from the input payloads and context.
pub(crate) type WorkflowExecutionFactory = Arc<
    dyn Fn(
            Vec<Payload>,
            PayloadConverter,
            BaseWorkflowContext,
        ) -> Result<Box<dyn DynWorkflowExecution>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for signal handler functions
pub(crate) type SignalHandler = Arc<
    dyn Fn(Payload, PayloadConverter) -> Result<BoxFuture<'static, ()>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for query handler functions
pub(crate) type QueryHandler =
    Arc<dyn Fn(Payload, PayloadConverter) -> Result<Payload, PayloadConversionError> + Send + Sync>;

/// Type alias for update handler functions
pub(crate) type UpdateHandler = Arc<
    dyn Fn(Payload, PayloadConverter) -> Result<BoxFuture<'static, Payload>, PayloadConversionError>
        + Send
        + Sync,
>;

/// Type alias for update validator functions
pub(crate) type UpdateValidator =
    Arc<dyn Fn(&Payload, &PayloadConverter) -> Result<(), String> + Send + Sync>;

/// Contains all handlers for a single workflow type.
#[derive(Clone)]
struct WorkflowHandlers {
    factory: WorkflowExecutionFactory,
    signals: HashMap<&'static str, SignalHandler>,
    queries: HashMap<&'static str, QueryHandler>,
    updates: HashMap<&'static str, (UpdateHandler, UpdateValidator)>,
}

/// Contains workflow registrations in a form ready for execution by workers.
#[derive(Default, Clone)]
pub struct WorkflowDefinitions {
    /// Maps workflow type name to all handlers for that workflow
    workflows: HashMap<&'static str, WorkflowHandlers>,
}

impl WorkflowDefinitions {
    /// Creates a new empty `WorkflowDefinitions`.
    pub fn new() -> Self {
        Self::default()
    }

    /// Register a workflow implementation.
    pub fn register_workflow<W: WorkflowImplementer>(&mut self) -> &mut Self {
        W::register_all(self);
        self
    }

    /// Register a specific workflow's run method.
    #[doc(hidden)]
    pub fn register_workflow_run<W: WorkflowImplementation>(&mut self) -> &mut Self
    where
        <W::Run as WorkflowDefinition>::Input: Send,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let factory: WorkflowExecutionFactory =
            Arc::new(move |payloads, converter: PayloadConverter, base_ctx| {
                let ser_ctx = SerializationContext {
                    data: &SerializationContextData::Workflow,
                    converter: &converter,
                };
                let input = converter.from_payloads(&ser_ctx, payloads)?;
                let (init_input, run_input) = if W::INIT_TAKES_INPUT {
                    (Some(input), None)
                } else {
                    (None, Some(input))
                };
                Ok(
                    Box::new(WorkflowExecution::<W>::new(base_ctx, init_input, run_input))
                        as Box<dyn DynWorkflowExecution>,
                )
            });
        self.workflows.insert(
            workflow_name,
            WorkflowHandlers {
                factory,
                signals: HashMap::new(),
                queries: HashMap::new(),
                updates: HashMap::new(),
            },
        );
        self
    }

    /// Register a workflow with a custom factory for instance creation.
    pub fn register_workflow_run_with_factory<W, F>(&mut self, user_factory: F) -> &mut Self
    where
        W: WorkflowImplementation,
        <W::Run as WorkflowDefinition>::Input: Send,
        F: Fn() -> W + Send + Sync + 'static,
    {
        assert!(
            !W::HAS_INIT,
            "Workflows registered with a factory must not define an #[init] method. \
             The factory replaces init for instance creation."
        );

        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let user_factory = Arc::new(user_factory);
        let factory: WorkflowExecutionFactory =
            Arc::new(move |payloads, converter: PayloadConverter, base_ctx| {
                let ser_ctx = SerializationContext {
                    data: &SerializationContextData::Workflow,
                    converter: &converter,
                };
                let input: <W::Run as WorkflowDefinition>::Input =
                    converter.from_payloads(&ser_ctx, payloads)?;

                // User factory creates the instance - input always goes to run()
                let workflow = user_factory();
                Ok(Box::new(WorkflowExecution::<W>::new_with_workflow(
                    workflow,
                    base_ctx,
                    Some(input),
                )) as Box<dyn DynWorkflowExecution>)
            });

        self.workflows.insert(
            workflow_name,
            WorkflowHandlers {
                factory,
                signals: HashMap::new(),
                queries: HashMap::new(),
                updates: HashMap::new(),
            },
        );
        self
    }

    /// Register a synchronous signal handler for a workflow.
    #[doc(hidden)]
    pub fn register_signal<W, S>(&mut self) -> &mut Self
    where
        W: ExecutableSyncSignal<S>,
        S: SignalDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let signal_name = S::name();

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before signals")
            .signals
            .insert(
                signal_name,
                Arc::new(move |_payload, _converter| {
                    // Signal handlers will be invoked through the workflow instance
                    // TODO: Implement actual dispatch
                    todo!("Sync signal dispatch implementation")
                }),
            );
        self
    }

    /// Register an asynchronous signal handler for a workflow.
    #[doc(hidden)]
    pub fn register_async_signal<W, S>(&mut self) -> &mut Self
    where
        W: ExecutableAsyncSignal<S>,
        S: SignalDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let signal_name = S::name();

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before signals")
            .signals
            .insert(
                signal_name,
                Arc::new(move |_payload, _converter| {
                    // Signal handlers will be invoked through the workflow instance
                    // TODO: Implement actual dispatch
                    todo!("Async signal dispatch implementation")
                }),
            );
        self
    }

    /// Register a query handler for a workflow.
    #[doc(hidden)]
    pub fn register_query<W, Q>(&mut self) -> &mut Self
    where
        W: ExecutableQuery<Q>,
        Q: QueryDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let query_name = Q::name();

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before queries")
            .queries
            .insert(
                query_name,
                Arc::new(move |_payload, _converter| {
                    // Query handlers will be invoked through the workflow instance
                    todo!("Query dispatch implementation")
                }),
            );
        self
    }

    /// Register a synchronous update handler for a workflow.
    #[doc(hidden)]
    pub fn register_update<W, U>(&mut self) -> &mut Self
    where
        W: ExecutableSyncUpdate<U>,
        U: UpdateDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let update_name = U::name();

        let handler: UpdateHandler = Arc::new(move |_payload, _converter| {
            // Update handlers will be invoked through the workflow instance
            // TODO: Implement actual dispatch
            todo!("Sync update dispatch implementation")
        });
        let validator: UpdateValidator = Arc::new(move |_payload, _converter| {
            // Validation will be invoked through the workflow instance
            Ok(())
        });

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before updates")
            .updates
            .insert(update_name, (handler, validator));
        self
    }

    /// Register an asynchronous update handler for a workflow.
    #[doc(hidden)]
    pub fn register_async_update<W, U>(&mut self) -> &mut Self
    where
        W: ExecutableAsyncUpdate<U>,
        U: UpdateDefinition,
    {
        let workflow_name = <W::Run as WorkflowDefinition>::name();
        let update_name = U::name();

        let handler: UpdateHandler = Arc::new(move |_payload, _converter| {
            // Update handlers will be invoked through the workflow instance
            // TODO: Implement actual dispatch
            todo!("Async update dispatch implementation")
        });
        let validator: UpdateValidator = Arc::new(move |_payload, _converter| {
            // Validation will be invoked through the workflow instance
            Ok(())
        });

        self.workflows
            .get_mut(workflow_name)
            .expect("Workflow must be registered before updates")
            .updates
            .insert(update_name, (handler, validator));
        self
    }

    /// Check if any workflows are registered.
    pub fn is_empty(&self) -> bool {
        self.workflows.is_empty()
    }

    /// Get the workflow execution factory for a given workflow type.
    pub(crate) fn get_workflow(&self, workflow_type: &str) -> Option<WorkflowExecutionFactory> {
        self.workflows.get(workflow_type).map(|h| h.factory.clone())
    }

    /// Get the signal handler for a given workflow and signal type.
    #[allow(dead_code)] // Remove once dispatch implemented
    pub(crate) fn get_signal(
        &self,
        workflow_type: &str,
        signal_name: &str,
    ) -> Option<SignalHandler> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.signals.get(signal_name))
            .cloned()
    }

    /// Get the query handler for a given workflow and query type.
    #[allow(dead_code)] // Remove once dispatch implemented
    pub(crate) fn get_query(&self, workflow_type: &str, query_name: &str) -> Option<QueryHandler> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.queries.get(query_name))
            .cloned()
    }

    /// Get the update handler and validator for a given workflow and update type.
    #[allow(dead_code)] // Remove once dispatch implemented
    pub(crate) fn get_update(
        &self,
        workflow_type: &str,
        update_name: &str,
    ) -> Option<(UpdateHandler, UpdateValidator)> {
        self.workflows
            .get(workflow_type)
            .and_then(|h| h.updates.get(update_name))
            .cloned()
    }

    /// Returns an iterator over registered workflow type names.
    pub fn workflow_types(&self) -> impl Iterator<Item = &'static str> + '_ {
        self.workflows.keys().copied()
    }
}

impl Debug for WorkflowDefinitions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("WorkflowDefinitions")
            .field("workflows", &self.workflows.keys().collect::<Vec<_>>())
            .finish()
    }
}
