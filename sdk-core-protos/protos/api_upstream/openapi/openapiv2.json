{
  "swagger": "2.0",
  "info": {
    "title": "temporal/api/workflowservice/v1/request_response.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "WorkflowService"
    },
    {
      "name": "OperatorService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/cluster-info": {
      "get": {
        "summary": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetClusterInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces": {
      "get": {
        "summary": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "RegisterNamespace creates a new namespace which can be used as a container for all resources.",
        "description": "A Namespace is a top level entity within Temporal, and is used as a container for resources\nlike workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\nisolation for all resources within the namespace. All resources belongs to exactly one\nnamespace.",
        "operationId": "RegisterNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceRequest"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}": {
      "get": {
        "summary": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCanceledById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete": {
      "post": {
        "summary": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\ntask.",
        "description": "This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCompletedById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\na new workflow task created for the workflow. Fails with `NotFound` if the task token is no\nlonger valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskFailedById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "summary": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.",
        "description": "If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\nthen it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\nthe workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\nsuch situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RecordActivityTaskHeartbeatById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/pause-by-id": {
      "post": {
        "summary": "PauseActivityById pauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.",
        "description": "Pausing an activity means:\n- If the activity is currently waiting for a retry or is running and subsequently fails,\n  it will not be rescheduled until it is unpaused.\n- If the activity is already paused, calling this method will have no effect.\n- If the activity is running and finishes successfully, the activity will be completed.\n- If the activity is running and finishes with failure:\n  * if there is no retry left - the activity will be completed.\n  * if there are more retries left - the activity will be paused.\nFor long-running activities:\n- activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n- The activity should respond to the cancellation accordingly.",
        "operationId": "PauseActivityById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PauseActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePauseActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/reset-by-id": {
      "post": {
        "summary": "ResetActivityById unpauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.\nResetting an activity means:\n* number of attempts will be reset to 0.\n* activity timeouts will be resetted.\nIf the activity currently running:\n*  if 'no_wait' flag is provided, a new instance of the activity will be scheduled immediately.\n*  if 'no_wait' flag is not provided, a new instance of the  activity will be scheduled after current instance completes if needed.\nIf 'reset_heartbeats' flag is set, the activity heartbeat timer and heartbeats will be reset.",
        "operationId": "ResetActivityById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/unpause-by-id": {
      "post": {
        "summary": "UnpauseActivityById unpauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.\nThere are two 'modes' of unpausing an activity:\n'resume' - If the activity is paused, it will be resumed and scheduled for execution.\n   * If the activity is currently running Unpause with 'resume' has no effect.\n   * if 'no_wait' flag is set and the activity is waiting, the activity will be scheduled immediately.\n'reset' - If the activity is paused, it will be reset to its initial state and (depending on parameters) scheduled for execution.\n   * If the activity is currently running, Unpause with 'reset' will reset the number of attempts.\n   * if 'no_wait' flag is set, the activity will be scheduled immediately.\n   * if 'reset_heartbeats' flag is set, the activity heartbeat timer and heartbeats will be reset.\nIf the activity is in waiting for retry and past it retry timeout, it will be scheduled immediately.\nOnce the activity is unpaused, all timeout timers will be regenerated.",
        "operationId": "UnpauseActivityById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UnpauseActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUnpauseActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/update-options-by-id": {
      "post": {
        "summary": "UpdateActivityOptionsById is called by the client to update the options of an activity",
        "operationId": "UpdateActivityOptionsById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateActivityOptionsByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateActivityOptionsByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/archived-workflows": {
      "get": {
        "summary": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListArchivedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations": {
      "get": {
        "summary": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListBatchOperationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "description": "List page size",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Next page token",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "summary": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Job ID defines the unique ID for the batch job",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "summary": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StopBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStopBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules": {
      "get": {
        "summary": "List all schedules in a namespace.",
        "operationId": "ListSchedules2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSchedulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list schedules in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "description": "How many to return at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Token to get the next page of results.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "Query to filter schedules.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "summary": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Creates a new schedule.",
        "operationId": "CreateSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace the schedule should be created in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the new schedule.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "summary": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListScheduleMatchingTimesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "startTime",
            "description": "Time range to query.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "endTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "summary": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PatchScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePatchScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "summary": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/search-attributes": {
      "get": {
        "summary": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSearchAttributesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue.name}": {
      "get": {
        "summary": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n  - List of pollers\n  - Workflow Reachability status\n  - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeTaskQueueResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.kind",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.\n\n - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history\n\nThe task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "default": "TASK_QUEUE_KIND_UNSPECIFIED"
          },
          {
            "name": "taskQueue.normalName",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "taskQueueType",
            "description": "Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.\nIf unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "default": "TASK_QUEUE_TYPE_UNSPECIFIED"
          },
          {
            "name": "includeTaskQueueStatus",
            "description": "Deprecated. Ignored in `ENHANCED` mode.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "apiMode",
            "description": "All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode.\n\n - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
              "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
            ],
            "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED"
          },
          {
            "name": "versions.buildIds",
            "description": "Include specific Build IDs.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "versions.unversioned",
            "description": "Include the unversioned queue.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "versions.allActive",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "taskQueueTypes",
            "description": "Task queue types to report info about. If not specified, all types are considered.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reportStats",
            "description": "Report stats for the requested task queue types and versions",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportPollers",
            "description": "Report list of pollers for requested task queue types and versions",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportTaskReachability",
            "description": "Report task reachability for the requested versions and all task types (task reachability is not reported\nper task type).",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "summary": "Deprecated. Use `GetWorkerVersioningRules`.\nFetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerBuildIdCompatibilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maxSets",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\ndefault major version set. 0 returns all sets.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "summary": "Fetches the Build ID assignment and redirect rules for a Task Queue.\nWARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerVersioningRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/update": {
      "post": {
        "summary": "UpdateNamespace is used to update the information and configuration of a registered\nnamespace.",
        "operationId": "UpdateNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateNamespaceBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "summary": "Deprecated. Use `DescribeTaskQueue`.",
        "description": "Fetches task reachability to determine whether a worker may be retired.\nThe request may specify task queues to query for or let the server fetch all task queues mapped to the given\nbuild IDs.\n\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerTaskReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "buildIds",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\nThe number of build ids that can be queried in a single API call is limited.\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "taskQueues",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\nbuild ids in the namespace.\nMust specify at least one task queue if querying for an unversioned worker.\nThe number of task queues that the server will fetch reachability information for is limited.\nSee the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reachability",
            "description": "Type of reachability to query for.\n`TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\nUse `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\nOtherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\nunspecified.\nSee the TaskReachability docstring for information about each enum variant.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_REACHABILITY_UNSPECIFIED",
              "TASK_REACHABILITY_NEW_WORKFLOWS",
              "TASK_REACHABILITY_EXISTING_WORKFLOWS",
              "TASK_REACHABILITY_OPEN_WORKFLOWS",
              "TASK_REACHABILITY_CLOSED_WORKFLOWS"
            ],
            "default": "TASK_REACHABILITY_UNSPECIFIED"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-count": {
      "get": {
        "summary": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows": {
      "get": {
        "summary": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "summary": "ExecuteMultiOperation executes multiple operations within a single workflow.",
        "description": "Operations are started atomically, meaning if *any* operation fails to be started, none are,\nand the request fails. Upon start, the API returns only when *all* operations have a response.\n\nUpon failure, it returns `MultiOperationExecutionFailure` where the status code\nequals the status code of the *first* operation that failed to be started.\n\nNOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ExecuteMultiOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceExecuteMultiOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}": {
      "get": {
        "summary": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history": {
      "get": {
        "summary": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n`NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\nthese, it should be passed here to fetch the next page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "waitNewEvent",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\nthe `history_event_filter_type`, or a timeout is hit.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "historyEventFilterType",
            "description": "Filter returned events such that they match the specified filter type.\nDefault: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
              "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
              "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
            ],
            "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
          },
          {
            "name": "skipArchival",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse": {
      "get": {
        "summary": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \norder (starting from last event). Fails with`NotFound` if the specified workflow execution is \nunknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryReverseResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}": {
      "post": {
        "summary": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1QueryWorkflowResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query.queryType",
            "description": "The workflow-author-defined identifier of the query. Typically a function name.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceQueryWorkflowBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel": {
      "post": {
        "summary": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\na workflow execution.",
        "description": "This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\nworkflow history and a new workflow task created for the workflow. It returns success if the requested\nworkflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RequestCancelWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRequestCancelWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset": {
      "post": {
        "summary": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n`WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\nexecution instance.\nTODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}": {
      "post": {
        "summary": "SignalWorkflowExecution is used to send a signal to a running workflow execution.",
        "description": "This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\ntask being created for the execution.",
        "operationId": "SignalWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate": {
      "post": {
        "summary": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n`WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\nexecution instance.",
        "operationId": "TerminateWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TerminateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTerminateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}": {
      "post": {
        "summary": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "request.input.name",
            "description": "The name of the Update handler to invoke on the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "summary": "StartWorkflowExecution starts a new workflow execution.",
        "description": "It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\nalso schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\ninstance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "summary": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\nit isn't yet started.",
        "description": "If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\nand a workflow task is generated.\n\nIf the workflow is not running or not found, then the workflow is created with\n`WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\nworkflow task is generated.",
        "operationId": "SignalWithStartWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWithStartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWithStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/nexus/endpoints": {
      "get": {
        "summary": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\nnext_page_token field of the previous response to get the next page of results. An empty next_page_token\nindicates that there are no more results. During pagination, a newly added service with an ID lexicographically\nearlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNexusEndpointsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\nresponse, the token will be empty if there's no other page.\nNote: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "name",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "post": {
        "summary": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\nALREADY_EXISTS.\nReturns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointRequest"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/nexus/endpoints/{id}": {
      "get": {
        "summary": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "delete": {
        "summary": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Data version for this endpoint. Must match current version.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/nexus/endpoints/{id}/update": {
      "post": {
        "summary": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n`ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\nmatch.\nReturns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\nneed to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/OperatorServiceUpdateNexusEndpointBody"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/system-info": {
      "get": {
        "summary": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetSystemInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster": {
      "get": {
        "summary": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetClusterInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces": {
      "get": {
        "summary": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "RegisterNamespace creates a new namespace which can be used as a container for all resources.",
        "description": "A Namespace is a top level entity within Temporal, and is used as a container for resources\nlike workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\nisolation for all resources within the namespace. All resources belongs to exactly one\nnamespace.",
        "operationId": "RegisterNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceRequest"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}": {
      "get": {
        "summary": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}/search-attributes": {
      "get": {
        "summary": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSearchAttributesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}/update": {
      "post": {
        "summary": "UpdateNamespace is used to update the information and configuration of a registered\nnamespace.",
        "operationId": "UpdateNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateNamespaceBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/nexus/endpoints": {
      "get": {
        "summary": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\nnext_page_token field of the previous response to get the next page of results. An empty next_page_token\nindicates that there are no more results. During pagination, a newly added service with an ID lexicographically\nearlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNexusEndpointsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\nresponse, the token will be empty if there's no other page.\nNote: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "name",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "post": {
        "summary": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\nALREADY_EXISTS.\nReturns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointRequest"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/nexus/endpoints/{id}": {
      "get": {
        "summary": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "delete": {
        "summary": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Data version for this endpoint. Must match current version.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/nexus/endpoints/{id}/update": {
      "post": {
        "summary": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n`ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\nmatch.\nReturns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\nneed to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/OperatorServiceUpdateNexusEndpointBody"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/cancel": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCanceledById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/complete": {
      "post": {
        "summary": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\ntask.",
        "description": "This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCompletedById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/fail": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\na new workflow task created for the workflow. Fails with `NotFound` if the task token is no\nlonger valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskFailedById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "summary": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.",
        "description": "If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\nthen it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\nthe workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\nsuch situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RecordActivityTaskHeartbeatById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/pause-by-id": {
      "post": {
        "summary": "PauseActivityById pauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.",
        "description": "Pausing an activity means:\n- If the activity is currently waiting for a retry or is running and subsequently fails,\n  it will not be rescheduled until it is unpaused.\n- If the activity is already paused, calling this method will have no effect.\n- If the activity is running and finishes successfully, the activity will be completed.\n- If the activity is running and finishes with failure:\n  * if there is no retry left - the activity will be completed.\n  * if there are more retries left - the activity will be paused.\nFor long-running activities:\n- activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n- The activity should respond to the cancellation accordingly.",
        "operationId": "PauseActivityById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PauseActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePauseActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/reset-by-id": {
      "post": {
        "summary": "ResetActivityById unpauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.\nResetting an activity means:\n* number of attempts will be reset to 0.\n* activity timeouts will be resetted.\nIf the activity currently running:\n*  if 'no_wait' flag is provided, a new instance of the activity will be scheduled immediately.\n*  if 'no_wait' flag is not provided, a new instance of the  activity will be scheduled after current instance completes if needed.\nIf 'reset_heartbeats' flag is set, the activity heartbeat timer and heartbeats will be reset.",
        "operationId": "ResetActivityById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/unpause-by-id": {
      "post": {
        "summary": "UnpauseActivityById unpauses the execution of an activity specified by its ID.\nReturns a `NotFound` error if there is no pending activity with the provided ID.\nThere are two 'modes' of unpausing an activity:\n'resume' - If the activity is paused, it will be resumed and scheduled for execution.\n   * If the activity is currently running Unpause with 'resume' has no effect.\n   * if 'no_wait' flag is set and the activity is waiting, the activity will be scheduled immediately.\n'reset' - If the activity is paused, it will be reset to its initial state and (depending on parameters) scheduled for execution.\n   * If the activity is currently running, Unpause with 'reset' will reset the number of attempts.\n   * if 'no_wait' flag is set, the activity will be scheduled immediately.\n   * if 'reset_heartbeats' flag is set, the activity heartbeat timer and heartbeats will be reset.\nIf the activity is in waiting for retry and past it retry timeout, it will be scheduled immediately.\nOnce the activity is unpaused, all timeout timers will be regenerated.",
        "operationId": "UnpauseActivityById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UnpauseActivityByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUnpauseActivityByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/update-options-by-id": {
      "post": {
        "summary": "UpdateActivityOptionsById is called by the client to update the options of an activity",
        "operationId": "UpdateActivityOptionsById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateActivityOptionsByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateActivityOptionsByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/archived-workflows": {
      "get": {
        "summary": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListArchivedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations": {
      "get": {
        "summary": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListBatchOperationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "description": "List page size",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Next page token",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "summary": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Job ID defines the unique ID for the batch job",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "summary": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StopBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStopBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules": {
      "get": {
        "summary": "List all schedules in a namespace.",
        "operationId": "ListSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSchedulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list schedules in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "description": "How many to return at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Token to get the next page of results.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "Query to filter schedules.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "summary": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Creates a new schedule.",
        "operationId": "CreateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace the schedule should be created in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the new schedule.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "summary": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListScheduleMatchingTimesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "startTime",
            "description": "Time range to query.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "endTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "summary": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PatchScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePatchScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "summary": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue.name}": {
      "get": {
        "summary": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n  - List of pollers\n  - Workflow Reachability status\n  - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeTaskQueueResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.kind",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.\n\n - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history\n\nThe task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "default": "TASK_QUEUE_KIND_UNSPECIFIED"
          },
          {
            "name": "taskQueue.normalName",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "taskQueueType",
            "description": "Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.\nIf unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "default": "TASK_QUEUE_TYPE_UNSPECIFIED"
          },
          {
            "name": "includeTaskQueueStatus",
            "description": "Deprecated. Ignored in `ENHANCED` mode.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "apiMode",
            "description": "All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode.\n\n - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
              "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
            ],
            "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED"
          },
          {
            "name": "versions.buildIds",
            "description": "Include specific Build IDs.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "versions.unversioned",
            "description": "Include the unversioned queue.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "versions.allActive",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "taskQueueTypes",
            "description": "Task queue types to report info about. If not specified, all types are considered.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reportStats",
            "description": "Report stats for the requested task queue types and versions",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportPollers",
            "description": "Report list of pollers for requested task queue types and versions",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportTaskReachability",
            "description": "Report task reachability for the requested versions and all task types (task reachability is not reported\nper task type).",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "summary": "Deprecated. Use `GetWorkerVersioningRules`.\nFetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerBuildIdCompatibilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maxSets",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\ndefault major version set. 0 returns all sets.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "summary": "Fetches the Build ID assignment and redirect rules for a Task Queue.\nWARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerVersioningRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "summary": "Deprecated. Use `DescribeTaskQueue`.",
        "description": "Fetches task reachability to determine whether a worker may be retired.\nThe request may specify task queues to query for or let the server fetch all task queues mapped to the given\nbuild IDs.\n\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerTaskReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "buildIds",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\nThe number of build ids that can be queried in a single API call is limited.\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "taskQueues",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\nbuild ids in the namespace.\nMust specify at least one task queue if querying for an unversioned worker.\nThe number of task queues that the server will fetch reachability information for is limited.\nSee the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reachability",
            "description": "Type of reachability to query for.\n`TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\nUse `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\nOtherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\nunspecified.\nSee the TaskReachability docstring for information about each enum variant.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_REACHABILITY_UNSPECIFIED",
              "TASK_REACHABILITY_NEW_WORKFLOWS",
              "TASK_REACHABILITY_EXISTING_WORKFLOWS",
              "TASK_REACHABILITY_OPEN_WORKFLOWS",
              "TASK_REACHABILITY_CLOSED_WORKFLOWS"
            ],
            "default": "TASK_REACHABILITY_UNSPECIFIED"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflow-count": {
      "get": {
        "summary": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows": {
      "get": {
        "summary": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "summary": "ExecuteMultiOperation executes multiple operations within a single workflow.",
        "description": "Operations are started atomically, meaning if *any* operation fails to be started, none are,\nand the request fails. Upon start, the API returns only when *all* operations have a response.\n\nUpon failure, it returns `MultiOperationExecutionFailure` where the status code\nequals the status code of the *first* operation that failed to be started.\n\nNOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ExecuteMultiOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceExecuteMultiOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}": {
      "get": {
        "summary": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/history": {
      "get": {
        "summary": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n`NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\nthese, it should be passed here to fetch the next page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "waitNewEvent",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\nthe `history_event_filter_type`, or a timeout is hit.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "historyEventFilterType",
            "description": "Filter returned events such that they match the specified filter type.\nDefault: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
              "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
              "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
            ],
            "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
          },
          {
            "name": "skipArchival",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse": {
      "get": {
        "summary": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \norder (starting from last event). Fails with`NotFound` if the specified workflow execution is \nunknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryReverseResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}": {
      "post": {
        "summary": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1QueryWorkflowResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query.queryType",
            "description": "The workflow-author-defined identifier of the query. Typically a function name.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceQueryWorkflowBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel": {
      "post": {
        "summary": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\na workflow execution.",
        "description": "This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\nworkflow history and a new workflow task created for the workflow. It returns success if the requested\nworkflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RequestCancelWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRequestCancelWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset": {
      "post": {
        "summary": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n`WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\nexecution instance.\nTODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}": {
      "post": {
        "summary": "SignalWorkflowExecution is used to send a signal to a running workflow execution.",
        "description": "This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\ntask being created for the execution.",
        "operationId": "SignalWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate": {
      "post": {
        "summary": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n`WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\nexecution instance.",
        "operationId": "TerminateWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TerminateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTerminateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}": {
      "post": {
        "summary": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "request.input.name",
            "description": "The name of the Update handler to invoke on the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "summary": "StartWorkflowExecution starts a new workflow execution.",
        "description": "It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\nalso schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\ninstance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "summary": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\nit isn't yet started.",
        "description": "If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\nand a workflow task is generated.\n\nIf the workflow is not running or not found, then the workflow is created with\n`WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\nworkflow task is generated.",
        "operationId": "SignalWithStartWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWithStartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWithStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/system-info": {
      "get": {
        "summary": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetSystemInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    }
  },
  "definitions": {
    "CallbackInfoTrigger": {
      "type": "object",
      "properties": {
        "workflowClosed": {
          "$ref": "#/definitions/CallbackInfoWorkflowClosed"
        }
      }
    },
    "CallbackInfoWorkflowClosed": {
      "type": "object",
      "description": "Trigger for when the workflow is closed."
    },
    "CallbackInternal": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "description": "Opaque internal data."
        }
      },
      "description": "Callbacks to be delivered internally within the system.\nThis variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.\nThe only reason that this is exposed is because callbacks are replicated across clusters via the\nWorkflowExecutionStarted event, which is defined in the public API."
    },
    "CallbackNexus": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "Callback URL."
        },
        "header": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to callback request."
        }
      }
    },
    "CountWorkflowExecutionsResponseAggregationGroup": {
      "type": "object",
      "properties": {
        "groupValues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Payload"
          }
        },
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "EndpointTargetExternal": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "URL to call."
        }
      },
      "description": "Target an external server by URL.\nAt a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected\ninto the server to modify the request."
    },
    "EndpointTargetWorker": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace to route requests to."
        },
        "taskQueue": {
          "type": "string",
          "description": "Nexus task queue to route requests to."
        }
      },
      "description": "Target a worker polling on a Nexus task queue in a specific namespace."
    },
    "ExecuteMultiOperationRequestOperation": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1StartWorkflowExecutionRequest",
          "title": "Additional restrictions:\n- setting `cron_schedule` is invalid\n- setting `request_eager_execution` is invalid\n- setting `workflow_start_delay` is invalid"
        },
        "updateWorkflow": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionRequest",
          "title": "Additional restrictions:\n- setting `first_execution_run_id` is invalid\n- setting `workflow_execution.run_id` is invalid"
        }
      }
    },
    "LinkBatchJob": {
      "type": "object",
      "properties": {
        "jobId": {
          "type": "string"
        }
      },
      "description": "A link to a built-in batch job.\nBatch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).\nThis link can be put on workflow history events generated by actions taken by a batch job."
    },
    "LinkWorkflowEvent": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "eventRef": {
          "$ref": "#/definitions/WorkflowEventEventReference"
        }
      }
    },
    "OperatorServiceUpdateNexusEndpointBody": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Data version for this endpoint. Must match current version."
        },
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec"
        }
      }
    },
    "StartOperationResponseAsync": {
      "type": "object",
      "properties": {
        "operationId": {
          "type": "string"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apinexusv1Link"
          }
        }
      },
      "description": "The operation will complete asynchronously.\nThe returned ID can be used to reference this operation."
    },
    "StartOperationResponseSync": {
      "type": "object",
      "properties": {
        "payload": {
          "$ref": "#/definitions/v1Payload"
        }
      },
      "description": "An operation completed successfully."
    },
    "UnpauseActivityByIdRequestResetOperation": {
      "type": "object",
      "properties": {
        "noWait": {
          "type": "boolean",
          "description": "Indicates that the activity should be scheduled immediately.\nNote that this may run simultaneously with any existing executions of the activity."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "title": "If set, the Heartbeat Details will be cleared out to make the Activity start over from the beginning"
        }
      }
    },
    "UnpauseActivityByIdRequestResumeOperation": {
      "type": "object",
      "properties": {
        "noWait": {
          "type": "boolean",
          "description": "Indicates that if the activity is waiting to retry, it will  be scheduled immediately."
        }
      }
    },
    "UpdateWorkerBuildIdCompatibilityRequestAddNewCompatibleVersion": {
      "type": "object",
      "properties": {
        "newBuildId": {
          "type": "string",
          "description": "A new id to be added to an existing compatible set."
        },
        "existingCompatibleBuildId": {
          "type": "string",
          "description": "A build id which must already exist in the version sets known by the task queue. The new\nid will be stored in the set containing this id, marking it as compatible with\nthe versions within."
        },
        "makeSetDefault": {
          "type": "boolean",
          "description": "When set, establishes the compatible set being targeted as the overall default for the\nqueue. If a different set was the current default, the targeted set will replace it as\nthe new default."
        }
      }
    },
    "UpdateWorkerBuildIdCompatibilityRequestMergeSets": {
      "type": "object",
      "properties": {
        "primarySetBuildId": {
          "type": "string",
          "title": "A build ID in the set whose default will become the merged set default"
        },
        "secondarySetBuildId": {
          "type": "string",
          "title": "A build ID in the set which will be merged into the primary set"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestAddCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        }
      },
      "description": "Adds the rule to the list of redirect rules for this Task Queue. There\ncan be at most one redirect rule for each distinct Source Build ID."
    },
    "UpdateWorkerVersioningRulesRequestCommitBuildId": {
      "type": "object",
      "properties": {
        "targetBuildId": {
          "type": "string"
        },
        "force": {
          "type": "boolean",
          "description": "To prevent committing invalid Build IDs, we reject the request if no\npollers has been seen recently for this Build ID. Use the `force`\noption to disable this validation."
        }
      },
      "description": "This command is intended to be used to complete the rollout of a Build\nID and cleanup unnecessary rules possibly created during a gradual\nrollout. Specifically, this command will make the following changes\natomically:\n 1. Adds an assignment rule (with full ramp) for the target Build ID at\n    the end of the list.\n 2. Removes all previously added assignment rules to the given target\n    Build ID (if any).\n 3. Removes any fully-ramped assignment rule for other Build IDs."
    },
    "UpdateWorkerVersioningRulesRequestDeleteBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32"
        },
        "force": {
          "type": "boolean",
          "title": "By default presence of one unconditional rule is enforced, otherwise\nthe delete operation will be rejected. Set `force` to true to\nbypass this validation. An unconditional assignment rule:\n  - Has no hint filter\n  - Has no ramp"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestDeleteCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "sourceBuildId": {
          "type": "string"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestInsertBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32",
          "description": "Use this option to insert the rule in a particular index. By\ndefault, the new rule is inserted at the beginning of the list\n(index 0). If the given index is too larger the rule will be\ninserted at the end of the list."
        },
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        }
      },
      "description": "Inserts the rule to the list of assignment rules for this Task Queue.\nThe rules are evaluated in order, starting from index 0. The first\napplicable rule will be applied and the rest will be ignored."
    },
    "UpdateWorkerVersioningRulesRequestReplaceBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32"
        },
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        },
        "force": {
          "type": "boolean",
          "title": "By default presence of one unconditional rule is enforced, otherwise\nthe replace operation will be rejected. Set `force` to true to\nbypass this validation. An unconditional assignment rule:\n  - Has no hint filter\n  - Has no ramp"
        }
      },
      "description": "Replaces the assignment rule at a given index."
    },
    "UpdateWorkerVersioningRulesRequestReplaceCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        }
      },
      "description": "Replaces the routing rule with the given source Build ID."
    },
    "WorkflowEventEventReference": {
      "type": "object",
      "properties": {
        "eventId": {
          "type": "string",
          "format": "int64"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        }
      }
    },
    "WorkflowServiceCreateScheduleBody": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "description": "The schedule spec, policies, action, and initial state."
        },
        "initialPatch": {
          "$ref": "#/definitions/v1SchedulePatch",
          "description": "Optional initial patch (e.g. to run the action once immediately)."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this create request for idempotence. Typically UUIDv4."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo",
          "description": "Memo and search attributes to attach to the schedule itself."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "WorkflowServiceExecuteMultiOperationBody": {
      "type": "object",
      "properties": {
        "operations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ExecuteMultiOperationRequestOperation"
          },
          "description": "List of operations to execute within a single workflow.\n\nPreconditions:\n- The list of operations must not be empty.\n- The workflow ids must match across operations.\n- The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.\n\nNote that additional operation-specific restrictions have to be considered."
        }
      }
    },
    "WorkflowServicePatchScheduleBody": {
      "type": "object",
      "properties": {
        "patch": {
          "$ref": "#/definitions/v1SchedulePatch"
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
        }
      }
    },
    "WorkflowServicePauseActivityByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "description": "ID of the workflow which scheduled this activity."
        },
        "runId": {
          "type": "string",
          "description": "Run ID of the workflow which scheduled this activity.\nIf empty - latest workflow is used."
        },
        "activityId": {
          "type": "string",
          "description": "ID of the activity we're updating."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "Used to de-dupe requests."
        }
      }
    },
    "WorkflowServiceQueryWorkflowBody": {
      "type": "object",
      "properties": {
        "execution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "query": {
          "type": "object",
          "properties": {
            "queryArgs": {
              "$ref": "#/definitions/v1Payloads",
              "description": "Serialized arguments that will be provided to the query handler."
            },
            "header": {
              "$ref": "#/definitions/v1Header",
              "description": "Headers that were passed by the caller of the query and copied by temporal \nserver into the workflow task."
            }
          },
          "title": "See https://docs.temporal.io/docs/concepts/queries/"
        },
        "queryRejectCondition": {
          "$ref": "#/definitions/v1QueryRejectCondition",
          "description": "QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.\nDefault: QUERY_REJECT_CONDITION_NONE."
        }
      }
    },
    "WorkflowServiceRecordActivityTaskHeartbeatBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arbitrary data, of which the most recent call is kept, to store for this activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRecordActivityTaskHeartbeatByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity we're heartbeating"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arbitrary data, of which the most recent call is kept, to store for this activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRequestCancelWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe cancellation requests"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionCanceled event."
        }
      }
    },
    "WorkflowServiceResetActivityByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "description": "ID of the workflow which scheduled this activity."
        },
        "runId": {
          "type": "string",
          "description": "Run ID of the workflow which scheduled this activity.\nIf empty - latest workflow is used."
        },
        "activityId": {
          "type": "string",
          "description": "ID of the activity we're updating."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "Used to de-dupe requests."
        },
        "noWait": {
          "type": "boolean",
          "description": "Indicates that activity should be scheduled immediately.\nIf this flag doesn't set, and activity currently running - temporal will wait until activity is completed."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "description": "Indicates that activity should reset heartbeat details.\nThis flag will be applied only to the new instance of the activity."
        }
      }
    },
    "WorkflowServiceResetWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "reason": {
          "type": "string"
        },
        "workflowTaskFinishEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n`WORKFLOW_TASK_STARTED` event to reset to."
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe reset requests"
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "title": "Event types to be reapplied (deprecated)\nDefault: RESET_REAPPLY_TYPE_SIGNAL"
        },
        "resetReapplyExcludeTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ResetReapplyExcludeType"
          },
          "title": "Event types not to be reapplied"
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCanceledBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the cancellation"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCanceledByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to confirm is cancelled"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the cancellation"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCompletedBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "The result of successfully executing the activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCompletedByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to complete"
        },
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "The serialized result of activity execution"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRespondActivityTaskFailedBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Detailed failure information"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional details to be stored as last activity heartbeat"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskFailedByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to fail"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Detailed failure information"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional details to be stored as last activity heartbeat"
        }
      }
    },
    "WorkflowServiceSignalWithStartWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "title": "The task queue to start this workflow on, if it will be started"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "title": "Total workflow execution timeout including retries and continue as new"
        },
        "workflowRunTimeout": {
          "type": "string",
          "title": "Timeout of a single workflow run"
        },
        "workflowTaskTimeout": {
          "type": "string",
          "title": "Timeout of a single workflow task"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe signal w/ start requests"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.\nNote that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "signalInput": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "title": "Retry policy for the workflow"
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nNote that the signal will be delivered with the first workflow task. If the workflow gets\nanother SignalWithStartWorkflow before the delay and `skip_generate_workflow_task` is false\nor not set, a workflow task will be dispatched immediately and the rest of the delay period\nwill be ignored, even if that request also had a delay. Signal via SignalWorkflowExecution\nwill not unblock the workflow."
        },
        "skipGenerateWorkflowTask": {
          "type": "boolean",
          "description": "Indicates that a new workflow task should not be generated when this signal is received."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events."
        }
      }
    },
    "WorkflowServiceSignalWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe sent signals"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "skipGenerateWorkflowTask": {
          "type": "boolean",
          "description": "Indicates that a new workflow task should not be generated when this signal is received."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionSignaled event."
        }
      }
    },
    "WorkflowServiceStartBatchOperationBody": {
      "type": "object",
      "properties": {
        "visibilityQuery": {
          "type": "string",
          "title": "Visibility query defines the the group of workflow to apply the batch operation\nThis field and `executions` are mutually exclusive"
        },
        "reason": {
          "type": "string",
          "title": "Reason to perform the batch operation"
        },
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecution"
          },
          "title": "Executions to apply the batch operation\nThis field and `visibility_query` are mutually exclusive"
        },
        "maxOperationsPerSecond": {
          "type": "number",
          "format": "float",
          "description": "Limit for the number of operations processed per second within this batch.\nIts purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system\noverload and minimize potential delays in executing ongoing tasks for user workers.\nNote that when no explicit limit is provided, the server will operate according to its limit defined by the\ndynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the\nserver's configured limit."
        },
        "terminationOperation": {
          "$ref": "#/definitions/v1BatchOperationTermination"
        },
        "signalOperation": {
          "$ref": "#/definitions/v1BatchOperationSignal"
        },
        "cancellationOperation": {
          "$ref": "#/definitions/v1BatchOperationCancellation"
        },
        "deletionOperation": {
          "$ref": "#/definitions/v1BatchOperationDeletion"
        },
        "resetOperation": {
          "$ref": "#/definitions/v1BatchOperationReset"
        }
      }
    },
    "WorkflowServiceStartWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this start request. Typically UUIDv4."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to get the first workflow task inline in the response bypassing matching service and worker polling.\nIf set to `true` the caller is expected to have a worker available and capable of processing the task.\nThe returned task will be marked as started and is expected to be completed by the specified\n`workflow_task_timeout`."
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "These values will be available as ContinuedFailure and LastCompletionResult in the\nWorkflowExecutionStarted event and through SDKs. The are currently only used by the\nserver itself (for the schedules feature) and are not intended to be exposed in\nStartWorkflowExecution."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nIf the workflow gets a signal before the delay, a workflow task will be dispatched and the rest\nof the delay will be ignored."
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Callbacks to be called by the server when this workflow reaches a terminal state.\nIf the workflow continues-as-new, these callbacks will be carried over to the new execution.\nCallback addresses must be whitelisted in the server's dynamic configuration."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the workflow."
        }
      }
    },
    "WorkflowServiceStopBatchOperationBody": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "title": "Reason to stop a batch operation"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the operator"
        }
      }
    },
    "WorkflowServiceTerminateWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "reason": {
          "type": "string"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the termination event"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionTerminated event."
        }
      }
    },
    "WorkflowServiceUnpauseActivityByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "description": "ID of the workflow which scheduled this activity."
        },
        "runId": {
          "type": "string",
          "description": "Run ID of the workflow which scheduled this activity.\nIf empty - latest workflow is used."
        },
        "activityId": {
          "type": "string",
          "description": "ID of the activity we're updating."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "Used to de-dupe requests."
        },
        "resume": {
          "$ref": "#/definitions/UnpauseActivityByIdRequestResumeOperation"
        },
        "reset": {
          "$ref": "#/definitions/UnpauseActivityByIdRequestResetOperation"
        }
      }
    },
    "WorkflowServiceUpdateActivityOptionsByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "ID of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run ID of the workflow which scheduled this activity\nif empty - latest workflow is used"
        },
        "activityId": {
          "type": "string",
          "title": "ID of the activity we're updating"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "title": "Activity options. Partial updates are accepted and controlled by update_mask"
        },
        "updateMask": {
          "type": "string",
          "title": "Controls which fields from `activity_options` will be applied"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe requests"
        }
      }
    },
    "WorkflowServiceUpdateNamespaceBody": {
      "type": "object",
      "properties": {
        "updateInfo": {
          "$ref": "#/definitions/v1UpdateNamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "securityToken": {
          "type": "string"
        },
        "deleteBadBinary": {
          "type": "string"
        },
        "promoteNamespace": {
          "type": "boolean",
          "description": "promote local namespace to global namespace. Ignored if namespace is already global namespace."
        }
      }
    },
    "WorkflowServiceUpdateScheduleBody": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "description": "The new schedule. The four main fields of the schedule (spec, action,\npolicies, state) are replaced completely by the values in this message."
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This can be the value of conflict_token from a DescribeScheduleResponse,\nwhich will cause this request to fail if the schedule has been modified\nbetween the Describe and this Update.\nIf missing, the schedule will be updated unconditionally."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes",
          "description": "Schedule search attributes to be updated.\nDo not set this field if you do not want to update the search attributes.\nA non-null empty object will set the search attributes to an empty map.\nNote: you cannot only update the search attributes with `UpdateScheduleRequest`,\nyou must also set the `schedule` field; otherwise, it will unset the schedule."
        }
      }
    },
    "WorkflowServiceUpdateWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "The target Workflow Id and (optionally) a specific Run Id thereof.",
          "title": "The target Workflow Id and (optionally) a specific Run Id thereof."
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no Run Id is set on\n`workflow_execution`), or specified (if it is) Workflow Execution is not\npart of the same execution chain as this Id."
        },
        "waitPolicy": {
          "$ref": "#/definitions/v1WaitPolicy",
          "description": "Specifies client's intent to wait for Update results.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached.\nActual reached stage will be included in the response."
        },
        "request": {
          "type": "object",
          "properties": {
            "meta": {
              "$ref": "#/definitions/v1Meta"
            },
            "input": {
              "type": "object",
              "properties": {
                "header": {
                  "$ref": "#/definitions/v1Header",
                  "description": "Headers that are passed with the Update from the requesting entity.\nThese can include things like auth or tracing tokens."
                },
                "args": {
                  "$ref": "#/definitions/v1Payloads",
                  "description": "The arguments to pass to the named Update handler."
                }
              }
            }
          },
          "description": "The request information that will be delivered all the way down to the\nWorkflow Execution.",
          "title": "The request information that will be delivered all the way down to the\nWorkflow Execution."
        }
      }
    },
    "apicommonv1Link": {
      "type": "object",
      "properties": {
        "workflowEvent": {
          "$ref": "#/definitions/LinkWorkflowEvent"
        },
        "batchJob": {
          "$ref": "#/definitions/LinkBatchJob"
        }
      },
      "description": "Link can be associated with history events. It might contain information about an external entity\nrelated to the history event. For example, workflow A makes a Nexus call that starts workflow B:\nin this case, a history event in workflow A could contain a Link to the workflow started event in\nworkflow B, and vice-versa."
    },
    "apifailurev1Failure": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "source": {
          "type": "string",
          "description": "The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK\nIn some SDKs this is used to rehydrate the stack trace into an exception object."
        },
        "stackTrace": {
          "type": "string"
        },
        "encodedAttributes": {
          "$ref": "#/definitions/v1Payload",
          "description": "Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of\nerrors originating in user code which might contain sensitive information.\nThe `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto\nmessage.\n\nSDK authors:\n- The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:\n  - Uses a JSON object to represent `{ message, stack_trace }`.\n  - Overwrites the original message with \"Encoded failure\" to indicate that more information could be extracted.\n  - Overwrites the original stack_trace with an empty string.\n  - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed\n    by the user-provided PayloadCodec\n\n- If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes."
        },
        "cause": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "applicationFailureInfo": {
          "$ref": "#/definitions/v1ApplicationFailureInfo"
        },
        "timeoutFailureInfo": {
          "$ref": "#/definitions/v1TimeoutFailureInfo"
        },
        "canceledFailureInfo": {
          "$ref": "#/definitions/v1CanceledFailureInfo"
        },
        "terminatedFailureInfo": {
          "$ref": "#/definitions/v1TerminatedFailureInfo"
        },
        "serverFailureInfo": {
          "$ref": "#/definitions/v1ServerFailureInfo"
        },
        "resetWorkflowFailureInfo": {
          "$ref": "#/definitions/v1ResetWorkflowFailureInfo"
        },
        "activityFailureInfo": {
          "$ref": "#/definitions/v1ActivityFailureInfo"
        },
        "childWorkflowExecutionFailureInfo": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailureInfo"
        },
        "nexusOperationExecutionFailureInfo": {
          "$ref": "#/definitions/v1NexusOperationFailureInfo"
        }
      }
    },
    "apinexusv1Failure": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "details": {
          "type": "string",
          "format": "byte"
        }
      },
      "title": "A general purpose failure message.\nSee: https://github.com/nexus-rpc/api/blob/main/SPEC.md#failure"
    },
    "apinexusv1Link": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#links."
        },
        "type": {
          "type": "string"
        }
      }
    },
    "apinexusv1Request": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers extracted from the original request in the Temporal frontend.\nWhen using Nexus over HTTP, this includes the request's HTTP headers ignoring multiple values."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "The timestamp when the request was scheduled in the frontend."
        },
        "startOperation": {
          "$ref": "#/definitions/v1StartOperationRequest"
        },
        "cancelOperation": {
          "$ref": "#/definitions/v1CancelOperationRequest"
        }
      },
      "description": "A Nexus request."
    },
    "apinexusv1Response": {
      "type": "object",
      "properties": {
        "startOperation": {
          "$ref": "#/definitions/v1StartOperationResponse"
        },
        "cancelOperation": {
          "$ref": "#/definitions/v1CancelOperationResponse"
        }
      },
      "description": "A response indicating that the handler has successfully processed a request."
    },
    "apiupdatev1Request": {
      "type": "object",
      "properties": {
        "meta": {
          "$ref": "#/definitions/v1Meta"
        },
        "input": {
          "$ref": "#/definitions/v1Input"
        }
      },
      "description": "The client request that triggers a Workflow Update."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1ActivityFailureInfo": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "identity": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityOptions": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\nretries will be attempted. Either this or `start_to_close_timeout` must be specified.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\ntimeout is always non retryable, as all a retry would achieve is to put it back into the same\nqueue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\nspecified.\n"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be\nspecified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        }
      }
    },
    "v1ActivityPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to."
        },
        "newRetryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "If set, update the retry policy of the activity, replacing it with the specified one.\nThe number of attempts at the activity is preserved."
        }
      }
    },
    "v1ActivityTaskCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1ActivityTaskCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional information that the activity reported upon confirming cancellation"
        },
        "latestCancelRequestedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same\nactivity"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker who canceled this activity"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
        }
      }
    },
    "v1ActivityTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized results of the activity. IE: The return value of the activity function"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that completed this task"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
        }
      }
    },
    "v1ActivityTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Failure details"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that failed this task"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. Use the info inside the corresponding ActivityTaskStartedEvent"
        }
      }
    },
    "v1ActivityTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string",
          "title": "The worker/user assigned identifier for the activity"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\nretries will be attempted. Either this or `start_to_close_timeout` must be specified.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\ntimeout is always non retryable, as all a retry would achieve is to put it back into the same\nqueue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\nspecified.\n"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be\nspecified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are assigned a default retry policy controlled by the service's dynamic\nconfiguration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set\nretry_policy.maximum_attempts to 1."
        },
        "useWorkflowBuildId": {
          "type": "boolean",
          "description": "If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,\nAssignment rules of the activity's Task Queue will be used to determine the Build ID."
        }
      }
    },
    "v1ActivityTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO ??"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times this task has been attempted"
        },
        "lastFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Will be set to the most recent failure details, if this task has previously failed and then\nbeen retried."
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker to whom this task was dispatched."
        },
        "buildIdRedirectCounter": {
          "type": "string",
          "format": "int64",
          "description": "Used by server internally to properly reapply build ID redirects to an execution\nwhen rebuilding it from events."
        }
      }
    },
    "v1ActivityTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "If this activity had failed, was retried, and then timed out, that failure is stored as the\n`cause` in here."
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a activity author to define the activity. Typically, the\nname of a function. This is sometimes referred to as the activity's \"name\""
    },
    "v1AddOrUpdateRemoteClusterResponse": {
      "type": "object"
    },
    "v1AddSearchAttributesResponse": {
      "type": "object"
    },
    "v1Alert": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "severity": {
          "$ref": "#/definitions/v1Severity"
        }
      },
      "description": "Alert contains notification and severity."
    },
    "v1ApplicationFailureInfo": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "nonRetryable": {
          "type": "boolean"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "nextRetryDelay": {
          "type": "string",
          "description": "next_retry_delay can be used by the client to override the activity\nretry interval calculated by the retry policy. Retry attempts will\nstill be subject to the maximum retries limit and total time limit\ndefined by the policy."
        }
      }
    },
    "v1ArchivalState": {
      "type": "string",
      "enum": [
        "ARCHIVAL_STATE_UNSPECIFIED",
        "ARCHIVAL_STATE_DISABLED",
        "ARCHIVAL_STATE_ENABLED"
      ],
      "default": "ARCHIVAL_STATE_UNSPECIFIED"
    },
    "v1BackfillRequest": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time range to evaluate schedule in. Currently, this time range is\nexclusive on start_time and inclusive on end_time. (This is admittedly\ncounterintuitive and it may change in the future, so to be safe, use a\nstart time strictly before a scheduled time.) Also note that an action\nnominally scheduled in the interval but with jitter that pushes it after\nend_time will not be included."
        },
        "endTime": {
          "type": "string",
          "format": "date-time"
        },
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "If set, override overlap policy for this request."
        }
      }
    },
    "v1BadBinaries": {
      "type": "object",
      "properties": {
        "binaries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1BadBinaryInfo"
          }
        }
      }
    },
    "v1BadBinaryInfo": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string"
        },
        "operator": {
          "type": "string"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1BatchOperationCancellation": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationCancellation sends cancel requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationDeletion": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationDeletion sends deletion requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest."
    },
    "v1BatchOperationInfo": {
      "type": "object",
      "properties": {
        "jobId": {
          "type": "string",
          "title": "Batch job ID"
        },
        "state": {
          "$ref": "#/definitions/v1BatchOperationState",
          "title": "Batch operation state"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation start time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation close time"
        }
      }
    },
    "v1BatchOperationReset": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "options": {
          "$ref": "#/definitions/v1ResetOptions",
          "description": "Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored."
        },
        "resetType": {
          "$ref": "#/definitions/v1ResetType",
          "description": "Reset type (deprecated, use `options`)."
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "description": "History event reapply options (deprecated, use `options`)."
        }
      },
      "description": "BatchOperationReset sends reset requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest."
    },
    "v1BatchOperationSignal": {
      "type": "object",
      "properties": {
        "signal": {
          "type": "string",
          "title": "The workflow author-defined name of the signal to send to the workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationSignal sends signals to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest."
    },
    "v1BatchOperationState": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_STATE_UNSPECIFIED",
        "BATCH_OPERATION_STATE_RUNNING",
        "BATCH_OPERATION_STATE_COMPLETED",
        "BATCH_OPERATION_STATE_FAILED"
      ],
      "default": "BATCH_OPERATION_STATE_UNSPECIFIED"
    },
    "v1BatchOperationTermination": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide to the termination event"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationTermination sends terminate requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationType": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_TYPE_UNSPECIFIED",
        "BATCH_OPERATION_TYPE_TERMINATE",
        "BATCH_OPERATION_TYPE_CANCEL",
        "BATCH_OPERATION_TYPE_SIGNAL",
        "BATCH_OPERATION_TYPE_DELETE",
        "BATCH_OPERATION_TYPE_RESET"
      ],
      "default": "BATCH_OPERATION_TYPE_UNSPECIFIED"
    },
    "v1BuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "targetBuildId": {
          "type": "string"
        },
        "percentageRamp": {
          "$ref": "#/definitions/v1RampByPercentage",
          "description": "This ramp is useful for gradual Blue/Green deployments (and similar)\nwhere you want to send a certain portion of the traffic to the target\nBuild ID."
        }
      },
      "description": "Assignment rules are applied to *new* Workflow and Activity executions at\nschedule time to assign them to a Build ID.\n\nAssignment rules will not be used in the following cases:\n   - Child Workflows or Continue-As-New Executions who inherit their\n     parent/previous Workflow's assigned Build ID (by setting the\n     `inherit_build_id` flag - default behavior in SDKs when the same Task Queue\n     is used.)\n   - An Activity that inherits the assigned Build ID of its Workflow (by\n     setting the `use_workflow_build_id` flag - default behavior in SDKs\n     when the same Task Queue is used.)\n\nIn absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)\nthe task will be dispatched to Workers of the Build ID determined by the\nassignment rules (or inherited). Otherwise, the final Build ID will be\ndetermined by the redirect rules.\n\nOnce a Workflow completes its first Workflow Task in a particular Build ID it\nstays in that Build ID regardless of changes to assignment rules. Redirect\nrules can be used to move the workflow to another compatible Build ID.\n\nWhen using Worker Versioning on a Task Queue, in the steady state,\nthere should typically be a single assignment rule to send all new executions\nto the latest Build ID. Existence of at least one such \"unconditional\"\nrule at all times is enforces by the system, unless the `force` flag is used\nby the user when replacing/deleting these rules (for exceptional cases).\n\nDuring a deployment, one or more additional rules can be added to assign a\nsubset of the tasks to a new Build ID based on a \"ramp percentage\".\n\nWhen there are multiple assignment rules for a Task Queue, the rules are\nevaluated in order, starting from index 0. The first applicable rule will be\napplied and the rest will be ignored.\n\nIn the event that no assignment rule is applicable on a task (or the Task\nQueue is simply not versioned), the tasks will be dispatched to an\nunversioned Worker."
    },
    "v1BuildIdReachability": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "A build id or empty if unversioned."
        },
        "taskQueueReachability": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueueReachability"
          },
          "description": "Reachability per task queue."
        }
      },
      "description": "Reachability of tasks for a worker by build id, in one or more task queues."
    },
    "v1BuildIdTaskReachability": {
      "type": "string",
      "enum": [
        "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
        "BUILD_ID_TASK_REACHABILITY_REACHABLE",
        "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
        "BUILD_ID_TASK_REACHABILITY_UNREACHABLE"
      ],
      "default": "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
      "description": "Specifies which category of tasks may reach a versioned worker of a certain Build ID.\n\nTask Reachability is eventually consistent; there may be a delay (up to few minutes) until it\nconverges to the most accurate value but it is designed in a way to take the more conservative\nside until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.\n\nNote: future activities who inherit their workflow's Build ID but not its Task Queue will not be\naccounted for reachability as server cannot know if they'll happen as they do not use\nassignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows\nwho inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make\nsure to query reachability for the parent/previous workflow's Task Queue as well.\n\n - BUILD_ID_TASK_REACHABILITY_UNSPECIFIED: Task reachability is not reported\n - BUILD_ID_TASK_REACHABILITY_REACHABLE: Build ID may be used by new workflows or activities (base on versioning rules), or there MAY\nbe open workflows or backlogged activities assigned to it.\n - BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY: Build ID does not have open workflows and is not reachable by new workflows,\nbut MAY have closed workflows within the namespace retention period.\nNot applicable to activity-only task queues.\n - BUILD_ID_TASK_REACHABILITY_UNREACHABLE: Build ID is not used for new executions, nor it has been used by any existing execution\nwithin the retention period."
    },
    "v1CalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "string",
          "title": "Expression to match seconds. Default: 0"
        },
        "minute": {
          "type": "string",
          "title": "Expression to match minutes. Default: 0"
        },
        "hour": {
          "type": "string",
          "title": "Expression to match hours. Default: 0"
        },
        "dayOfMonth": {
          "type": "string",
          "title": "Expression to match days of the month. Default: *"
        },
        "month": {
          "type": "string",
          "title": "Expression to match months. Default: *"
        },
        "year": {
          "type": "string",
          "title": "Expression to match years. Default: *"
        },
        "dayOfWeek": {
          "type": "string",
          "title": "Expression to match days of the week. Default: *"
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "description": "CalendarSpec describes an event specification relative to the calendar,\nsimilar to a traditional cron specification, but with labeled fields. Each\nfield can be one of:\n  *: matches always\n  x: matches when the field equals x\n  x/y : matches when the field equals x+n*y where n is an integer\n  x-z: matches when the field is between x and z inclusive\n  w,x,y,...: matches when the field is one of the listed values\nEach x, y, z, ... is either a decimal integer, or a month or day of week name\nor abbreviation (in the appropriate fields).\nA timestamp matches if all fields match.\nNote that fields have different default values, for convenience.\nNote that the special case that some cron implementations have for treating\nday_of_month and day_of_week as \"or\" instead of \"and\" when both are set is\nnot implemented.\nday_of_week can accept 0 or 7 as Sunday\nCalendarSpec gets compiled into StructuredCalendarSpec, which is what will be\nreturned if you describe the schedule."
    },
    "v1Callback": {
      "type": "object",
      "properties": {
        "nexus": {
          "$ref": "#/definitions/CallbackNexus"
        },
        "internal": {
          "$ref": "#/definitions/CallbackInternal"
        }
      },
      "description": "Callback to attach to various events in the system, e.g. workflow run completion."
    },
    "v1CallbackInfo": {
      "type": "object",
      "properties": {
        "callback": {
          "$ref": "#/definitions/v1Callback",
          "description": "Information on how this callback should be invoked (e.g. its URL and type)."
        },
        "trigger": {
          "$ref": "#/definitions/CallbackInfoTrigger",
          "description": "Trigger for this callback."
        },
        "registrationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the callback was registered."
        },
        "state": {
          "$ref": "#/definitions/v1CallbackState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the callback.\nThis number represents a minimum bound since the attempt is incremented after the callback request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        }
      },
      "description": "CallbackInfo contains the state of an attached workflow callback."
    },
    "v1CallbackState": {
      "type": "string",
      "enum": [
        "CALLBACK_STATE_UNSPECIFIED",
        "CALLBACK_STATE_STANDBY",
        "CALLBACK_STATE_SCHEDULED",
        "CALLBACK_STATE_BACKING_OFF",
        "CALLBACK_STATE_FAILED",
        "CALLBACK_STATE_SUCCEEDED"
      ],
      "default": "CALLBACK_STATE_UNSPECIFIED",
      "description": "State of a callback.\n\n - CALLBACK_STATE_UNSPECIFIED: Default value, unspecified state.\n - CALLBACK_STATE_STANDBY: Callback is standing by, waiting to be triggered.\n - CALLBACK_STATE_SCHEDULED: Callback is in the queue waiting to be executed or is currently executing.\n - CALLBACK_STATE_BACKING_OFF: Callback has failed with a retryable error and is backing off before the next attempt.\n - CALLBACK_STATE_FAILED: Callback has failed.\n - CALLBACK_STATE_SUCCEEDED: Callback has succeeded."
    },
    "v1CancelExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1CancelOperationRequest": {
      "type": "object",
      "properties": {
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Type of operation to cancel."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID as originally generated by a Handler."
        }
      },
      "description": "A request to cancel an operation."
    },
    "v1CancelOperationResponse": {
      "type": "object",
      "description": "Response variant for CancelOperationRequest."
    },
    "v1CancelTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The same timer id from the start timer command"
        }
      }
    },
    "v1CancelWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1CanceledFailureInfo": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ChildWorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionFailureInfo": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1ChildWorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ClusterMetadata": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string",
          "description": "Name of the cluster name."
        },
        "clusterId": {
          "type": "string",
          "description": "Id of the cluster."
        },
        "address": {
          "type": "string",
          "description": "gRPC address."
        },
        "httpAddress": {
          "type": "string",
          "description": "HTTP address, if one exists."
        },
        "initialFailoverVersion": {
          "type": "string",
          "format": "int64",
          "description": "A unique failover version across all connected clusters."
        },
        "historyShardCount": {
          "type": "integer",
          "format": "int32",
          "description": "History service shard number."
        },
        "isConnectionEnabled": {
          "type": "boolean",
          "description": "A flag to indicate if a connection is active."
        }
      }
    },
    "v1ClusterReplicationConfig": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string"
        }
      }
    },
    "v1Command": {
      "type": "object",
      "properties": {
        "commandType": {
          "$ref": "#/definitions/v1CommandType"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the command. This is sometimes carried over to the history event if one is\ncreated as a result of the command. Most commands won't have this information, and how this\ninformation is used is dependent upon the interface that reads it.\n\nCurrent well-known uses:\n * start_child_workflow_execution_command_attributes - populates\n   temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details\n   are used by user interfaces to show fixed as-of-start workflow summary and details.\n * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer\n   started where the summary is used to identify the timer."
        },
        "scheduleActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1ScheduleActivityTaskCommandAttributes"
        },
        "startTimerCommandAttributes": {
          "$ref": "#/definitions/v1StartTimerCommandAttributes"
        },
        "completeWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CompleteWorkflowExecutionCommandAttributes"
        },
        "failWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1FailWorkflowExecutionCommandAttributes"
        },
        "requestCancelActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelActivityTaskCommandAttributes"
        },
        "cancelTimerCommandAttributes": {
          "$ref": "#/definitions/v1CancelTimerCommandAttributes"
        },
        "cancelWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CancelWorkflowExecutionCommandAttributes"
        },
        "requestCancelExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionCommandAttributes"
        },
        "recordMarkerCommandAttributes": {
          "$ref": "#/definitions/v1RecordMarkerCommandAttributes"
        },
        "continueAsNewWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1ContinueAsNewWorkflowExecutionCommandAttributes"
        },
        "startChildWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionCommandAttributes"
        },
        "signalExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionCommandAttributes"
        },
        "upsertWorkflowSearchAttributesCommandAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesCommandAttributes"
        },
        "protocolMessageCommandAttributes": {
          "$ref": "#/definitions/v1ProtocolMessageCommandAttributes"
        },
        "modifyWorkflowPropertiesCommandAttributes": {
          "$ref": "#/definitions/v1ModifyWorkflowPropertiesCommandAttributes",
          "title": "16 is available for use - it was used as part of a prototype that never made it into a release"
        },
        "scheduleNexusOperationCommandAttributes": {
          "$ref": "#/definitions/v1ScheduleNexusOperationCommandAttributes"
        },
        "requestCancelNexusOperationCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelNexusOperationCommandAttributes"
        }
      }
    },
    "v1CommandType": {
      "type": "string",
      "enum": [
        "COMMAND_TYPE_UNSPECIFIED",
        "COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK",
        "COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK",
        "COMMAND_TYPE_START_TIMER",
        "COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_CANCEL_TIMER",
        "COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_RECORD_MARKER",
        "COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "COMMAND_TYPE_PROTOCOL_MESSAGE",
        "COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES",
        "COMMAND_TYPE_SCHEDULE_NEXUS_OPERATION",
        "COMMAND_TYPE_REQUEST_CANCEL_NEXUS_OPERATION"
      ],
      "default": "COMMAND_TYPE_UNSPECIFIED",
      "description": "Whenever this list of command types is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering."
    },
    "v1CompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "sourceBuildId": {
          "type": "string"
        },
        "targetBuildId": {
          "type": "string",
          "description": "Target Build ID must be compatible with the Source Build ID; that is it\nmust be able to process event histories made by the Source Build ID by\nusing [Patching](https://docs.temporal.io/workflows#patching) or other\nmeans."
        }
      },
      "description": "These rules apply to tasks assigned to a particular Build ID\n(`source_build_id`) to redirect them to another *compatible* Build ID\n(`target_build_id`).\n\nIt is user's responsibility to ensure that the target Build ID is compatible\nwith the source Build ID (e.g. by using the Patching API).\n\nMost deployments are not expected to need these rules, however following\nsituations can greatly benefit from redirects:\n - Need to move long-running Workflow Executions from an old Build ID to a\n   newer one.\n - Need to hotfix some broken or stuck Workflow Executions.\n\nIn steady state, redirect rules are beneficial when dealing with old\nExecutions ran on now-decommissioned Build IDs:\n - To redirecting the Workflow Queries to the current (compatible) Build ID.\n - To be able to Reset an old Execution so it can run on the current\n   (compatible) Build ID.\n\nRedirect rules can be chained."
    },
    "v1CompatibleVersionSet": {
      "type": "object",
      "properties": {
        "buildIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "All the compatible versions, unordered, except for the last element, which is considered the set \"default\"."
        }
      },
      "description": "Used by the worker versioning APIs, represents an unordered set of one or more versions which are\nconsidered to be compatible with each other. Currently the versions are always worker build IDs."
    },
    "v1CompleteWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ContinueAsNewInitiator": {
      "type": "string",
      "enum": [
        "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
        "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
        "CONTINUE_AS_NEW_INITIATOR_RETRY",
        "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE"
      ],
      "default": "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
      "title": "- CONTINUE_AS_NEW_INITIATOR_WORKFLOW: The workflow itself requested to continue as new\n - CONTINUE_AS_NEW_INITIATOR_RETRY: The workflow continued as new because it is retrying\n - CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE: The workflow continued as new because cron has triggered a new execution"
    },
    "v1ContinueAsNewWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "backoffStartInterval": {
          "type": "string",
          "description": "How long the workflow start will be delayed - not really a \"backoff\" in the traditional sense."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator",
          "title": "Should be removed"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Should be removed"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Should be removed"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Should be removed. Not necessarily unused but unclear and not exposed by SDKs."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the new execution inherits the Build ID of the current execution. Otherwise,\nthe assignment rules will be used to independently assign a Build ID to the new execution."
        }
      }
    },
    "v1CountWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "count": {
          "type": "string",
          "format": "int64",
          "description": "If `query` is not grouping by any field, the count is an approximate number\nof workflows that matches the query.\nIf `query` is grouping by a field, the count is simply the sum of the counts\nof the groups returned in the response. This number can be smaller than the\ntotal number of workflows matching the query."
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/CountWorkflowExecutionsResponseAggregationGroup"
          },
          "description": "`groups` contains the groups if the request is grouping by a field.\nThe list might not be complete, and the counts of each group is approximate."
        }
      }
    },
    "v1CreateNexusEndpointRequest": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec",
          "description": "Endpoint definition to create."
        }
      }
    },
    "v1CreateNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint",
          "description": "Data post acceptance. Can be used to issue additional updates to this record."
        }
      }
    },
    "v1CreateScheduleResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1DataBlob": {
      "type": "object",
      "properties": {
        "encodingType": {
          "$ref": "#/definitions/v1EncodingType"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1DeleteNamespaceResponse": {
      "type": "object",
      "properties": {
        "deletedNamespace": {
          "type": "string",
          "description": "Temporary namespace name that is used during reclaim resources step."
        }
      }
    },
    "v1DeleteNexusEndpointResponse": {
      "type": "object"
    },
    "v1DeleteScheduleResponse": {
      "type": "object"
    },
    "v1DeleteWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1DeprecateNamespaceResponse": {
      "type": "object",
      "description": "Deprecated."
    },
    "v1DescribeBatchOperationResponse": {
      "type": "object",
      "properties": {
        "operationType": {
          "$ref": "#/definitions/v1BatchOperationType",
          "title": "Batch operation type"
        },
        "jobId": {
          "type": "string",
          "title": "Batch job ID"
        },
        "state": {
          "$ref": "#/definitions/v1BatchOperationState",
          "title": "Batch operation state"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation start time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation close time"
        },
        "totalOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Total operation count"
        },
        "completeOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Complete operation count"
        },
        "failureOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Failure operation count"
        },
        "identity": {
          "type": "string",
          "title": "Identity indicates the operator identity"
        },
        "reason": {
          "type": "string",
          "title": "Reason indicates the reason to stop a operation"
        }
      }
    },
    "v1DescribeNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "failoverHistory": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1FailoverStatus"
          },
          "description": "Contains the historical state of failover_versions for the cluster, truncated to contain only the last N\nstates to ensure that the list does not grow unbounded."
        }
      }
    },
    "v1DescribeScheduleResponse": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "title": "The complete current schedule details. This may not match the schedule as\ncreated because:\n- some types of schedule specs may get compiled into others (e.g.\n  CronString into StructuredCalendarSpec)\n- some unspecified fields may be replaced by defaults\n- some fields in the state are modified automatically\n- the schedule may have been modified by UpdateSchedule or PatchSchedule"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleInfo",
          "description": "Extra schedule state info."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo",
          "description": "The memo and search attributes that the schedule was created with."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateSchedule to ensure that the\nschedule was not modified between a Describe and an Update, which could\nlead to lost updates and other confusion."
        }
      }
    },
    "v1DescribeTaskQueueMode": {
      "type": "string",
      "enum": [
        "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
        "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
      ],
      "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
      "description": " - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info."
    },
    "v1DescribeTaskQueueResponse": {
      "type": "object",
      "properties": {
        "pollers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollerInfo"
          },
          "description": "Deprecated. Use `versions_info.types_info.pollers` with `ENHANCED` mode instead.\nNot set in `ENHANCED` mode."
        },
        "taskQueueStatus": {
          "$ref": "#/definitions/v1TaskQueueStatus",
          "description": "Deprecated. Not set in `ENHANCED` mode."
        },
        "versionsInfo": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueVersionInfo"
          },
          "description": "This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.\nOnly set in `ENHANCED` mode."
        }
      }
    },
    "v1DescribeWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "executionConfig": {
          "$ref": "#/definitions/v1WorkflowExecutionConfig"
        },
        "workflowExecutionInfo": {
          "$ref": "#/definitions/v1WorkflowExecutionInfo"
        },
        "pendingActivities": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingActivityInfo"
          }
        },
        "pendingChildren": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingChildExecutionInfo"
          }
        },
        "pendingWorkflowTask": {
          "$ref": "#/definitions/v1PendingWorkflowTaskInfo"
        },
        "callbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CallbackInfo"
          }
        },
        "pendingNexusOperations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingNexusOperationInfo"
          }
        }
      }
    },
    "v1EncodingType": {
      "type": "string",
      "enum": [
        "ENCODING_TYPE_UNSPECIFIED",
        "ENCODING_TYPE_PROTO3",
        "ENCODING_TYPE_JSON"
      ],
      "default": "ENCODING_TYPE_UNSPECIFIED"
    },
    "v1Endpoint": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API."
        },
        "id": {
          "type": "string",
          "description": "Unique server-generated endpoint ID."
        },
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec",
          "description": "Spec for the endpoint."
        },
        "createdTime": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time when the endpoint was created."
        },
        "lastModifiedTime": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time when the endpoint was last modified.\nWill not be set if the endpoint has never been modified."
        },
        "urlPrefix": {
          "type": "string",
          "description": "Server exposed URL prefix for invocation of operations on this endpoint.\nThis doesn't include the protocol, hostname or port as the server does not know how it should be accessed\npublicly. The URL is stable in the face of endpoint renames."
        }
      },
      "description": "A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests."
    },
    "v1EndpointSpec": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.\nRenaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail."
        },
        "description": {
          "$ref": "#/definitions/v1Payload",
          "description": "Markdown description serialized as a single JSON string.\nIf the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.\nBy default, the server enforces a limit of 20,000 bytes for this entire payload."
        },
        "target": {
          "$ref": "#/definitions/v1EndpointTarget",
          "description": "Target to route requests to."
        }
      },
      "description": "Contains mutable fields for an Endpoint."
    },
    "v1EndpointTarget": {
      "type": "object",
      "properties": {
        "worker": {
          "$ref": "#/definitions/EndpointTargetWorker"
        },
        "external": {
          "$ref": "#/definitions/EndpointTargetExternal"
        }
      },
      "description": "Target to route requests to."
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
        "EVENT_TYPE_WORKFLOW_TASK_STARTED",
        "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
        "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
        "EVENT_TYPE_ACTIVITY_TASK_STARTED",
        "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
        "EVENT_TYPE_ACTIVITY_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
        "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
        "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
        "EVENT_TYPE_TIMER_STARTED",
        "EVENT_TYPE_TIMER_FIRED",
        "EVENT_TYPE_TIMER_CANCELED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_MARKER_RECORDED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED",
        "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED",
        "EVENT_TYPE_NEXUS_OPERATION_STARTED",
        "EVENT_TYPE_NEXUS_OPERATION_COMPLETED",
        "EVENT_TYPE_NEXUS_OPERATION_FAILED",
        "EVENT_TYPE_NEXUS_OPERATION_CANCELED",
        "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT",
        "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": "- EVENT_TYPE_UNSPECIFIED: Place holder and should never appear in a Workflow execution history\n - EVENT_TYPE_WORKFLOW_EXECUTION_STARTED: Workflow execution has been triggered/started\nIt contains Workflow execution inputs, as well as Workflow timeout configurations\n - EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED: Workflow execution has successfully completed and contains Workflow execution results\n - EVENT_TYPE_WORKFLOW_EXECUTION_FAILED: Workflow execution has unsuccessfully completed and contains the Workflow execution error\n - EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT: Workflow execution has timed out by the Temporal Server\nUsually due to the Workflow having not been completed within timeout settings\n - EVENT_TYPE_WORKFLOW_TASK_SCHEDULED: Workflow Task has been scheduled and the SDK client should now be able to process any new history events\n - EVENT_TYPE_WORKFLOW_TASK_STARTED: Workflow Task has started and the SDK client has picked up the Workflow Task and is processing new history events\n - EVENT_TYPE_WORKFLOW_TASK_COMPLETED: Workflow Task has completed\nThe SDK client picked up the Workflow Task and processed new history events\nSDK client may or may not ask the Temporal Server to do additional work, such as:\nEVENT_TYPE_ACTIVITY_TASK_SCHEDULED\nEVENT_TYPE_TIMER_STARTED\nEVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES\nEVENT_TYPE_MARKER_RECORDED\nEVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED\nEVENT_TYPE_WORKFLOW_EXECUTION_FAILED\nEVENT_TYPE_WORKFLOW_EXECUTION_CANCELED\nEVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW\n - EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT: Workflow Task encountered a timeout\nEither an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the task\n - EVENT_TYPE_WORKFLOW_TASK_FAILED: Workflow Task encountered a failure\nUsually this means that the Workflow was non-deterministic\nHowever, the Workflow reset functionality also uses this event\n - EVENT_TYPE_ACTIVITY_TASK_SCHEDULED: Activity Task was scheduled\nThe SDK client should pick up this activity task and execute\nThis event type contains activity inputs, as well as activity timeout configurations\n - EVENT_TYPE_ACTIVITY_TASK_STARTED: Activity Task has started executing\nThe SDK client has picked up the Activity Task and is processing the Activity invocation\n - EVENT_TYPE_ACTIVITY_TASK_COMPLETED: Activity Task has finished successfully\nThe SDK client has picked up and successfully completed the Activity Task\nThis event type contains Activity execution results\n - EVENT_TYPE_ACTIVITY_TASK_FAILED: Activity Task has finished unsuccessfully\nThe SDK picked up the Activity Task but unsuccessfully completed it\nThis event type contains Activity execution errors\n - EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT: Activity has timed out according to the Temporal Server\nActivity did not complete within the timeout settings\n - EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED: A request to cancel the Activity has occurred\nThe SDK client will be able to confirm cancellation of an Activity during an Activity heartbeat\n - EVENT_TYPE_ACTIVITY_TASK_CANCELED: Activity has been cancelled\n - EVENT_TYPE_TIMER_STARTED: A timer has started\n - EVENT_TYPE_TIMER_FIRED: A timer has fired\n - EVENT_TYPE_TIMER_CANCELED: A time has been cancelled\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED: A request has been made to cancel the Workflow execution\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED: SDK client has confirmed the cancellation request and the Workflow execution has been cancelled\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Workflow has requested that the Temporal Server try to cancel another Workflow\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server could not cancel the targeted Workflow\nThis is usually because the target Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED: Temporal Server has successfully requested the cancellation of the target Workflow\n - EVENT_TYPE_MARKER_RECORDED: A marker has been recorded.\nThis event type is transparent to the Temporal Server\nThe Server will only store it and will not try to understand it.\n - EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED: Workflow has received a Signal event\nThe event type contains the Signal name, as well as a Signal payload\n - EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED: Workflow execution has been forcefully terminated\nThis is usually because the terminate Workflow API was called\n - EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW: Workflow has successfully completed and a new Workflow has been started within the same transaction\nContains last Workflow execution results as well as new Workflow execution inputs\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to start a child Workflow\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution cannot be started/triggered\nUsually due to a child Workflow ID collision\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED: Child Workflow execution has successfully started/triggered\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED: Child Workflow execution has successfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution has unsuccessfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED: Child Workflow execution has been cancelled\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT: Child Workflow execution has timed out by the Temporal Server\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED: Child Workflow execution has been terminated\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to Signal the targeted Workflow\nContains the Signal name, as well as a Signal payload\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server cannot Signal the targeted Workflow\nUsually because the Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED: Temporal Server has successfully Signaled the targeted Workflow\n - EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: Workflow search attributes should be updated and synchronized with the visibility store\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED: An update was admitted. Note that not all admitted updates result in this\nevent. See UpdateAdmittedEventOrigin for situations in which this event\nis created.\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED: An update was accepted (i.e. passed validation, perhaps because no validator was defined)\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED: This event is never written to history.\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED: An update completed\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of the workflow as a whole have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of an already-scheduled activity have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED: Workflow properties modified by user workflow code\n - EVENT_TYPE_NEXUS_OPERATION_SCHEDULED: A Nexus operation was scheduled using a ScheduleNexusOperation command.\n - EVENT_TYPE_NEXUS_OPERATION_STARTED: An asynchronous Nexus operation was started by a Nexus handler.\n - EVENT_TYPE_NEXUS_OPERATION_COMPLETED: A Nexus operation completed successfully.\n - EVENT_TYPE_NEXUS_OPERATION_FAILED: A Nexus operation failed.\n - EVENT_TYPE_NEXUS_OPERATION_CANCELED: A Nexus operation completed as canceled.\n - EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT: A Nexus operation timed out.\n - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED: A Nexus operation was requested to be canceled using a RequestCancelNexusOperation command.",
      "title": "Whenever this list of events is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering"
    },
    "v1ExecuteMultiOperationResponse": {
      "type": "object",
      "properties": {
        "responses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ExecuteMultiOperationResponseResponse"
          }
        }
      }
    },
    "v1ExecuteMultiOperationResponseResponse": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
        },
        "updateWorkflow": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
        }
      }
    },
    "v1ExternalWorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds\nto"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-cancelled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        }
      }
    },
    "v1ExternalWorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which was signaled.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1FailWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      }
    },
    "v1FailoverStatus": {
      "type": "object",
      "properties": {
        "failoverTime": {
          "type": "string",
          "format": "date-time",
          "title": "Timestamp when the Cluster switched to the following failover_version"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "Represents a historical replication status of a Namespace"
    },
    "v1GetClusterInfoResponse": {
      "type": "object",
      "properties": {
        "supportedClients": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Key is client name i.e \"temporal-go\", \"temporal-java\", or \"temporal-cli\".\nValue is ranges of supported versions of this client i.e \">1.1.1 <=1.4.0 || ^5.0.0\"."
        },
        "serverVersion": {
          "type": "string"
        },
        "clusterId": {
          "type": "string"
        },
        "versionInfo": {
          "$ref": "#/definitions/v1VersionInfo"
        },
        "clusterName": {
          "type": "string"
        },
        "historyShardCount": {
          "type": "integer",
          "format": "int32"
        },
        "persistenceStore": {
          "type": "string"
        },
        "visibilityStore": {
          "type": "string"
        }
      },
      "description": "GetClusterInfoResponse contains information about Temporal cluster."
    },
    "v1GetNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint"
        }
      }
    },
    "v1GetSearchAttributesResponse": {
      "type": "object",
      "properties": {
        "keys": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          }
        }
      }
    },
    "v1GetSystemInfoResponse": {
      "type": "object",
      "properties": {
        "serverVersion": {
          "type": "string",
          "description": "Version of the server."
        },
        "capabilities": {
          "$ref": "#/definitions/v1GetSystemInfoResponseCapabilities",
          "description": "All capabilities the system supports."
        }
      }
    },
    "v1GetSystemInfoResponseCapabilities": {
      "type": "object",
      "properties": {
        "signalAndQueryHeader": {
          "type": "boolean",
          "description": "True if signal and query headers are supported."
        },
        "internalErrorDifferentiation": {
          "type": "boolean",
          "description": "True if internal errors are differentiated from other types of errors for purposes of\nretrying non-internal errors.\n\nWhen unset/false, clients retry all failures. When true, clients should only retry\nnon-internal errors."
        },
        "activityFailureIncludeHeartbeat": {
          "type": "boolean",
          "title": "True if RespondActivityTaskFailed API supports including heartbeat details"
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Supports scheduled workflow features."
        },
        "encodedFailureAttributes": {
          "type": "boolean",
          "title": "True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes"
        },
        "buildIdBasedVersioning": {
          "type": "boolean",
          "title": "True if server supports dispatching Workflow and Activity tasks based on a worker's build_id\n(see:\nhttps://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)"
        },
        "upsertMemo": {
          "type": "boolean",
          "title": "True if server supports upserting workflow memo"
        },
        "eagerWorkflowStart": {
          "type": "boolean",
          "title": "True if server supports eager workflow task dispatching for the StartWorkflowExecution API"
        },
        "sdkMetadata": {
          "type": "boolean",
          "title": "True if the server knows about the sdk metadata field on WFT completions and will record\nit in history"
        },
        "countGroupByExecutionStatus": {
          "type": "boolean",
          "title": "True if the server supports count group by execution status"
        },
        "nexus": {
          "type": "boolean",
          "description": "True if the server supports Nexus operations.\nThis flag is dependent both on server version and for Nexus to be enabled via server configuration."
        }
      },
      "description": "System capability details."
    },
    "v1GetWorkerBuildIdCompatibilityResponse": {
      "type": "object",
      "properties": {
        "majorVersionSets": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CompatibleVersionSet"
          },
          "description": "Major version sets, in order from oldest to newest. The last element of the list will always\nbe the current default major version. IE: New workflows will target the most recent version\nin that version set.\n\nThere may be fewer sets returned than exist, if the request chose to limit this response."
        }
      }
    },
    "v1GetWorkerTaskReachabilityResponse": {
      "type": "object",
      "properties": {
        "buildIdReachability": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BuildIdReachability"
          },
          "description": "Task reachability, broken down by build id and then task queue.\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store."
        }
      },
      "description": "Deprecated. Use `DescribeTaskQueue`."
    },
    "v1GetWorkerVersioningRulesResponse": {
      "type": "object",
      "properties": {
        "assignmentRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedBuildIdAssignmentRule"
          }
        },
        "compatibleRedirectRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedCompatibleBuildIdRedirectRule"
          }
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateWorkerVersioningRulesRequest to\nensure that the rules were not modified between this List and the Update,\nwhich could lead to lost updates and other confusion."
        }
      }
    },
    "v1GetWorkflowExecutionHistoryResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "rawHistory": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1DataBlob"
          },
          "description": "Raw history is an alternate representation of history that may be returned if configured on\nthe frontend. This is not supported by all SDKs. Either this or `history` will be set."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        },
        "archived": {
          "type": "boolean"
        }
      }
    },
    "v1GetWorkflowExecutionHistoryReverseResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        }
      }
    },
    "v1HandlerError": {
      "type": "object",
      "properties": {
        "errorType": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors."
        },
        "failure": {
          "$ref": "#/definitions/apinexusv1Failure"
        }
      }
    },
    "v1Header": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "Contains metadata that can be attached to a variety of requests, like starting a workflow, and\ncan be propagated between, for example, workflows and activities."
    },
    "v1History": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HistoryEvent"
          }
        }
      }
    },
    "v1HistoryEvent": {
      "type": "object",
      "properties": {
        "eventId": {
          "type": "string",
          "format": "int64",
          "description": "Monotonically increasing event number, starts at 1."
        },
        "eventTime": {
          "type": "string",
          "format": "date-time"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "taskId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "workerMayIgnore": {
          "type": "boolean",
          "description": "Set to true when the SDK may ignore the event as it does not impact workflow state or\ninformation in any way that the SDK need be concerned with. If an SDK encounters an event\ntype which it does not understand, it must error unless this is true. If it is true, it's\nacceptable for the event type and/or attributes to be uninterpretable."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the event. This is often carried over from commands and client calls. Most events\nwon't have this information, and how this information is used is dependent upon the interface\nthat reads it.\n\nCurrent well-known uses:\n * workflow_execution_started_event_attributes - summary and details from start workflow.\n * timer_started_event_attributes - summary represents an identifier for the timer for use by\n   user interfaces."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links associated with the event."
        },
        "workflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionStartedEventAttributes"
        },
        "workflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCompletedEventAttributes"
        },
        "workflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionFailedEventAttributes"
        },
        "workflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTimedOutEventAttributes"
        },
        "workflowTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskScheduledEventAttributes"
        },
        "workflowTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskStartedEventAttributes"
        },
        "workflowTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskCompletedEventAttributes"
        },
        "workflowTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskTimedOutEventAttributes"
        },
        "workflowTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskFailedEventAttributes"
        },
        "activityTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskScheduledEventAttributes"
        },
        "activityTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskStartedEventAttributes"
        },
        "activityTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCompletedEventAttributes"
        },
        "activityTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskFailedEventAttributes"
        },
        "activityTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskTimedOutEventAttributes"
        },
        "timerStartedEventAttributes": {
          "$ref": "#/definitions/v1TimerStartedEventAttributes"
        },
        "timerFiredEventAttributes": {
          "$ref": "#/definitions/v1TimerFiredEventAttributes"
        },
        "activityTaskCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCancelRequestedEventAttributes"
        },
        "activityTaskCanceledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCanceledEventAttributes"
        },
        "timerCanceledEventAttributes": {
          "$ref": "#/definitions/v1TimerCanceledEventAttributes"
        },
        "markerRecordedEventAttributes": {
          "$ref": "#/definitions/v1MarkerRecordedEventAttributes"
        },
        "workflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionSignaledEventAttributes"
        },
        "workflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTerminatedEventAttributes"
        },
        "workflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCanceledEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionContinuedAsNewEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionContinuedAsNewEventAttributes"
        },
        "startChildWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionInitiatedEventAttributes"
        },
        "startChildWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionStartedEventAttributes"
        },
        "childWorkflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCompletedEventAttributes"
        },
        "childWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCanceledEventAttributes"
        },
        "childWorkflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTimedOutEventAttributes"
        },
        "childWorkflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTerminatedEventAttributes"
        },
        "signalExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "signalExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionSignaledEventAttributes"
        },
        "upsertWorkflowSearchAttributesEventAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesEventAttributes"
        },
        "workflowExecutionUpdateAcceptedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateAcceptedEventAttributes"
        },
        "workflowExecutionUpdateRejectedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateRejectedEventAttributes"
        },
        "workflowExecutionUpdateCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateCompletedEventAttributes"
        },
        "workflowPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedExternallyEventAttributes"
        },
        "activityPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1ActivityPropertiesModifiedExternallyEventAttributes"
        },
        "workflowPropertiesModifiedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedEventAttributes"
        },
        "workflowExecutionUpdateAdmittedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateAdmittedEventAttributes"
        },
        "nexusOperationScheduledEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationScheduledEventAttributes"
        },
        "nexusOperationStartedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationStartedEventAttributes"
        },
        "nexusOperationCompletedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCompletedEventAttributes"
        },
        "nexusOperationFailedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationFailedEventAttributes"
        },
        "nexusOperationCanceledEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCanceledEventAttributes"
        },
        "nexusOperationTimedOutEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationTimedOutEventAttributes"
        },
        "nexusOperationCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCancelRequestedEventAttributes"
        }
      },
      "description": "History events are the method by which Temporal SDKs advance (or recreate) workflow state.\nSee the `EventType` enum for more info about what each event is for."
    },
    "v1HistoryEventFilterType": {
      "type": "string",
      "enum": [
        "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
        "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
        "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
      ],
      "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
    },
    "v1IndexedValueType": {
      "type": "string",
      "enum": [
        "INDEXED_VALUE_TYPE_UNSPECIFIED",
        "INDEXED_VALUE_TYPE_TEXT",
        "INDEXED_VALUE_TYPE_KEYWORD",
        "INDEXED_VALUE_TYPE_INT",
        "INDEXED_VALUE_TYPE_DOUBLE",
        "INDEXED_VALUE_TYPE_BOOL",
        "INDEXED_VALUE_TYPE_DATETIME",
        "INDEXED_VALUE_TYPE_KEYWORD_LIST"
      ],
      "default": "INDEXED_VALUE_TYPE_UNSPECIFIED"
    },
    "v1Input": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the Update from the requesting entity.\nThese can include things like auth or tracing tokens."
        },
        "name": {
          "type": "string",
          "description": "The name of the Update handler to invoke on the target Workflow."
        },
        "args": {
          "$ref": "#/definitions/v1Payloads",
          "description": "The arguments to pass to the named Update handler."
        }
      }
    },
    "v1IntervalSpec": {
      "type": "object",
      "properties": {
        "interval": {
          "type": "string"
        },
        "phase": {
          "type": "string"
        }
      },
      "description": "IntervalSpec matches times that can be expressed as:\nepoch + n * interval + phase\nwhere n is an integer.\nphase defaults to zero if missing. interval is required.\nBoth interval and phase must be non-negative and are truncated to the nearest\nsecond before any calculations.\nFor example, an interval of 1 hour with phase of zero would match every hour,\non the hour. The same interval but a phase of 19 minutes would match every\nxx:19:00. An interval of 28 days with phase zero would match\n2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3\ndays, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead."
    },
    "v1ListArchivedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListBatchOperationsResponse": {
      "type": "object",
      "properties": {
        "operationInfo": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BatchOperationInfo"
          },
          "title": "BatchOperationInfo contains the basic info about batch operation"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListClosedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListClustersResponse": {
      "type": "object",
      "properties": {
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterMetadata"
          },
          "title": "List of all cluster information"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListNamespacesResponse": {
      "type": "object",
      "properties": {
        "namespaces": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1DescribeNamespaceResponse"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListNexusEndpointsResponse": {
      "type": "object",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "description": "Token for getting the next page."
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Endpoint"
          }
        }
      }
    },
    "v1ListOpenWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListScheduleMatchingTimesResponse": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      }
    },
    "v1ListSchedulesResponse": {
      "type": "object",
      "properties": {
        "schedules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleListEntry"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListSearchAttributesResponse": {
      "type": "object",
      "properties": {
        "customAttributes": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          },
          "description": "Mapping between custom (user-registered) search attribute name to its IndexedValueType."
        },
        "systemAttributes": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          },
          "description": "Mapping between system (predefined) search attribute name to its IndexedValueType."
        },
        "storageSchema": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Mapping from the attribute name to the visibility storage native type."
        }
      }
    },
    "v1ListTaskQueuePartitionsResponse": {
      "type": "object",
      "properties": {
        "activityTaskQueuePartitions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        },
        "workflowTaskQueuePartitions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        }
      }
    },
    "v1ListWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1MarkerRecordedEventAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string",
          "description": "Workers use this to identify the \"types\" of various markers. Ex: Local activity, side effect."
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          },
          "title": "Serialized information recorded in the marker"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Some uses of markers, like a local activity, could \"fail\". If they did that is recorded here."
        }
      }
    },
    "v1Memo": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "A user-defined set of *unindexed* fields that are exposed when listing/searching workflows"
    },
    "v1Message": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "An ID for this specific message."
        },
        "protocolInstanceId": {
          "type": "string",
          "description": "Identifies the specific instance of a protocol to which this message\nbelongs."
        },
        "eventId": {
          "type": "string",
          "format": "int64"
        },
        "commandIndex": {
          "type": "string",
          "format": "int64"
        },
        "body": {
          "$ref": "#/definitions/protobufAny",
          "description": "The opaque data carried by this message. The protocol type can be\nextracted from the package name of the message carried inside the Any."
        }
      }
    },
    "v1Meta": {
      "type": "object",
      "properties": {
        "updateId": {
          "type": "string",
          "description": "An ID with workflow-scoped uniqueness for this Update."
        },
        "identity": {
          "type": "string",
          "description": "A string identifying the agent that requested this Update."
        }
      },
      "description": "Metadata about a Workflow Update."
    },
    "v1MeteringMetadata": {
      "type": "object",
      "properties": {
        "nonfirstLocalActivityExecutionAttempts": {
          "type": "integer",
          "format": "int64",
          "description": "Count of local activities which have begun an execution attempt during this workflow task,\nand whose first attempt occurred in some previous task. This is used for metering\npurposes, and does not affect workflow state.\n"
        }
      },
      "title": "Metadata relevant for metering purposes"
    },
    "v1ModifyWorkflowPropertiesCommandAttributes": {
      "type": "object",
      "properties": {
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1NamespaceConfig": {
      "type": "object",
      "properties": {
        "workflowExecutionRetentionTtl": {
          "type": "string"
        },
        "badBinaries": {
          "$ref": "#/definitions/v1BadBinaries"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        },
        "customSearchAttributeAliases": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map from field name to alias."
        }
      }
    },
    "v1NamespaceFilter": {
      "type": "object",
      "properties": {
        "includeDeleted": {
          "type": "boolean",
          "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet."
        }
      }
    },
    "v1NamespaceInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "id": {
          "type": "string"
        },
        "capabilities": {
          "$ref": "#/definitions/v1NamespaceInfoCapabilities",
          "description": "All capabilities the namespace supports."
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Whether scheduled workflows are supported on this namespace. This is only needed\ntemporarily while the feature is experimental, so we can give it a high tag."
        }
      }
    },
    "v1NamespaceInfoCapabilities": {
      "type": "object",
      "properties": {
        "eagerWorkflowStart": {
          "type": "boolean",
          "description": "True if the namespace supports eager workflow start."
        },
        "syncUpdate": {
          "type": "boolean",
          "title": "True if the namespace supports sync update"
        },
        "asyncUpdate": {
          "type": "boolean",
          "title": "True if the namespace supports async update"
        }
      },
      "description": "Namespace capability details. Should contain what features are enabled in a namespace."
    },
    "v1NamespaceReplicationConfig": {
      "type": "object",
      "properties": {
        "activeClusterName": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "state": {
          "$ref": "#/definitions/v1ReplicationState"
        }
      }
    },
    "v1NamespaceState": {
      "type": "string",
      "enum": [
        "NAMESPACE_STATE_UNSPECIFIED",
        "NAMESPACE_STATE_REGISTERED",
        "NAMESPACE_STATE_DEPRECATED",
        "NAMESPACE_STATE_DELETED"
      ],
      "default": "NAMESPACE_STATE_UNSPECIFIED"
    },
    "v1NewWorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        }
      },
      "description": "NewWorkflowExecutionInfo is a shared message that encapsulates all the\nrequired arguments to starting a workflow in different contexts."
    },
    "v1NexusOperationCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\nwith."
        }
      }
    },
    "v1NexusOperationCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Cancellation details."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow."
    },
    "v1NexusOperationCancellationInfo": {
      "type": "object",
      "properties": {
        "requestedTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when cancellation was requested."
        },
        "state": {
          "$ref": "#/definitions/v1NexusOperationCancellationState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the cancel operation request.\nThis number represents a minimum bound since the attempt is incremented after the request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        }
      },
      "description": "NexusOperationCancellationInfo contains the state of a nexus operation cancellation."
    },
    "v1NexusOperationCancellationState": {
      "type": "string",
      "enum": [
        "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
        "NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED",
        "NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF",
        "NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED",
        "NEXUS_OPERATION_CANCELLATION_STATE_FAILED",
        "NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT"
      ],
      "default": "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
      "description": "State of a Nexus operation cancellation.\n\n - NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED: Default value, unspecified state.\n - NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED: Cancellation request is in the queue waiting to be executed or is currently executing.\n - NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF: Cancellation request has failed with a retryable error and is backing off before the next attempt.\n - NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED: Cancellation request succeeded.\n - NEXUS_OPERATION_CANCELLATION_STATE_FAILED: Cancellation request failed with a non-retryable error.\n - NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT: The associated operation timed out - exceeded the user supplied schedule-to-close timeout."
    },
    "v1NexusOperationCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "result": {
          "$ref": "#/definitions/v1Payload",
          "description": "Serialized result of the Nexus operation. The response of the Nexus handler.\nDelivered either via a completion callback or as a response to a synchronous operation."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation completed successfully."
    },
    "v1NexusOperationFailedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation failed."
    },
    "v1NexusOperationFailureInfo": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The NexusOperationScheduled event ID."
        },
        "endpoint": {
          "type": "string",
          "description": "Endpoint name."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID - may be empty if the operation completed synchronously."
        }
      }
    },
    "v1NexusOperationScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name, must exist in the endpoint registry."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "input": {
          "$ref": "#/definitions/v1Payload",
          "description": "Input for the operation. The server converts this into Nexus request content and the appropriate content headers\ninternally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the\ncontent is transformed back to the original Payload stored in this event."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nIndicates how long the caller is willing to wait for operation completion.\nCalls are retried internally by the server."
        },
        "nexusHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal\nactivities and child workflows, these are transmitted to Nexus operations that may be external and are not\ntraditional payloads."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with."
        },
        "requestId": {
          "type": "string",
          "description": "A unique ID generated by the history service upon creation of this event.\nThe ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key."
        },
        "endpointId": {
          "type": "string",
          "description": "Endpoint ID as resolved in the endpoint registry at the time this event was generated.\nThis is stored on the event and used internally by the server in case the endpoint is renamed from the time the\nevent was originally scheduled."
        }
      },
      "description": "Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command."
    },
    "v1NexusOperationStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to."
        },
        "operationId": {
          "type": "string",
          "description": "The operation ID returned by the Nexus handler in the response to the StartOperation request.\nThis ID is used when canceling the operation."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Event marking an asynchronous operation was started by the responding Nexus handler.\nIf the operation completes synchronously, this event is not generated.\nIn rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate\nthis event upon receiving the operation completion via callback."
    },
    "v1NexusOperationTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation timed out."
    },
    "v1Outcome": {
      "type": "object",
      "properties": {
        "success": {
          "$ref": "#/definitions/v1Payloads"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      },
      "description": "The outcome of a Workflow Update: success or failure."
    },
    "v1ParentClosePolicy": {
      "type": "string",
      "enum": [
        "PARENT_CLOSE_POLICY_UNSPECIFIED",
        "PARENT_CLOSE_POLICY_TERMINATE",
        "PARENT_CLOSE_POLICY_ABANDON",
        "PARENT_CLOSE_POLICY_REQUEST_CANCEL"
      ],
      "default": "PARENT_CLOSE_POLICY_UNSPECIFIED",
      "description": "- PARENT_CLOSE_POLICY_TERMINATE: The child workflow will also terminate\n - PARENT_CLOSE_POLICY_ABANDON: The child workflow will do nothing\n - PARENT_CLOSE_POLICY_REQUEST_CANCEL: Cancellation will be requested of the child workflow",
      "title": "Defines how child workflows will react to their parent completing"
    },
    "v1PatchScheduleResponse": {
      "type": "object"
    },
    "v1PauseActivityByIdResponse": {
      "type": "object"
    },
    "v1Payload": {
      "description": "Arbitrary payload data in an unconstrained format.\nThis may be activity input parameters, a workflow result, a memo, etc.\n"
    },
    "v1Payloads": {
      "type": "object",
      "properties": {
        "payloads": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "See `Payload`"
    },
    "v1PendingActivityInfo": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "state": {
          "$ref": "#/definitions/v1PendingActivityState"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        },
        "lastHeartbeatTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastStartedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "expirationTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastFailure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "lastWorkerIdentity": {
          "type": "string"
        },
        "useWorkflowBuildId": {
          "type": "object",
          "properties": {},
          "description": "When present, it means this activity is assigned to the build ID of its workflow."
        },
        "lastIndependentlyAssignedBuildId": {
          "type": "string",
          "description": "This means the activity is independently versioned and not bound to the build ID of its workflow.\nThe activity will use the build id in this field instead.\nIf the task fails and is scheduled again, the assigned build ID may change according to the latest versioning\nrules."
        },
        "lastWorkerVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "The version stamp of the worker to whom this activity was most recently dispatched"
        },
        "currentRetryInterval": {
          "type": "string",
          "description": "The time activity will wait until the next retry.\nIf activity is currently running it will be next retry interval if activity failed.\nIf activity is currently waiting it will be current retry interval.\nIf there will be no retry it will be null."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last activity attempt was completed. If activity has not been completed yet then it will be null."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "Next time when activity will be scheduled.\nIf activity is currently scheduled or started it will be null."
        },
        "paused": {
          "type": "boolean",
          "description": "Indicates if activity is paused."
        }
      }
    },
    "v1PendingActivityState": {
      "type": "string",
      "enum": [
        "PENDING_ACTIVITY_STATE_UNSPECIFIED",
        "PENDING_ACTIVITY_STATE_SCHEDULED",
        "PENDING_ACTIVITY_STATE_STARTED",
        "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED"
      ],
      "default": "PENDING_ACTIVITY_STATE_UNSPECIFIED"
    },
    "v1PendingChildExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "workflowTypeName": {
          "type": "string"
        },
        "initiatedId": {
          "type": "string",
          "format": "int64"
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        }
      }
    },
    "v1PendingNexusOperationInfo": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name.\nResolved to a URL via the cluster's endpoint registry."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID. Only set for asynchronous operations after a successful StartOperation call."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nThis is the only timeout settable by a workflow."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the operation was scheduled."
        },
        "state": {
          "$ref": "#/definitions/v1PendingNexusOperationState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the start operation request.\nThis number represents a minimum bound since the attempt is incremented after the request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        },
        "cancellationInfo": {
          "$ref": "#/definitions/v1NexusOperationCancellationInfo"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the\nDescribeWorkflowExecution response with workflow history."
        }
      },
      "description": "PendingNexusOperationInfo contains the state of a pending Nexus operation."
    },
    "v1PendingNexusOperationState": {
      "type": "string",
      "enum": [
        "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
        "PENDING_NEXUS_OPERATION_STATE_SCHEDULED",
        "PENDING_NEXUS_OPERATION_STATE_BACKING_OFF",
        "PENDING_NEXUS_OPERATION_STATE_STARTED"
      ],
      "default": "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
      "description": "State of a pending Nexus operation.\n\n - PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED: Default value, unspecified state.\n - PENDING_NEXUS_OPERATION_STATE_SCHEDULED: Operation is in the queue waiting to be executed or is currently executing.\n - PENDING_NEXUS_OPERATION_STATE_BACKING_OFF: Operation has failed with a retryable error and is backing off before the next attempt.\n - PENDING_NEXUS_OPERATION_STATE_STARTED: Operation was started and will complete asynchronously."
    },
    "v1PendingWorkflowTaskInfo": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1PendingWorkflowTaskState"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "originalScheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.\nHeartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command\nIn this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds\nsome threshold, the workflow task will be forced timeout."
        },
        "startedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1PendingWorkflowTaskState": {
      "type": "string",
      "enum": [
        "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED",
        "PENDING_WORKFLOW_TASK_STATE_SCHEDULED",
        "PENDING_WORKFLOW_TASK_STATE_STARTED"
      ],
      "default": "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED"
    },
    "v1PollActivityTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowNamespace": {
          "type": "string",
          "title": "The namespace the workflow which requested this activity lives in"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "Type of the requesting workflow"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the requesting workflow"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string",
          "description": "The autogenerated or user specified identifier of this activity. Can be used to complete the\nactivity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage\nhas resolved, but unique IDs for every activity invocation is a good idea."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers specified by the scheduling workflow. Commonly used to propagate contextual info\nfrom the workflow to its activities. For example, tracing contexts."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arguments to the activity invocation"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Details of the last heartbeat that was recorded for this activity as of the time this task\nwas delivered."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task first scheduled"
        },
        "currentAttemptScheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task attempt scheduled"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task started (this attempt)"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of attempts to perform this activity"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "title": "First scheduled -> final result reported timeout"
        },
        "startToCloseTimeout": {
          "type": "string",
          "title": "Current attempt start -> final result reported timeout"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Window within which the activity must report a heartbeat, or be timed out."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "This is the retry policy the service uses which may be different from the one provided\n(or not) during activity scheduling. The service can override the provided one if some\nvalues are not specified or exceed configured system limits."
        }
      }
    },
    "v1PollNexusTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "description": "An opaque unique identifier for this task for correlating a completion request the embedded request."
        },
        "request": {
          "$ref": "#/definitions/apinexusv1Request",
          "description": "Embedded request as translated from the incoming frontend request."
        }
      }
    },
    "v1PollWorkflowExecutionUpdateResponse": {
      "type": "object",
      "properties": {
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of the update if and only if the update has completed. If\nthis response is being returned before the update has completed (e.g. due\nto the specification of a wait policy that only waits on\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will\nnot be set."
        },
        "stage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "The most advanced lifecycle stage that the Update is known to have\nreached, where lifecycle stages are ordered\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.\nUNSPECIFIED will be returned if and only if the server's maximum wait\ntime was reached before the Update reached the stage specified in the\nrequest WaitPolicy, and before the context deadline expired; clients may\nmay then retry the call as needed."
        },
        "updateRef": {
          "$ref": "#/definitions/v1UpdateRef",
          "description": "Sufficient information to address this Update."
        }
      }
    },
    "v1PollWorkflowTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "previousStartedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The last workflow task started event which was processed by some worker for this execution.\nWill be zero if no task has ever started."
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the most recent workflow task started event, which will have been generated as a\nresult of this poll request being served. Will be zero if the task\ndoes not contain any events which would advance history (no new WFT started).\nCurrently this can happen for queries."
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "Starting at 1, the number of attempts to complete this task by any worker."
        },
        "backlogCountHint": {
          "type": "string",
          "format": "int64",
          "description": "A hint that there are more tasks already present in this task queue \npartition. Can be used to prioritize draining a sticky queue.\n\nSpecifically, the returned number is the number of tasks remaining in\nthe in-memory buffer for this partition, which is currently capped at\n1000. Because sticky queues only have one partition, this number is \nmore useful when draining them. Normal queues, typically having more than one \npartition, will return a number representing only some portion of the \noverall backlog. Subsequent RPCs may not hit the same partition as \nthis call."
        },
        "history": {
          "$ref": "#/definitions/v1History",
          "description": "The history for this workflow, which will either be complete or partial. Partial histories\nare sent to workers who have signaled that they are using a sticky queue when completing\na workflow task."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "description": "Will be set if there are more history events than were included in this response. Such events\nshould be fetched via `GetWorkflowExecutionHistory`."
        },
        "query": {
          "$ref": "#/definitions/v1WorkflowQuery",
          "description": "Legacy queries appear in this field. The query must be responded to via\n`RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on\nclosed workflows) then the `history` field will be populated with the entire history. It\nmay also be populated if this task originates on a non-sticky queue."
        },
        "workflowExecutionTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "description": "The task queue this task originated from, which will always be the original non-sticky name\nfor the queue, even if this response came from polling a sticky queue."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When this task was scheduled by the server"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "description": "When the current workflow task started event was generated, meaning the current attempt."
        },
        "queries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1WorkflowQuery"
          },
          "title": "Queries that should be executed after applying the history in this task. Responses should be\nattached to `RespondWorkflowTaskCompletedRequest::query_results`"
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Message"
          },
          "title": "Protocol messages piggybacking on a WFT as a transport"
        }
      }
    },
    "v1PollerInfo": {
      "type": "object",
      "properties": {
        "lastAccessTime": {
          "type": "string",
          "format": "date-time"
        },
        "identity": {
          "type": "string"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "workerVersionCapabilities": {
          "$ref": "#/definitions/v1WorkerVersionCapabilities",
          "description": "If a worker has opted into the worker versioning feature while polling, its capabilities will\nappear here."
        }
      }
    },
    "v1ProtocolMessageCommandAttributes": {
      "type": "object",
      "properties": {
        "messageId": {
          "type": "string",
          "description": "The message ID of the message to which this command is a pointer."
        }
      }
    },
    "v1QueryRejectCondition": {
      "type": "string",
      "enum": [
        "QUERY_REJECT_CONDITION_UNSPECIFIED",
        "QUERY_REJECT_CONDITION_NONE",
        "QUERY_REJECT_CONDITION_NOT_OPEN",
        "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY"
      ],
      "default": "QUERY_REJECT_CONDITION_UNSPECIFIED",
      "description": " - QUERY_REJECT_CONDITION_NONE: None indicates that query should not be rejected.\n - QUERY_REJECT_CONDITION_NOT_OPEN: NotOpen indicates that query should be rejected if workflow is not open.\n - QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY: NotCompletedCleanly indicates that query should be rejected if workflow did not complete cleanly."
    },
    "v1QueryRejected": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1QueryResultType": {
      "type": "string",
      "enum": [
        "QUERY_RESULT_TYPE_UNSPECIFIED",
        "QUERY_RESULT_TYPE_ANSWERED",
        "QUERY_RESULT_TYPE_FAILED"
      ],
      "default": "QUERY_RESULT_TYPE_UNSPECIFIED"
    },
    "v1QueryWorkflowResponse": {
      "type": "object",
      "properties": {
        "queryResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "queryRejected": {
          "$ref": "#/definitions/v1QueryRejected"
        }
      }
    },
    "v1RampByPercentage": {
      "type": "object",
      "properties": {
        "rampPercentage": {
          "type": "number",
          "format": "float",
          "description": "Acceptable range is [0,100)."
        }
      }
    },
    "v1Range": {
      "type": "object",
      "properties": {
        "start": {
          "type": "integer",
          "format": "int32",
          "description": "Start of range (inclusive)."
        },
        "end": {
          "type": "integer",
          "format": "int32",
          "description": "End of range (inclusive)."
        },
        "step": {
          "type": "integer",
          "format": "int32",
          "description": "Step (optional, default 1)."
        }
      },
      "description": "Range represents a set of integer values, used to match fields of a calendar\ntime in StructuredCalendarSpec. If end < start, then end is interpreted as\nequal to start. This means you can use a Range with start set to a value, and\nend and step unset (defaulting to 0) to represent a single value."
    },
    "v1RecordActivityTaskHeartbeatByIdResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        }
      }
    },
    "v1RecordActivityTaskHeartbeatResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        },
        "activityPaused": {
          "type": "boolean",
          "description": "Will be set to true if the activity is paused."
        }
      }
    },
    "v1RecordMarkerCommandAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string"
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          }
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      }
    },
    "v1RegisterNamespaceRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "workflowExecutionRetentionPeriod": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "activeClusterName": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "securityToken": {
          "type": "string"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        }
      }
    },
    "v1RegisterNamespaceResponse": {
      "type": "object"
    },
    "v1ReleaseInfo": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string"
        },
        "releaseTime": {
          "type": "string",
          "format": "date-time"
        },
        "notes": {
          "type": "string"
        }
      },
      "description": "ReleaseInfo contains information about specific version of temporal."
    },
    "v1RemoveRemoteClusterResponse": {
      "type": "object"
    },
    "v1RemoveSearchAttributesResponse": {
      "type": "object"
    },
    "v1ReplicationState": {
      "type": "string",
      "enum": [
        "REPLICATION_STATE_UNSPECIFIED",
        "REPLICATION_STATE_NORMAL",
        "REPLICATION_STATE_HANDOVER"
      ],
      "default": "REPLICATION_STATE_UNSPECIFIED"
    },
    "v1RequestCancelActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled."
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1CancelExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed to cancel.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure\ncorresponds to"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "The namespace the workflow to be cancelled lives in.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelNexusOperationCommandAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.\nThe operation may ignore cancellation and end up with any completion state."
        }
      }
    },
    "v1RequestCancelWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1ResetActivityByIdResponse": {
      "type": "object"
    },
    "v1ResetOptions": {
      "type": "object",
      "properties": {
        "firstWorkflowTask": {
          "type": "object",
          "properties": {},
          "description": "Resets to the first workflow task completed or started event."
        },
        "lastWorkflowTask": {
          "type": "object",
          "properties": {},
          "description": "Resets to the last workflow task completed or started event."
        },
        "workflowTaskId": {
          "type": "string",
          "format": "int64",
          "description": "The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n`WORKFLOW_TASK_STARTED` event to reset to.\nNote that this option doesn't make sense when used as part of a batch request."
        },
        "buildId": {
          "type": "string",
          "description": "Resets to the first workflow task processed by this build id.\nIf the workflow was not processed by the build id, or the workflow task can't be\ndetermined, no reset will be performed.\nNote that by default, this reset is allowed to be to a prior run in a chain of\ncontinue-as-new."
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "title": "Event types to be reapplied (deprecated)\nDefault: RESET_REAPPLY_TYPE_SIGNAL"
        },
        "currentRunOnly": {
          "type": "boolean",
          "title": "If true, limit the reset to only within the current run. (Applies to build_id targets and\npossibly others in the future.)"
        },
        "resetReapplyExcludeTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ResetReapplyExcludeType"
          },
          "title": "Event types not to be reapplied"
        }
      },
      "description": "Describes where and how to reset a workflow, used for batch reset currently\nand may be used for single-workflow reset later."
    },
    "v1ResetPointInfo": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "Worker build id."
        },
        "binaryChecksum": {
          "type": "string",
          "description": "A worker binary version identifier (deprecated)."
        },
        "runId": {
          "type": "string",
          "description": "The first run ID in the execution chain that was touched by this worker build."
        },
        "firstWorkflowTaskCompletedId": {
          "type": "string",
          "format": "int64",
          "description": "Event ID of the first WorkflowTaskCompleted event processed by this worker build."
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "expireTime": {
          "type": "string",
          "format": "date-time",
          "description": "\nThe time that the run is deleted due to retention."
        },
        "resettable": {
          "type": "boolean",
          "description": "false if the reset point has pending childWFs/reqCancels/signalExternals."
        }
      },
      "description": "ResetPointInfo records the workflow event id that is the first one processed by a given\nbuild id or binary checksum. A new reset point will be created if either build id or binary\nchecksum changes (although in general only one or the other will be used at a time)."
    },
    "v1ResetPoints": {
      "type": "object",
      "properties": {
        "points": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ResetPointInfo"
          }
        }
      }
    },
    "v1ResetReapplyExcludeType": {
      "type": "string",
      "enum": [
        "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
        "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL",
        "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE",
        "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS"
      ],
      "default": "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
      "description": "Event types to exclude when reapplying events beyond the reset point.\n\n - RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL: Exclude signals when reapplying events beyond the reset point.\n - RESET_REAPPLY_EXCLUDE_TYPE_UPDATE: Exclude updates when reapplying events beyond the reset point.\n - RESET_REAPPLY_EXCLUDE_TYPE_NEXUS: Exclude nexus events when reapplying events beyond the reset point."
    },
    "v1ResetReapplyType": {
      "type": "string",
      "enum": [
        "RESET_REAPPLY_TYPE_UNSPECIFIED",
        "RESET_REAPPLY_TYPE_SIGNAL",
        "RESET_REAPPLY_TYPE_NONE",
        "RESET_REAPPLY_TYPE_ALL_ELIGIBLE"
      ],
      "default": "RESET_REAPPLY_TYPE_UNSPECIFIED",
      "description": "Event types to include when reapplying events. Deprecated: applications\nshould use ResetReapplyExcludeType to specify exclusions from this set, and\nnew event types should be added to ResetReapplyExcludeType instead of here.\n\n - RESET_REAPPLY_TYPE_SIGNAL: Signals are reapplied when workflow is reset.\n - RESET_REAPPLY_TYPE_NONE: No events are reapplied when workflow is reset.\n - RESET_REAPPLY_TYPE_ALL_ELIGIBLE: All eligible events are reapplied when workflow is reset."
    },
    "v1ResetStickyTaskQueueResponse": {
      "type": "object"
    },
    "v1ResetType": {
      "type": "string",
      "enum": [
        "RESET_TYPE_UNSPECIFIED",
        "RESET_TYPE_FIRST_WORKFLOW_TASK",
        "RESET_TYPE_LAST_WORKFLOW_TASK"
      ],
      "default": "RESET_TYPE_UNSPECIFIED",
      "description": "Reset type options. Deprecated, see temporal.api.common.v1.ResetOptions.\n\n - RESET_TYPE_FIRST_WORKFLOW_TASK: Resets to event of the first workflow task completed, or if it does not exist, the event after task scheduled.\n - RESET_TYPE_LAST_WORKFLOW_TASK: Resets to event of the last workflow task completed, or if it does not exist, the event after task scheduled."
    },
    "v1ResetWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string"
        }
      }
    },
    "v1ResetWorkflowFailureInfo": {
      "type": "object",
      "properties": {
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1RespondActivityTaskCanceledByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCanceledResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskFailedByIdResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apifailurev1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondActivityTaskFailedResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apifailurev1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondNexusTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondNexusTaskFailedResponse": {
      "type": "object"
    },
    "v1RespondQueryTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondWorkflowTaskCompletedRequestCapabilities": {
      "type": "object",
      "properties": {
        "discardSpeculativeWorkflowTaskWithEvents": {
          "type": "boolean",
          "title": "True if the SDK can handle speculative workflow task with command events.\nIf true, the server may chosse, at its discretion, to discard a speculative workflow task\neven if that speculative task included command events the SDK had not previouly processed"
        }
      },
      "description": "SDK capability details."
    },
    "v1RespondWorkflowTaskCompletedResponse": {
      "type": "object",
      "properties": {
        "workflowTask": {
          "$ref": "#/definitions/v1PollWorkflowTaskQueueResponse",
          "title": "See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`"
        },
        "activityTasks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollActivityTaskQueueResponse"
          },
          "title": "See `ScheduleActivityTaskCommandAttributes::request_eager_execution`"
        },
        "resetHistoryEventId": {
          "type": "string",
          "format": "int64",
          "description": "If non zero, indicates the server has discarded the workflow task that was being responded to.\nWill be the event ID of the last workflow task started event in the history before the new workflow task.\nServer is only expected to discard a workflow task if it could not have modified the workflow state."
        }
      }
    },
    "v1RespondWorkflowTaskFailedResponse": {
      "type": "object"
    },
    "v1RetryPolicy": {
      "type": "object",
      "properties": {
        "initialInterval": {
          "type": "string",
          "description": "Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries."
        },
        "backoffCoefficient": {
          "type": "number",
          "format": "double",
          "description": "Coefficient used to calculate the next retry interval.\nThe next retry interval is previous interval multiplied by the coefficient.\nMust be 1 or larger."
        },
        "maximumInterval": {
          "type": "string",
          "description": "Maximum interval between retries. Exponential backoff leads to interval increase.\nThis value is the cap of the increase. Default is 100x of the initial interval."
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n1 disables retries. 0 means unlimited (up to the timeouts)"
        },
        "nonRetryableErrorTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that\nthis is not a substring match, the error *type* (not message) must match exactly."
        }
      },
      "title": "How retries ought to be handled, usable by both workflows and activities"
    },
    "v1RetryState": {
      "type": "string",
      "enum": [
        "RETRY_STATE_UNSPECIFIED",
        "RETRY_STATE_IN_PROGRESS",
        "RETRY_STATE_NON_RETRYABLE_FAILURE",
        "RETRY_STATE_TIMEOUT",
        "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
        "RETRY_STATE_RETRY_POLICY_NOT_SET",
        "RETRY_STATE_INTERNAL_SERVER_ERROR",
        "RETRY_STATE_CANCEL_REQUESTED"
      ],
      "default": "RETRY_STATE_UNSPECIFIED"
    },
    "v1ScanWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1Schedule": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec"
        },
        "action": {
          "$ref": "#/definitions/v1ScheduleAction"
        },
        "policies": {
          "$ref": "#/definitions/v1SchedulePolicies"
        },
        "state": {
          "$ref": "#/definitions/v1ScheduleState"
        }
      }
    },
    "v1ScheduleAction": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1NewWorkflowExecutionInfo",
          "description": "All fields of NewWorkflowExecutionInfo are valid except for:\n- workflow_id_reuse_policy\n- cron_schedule\nThe workflow id of the started workflow may not match this exactly,\nit may have a timestamp appended for uniqueness."
        }
      }
    },
    "v1ScheduleActionResult": {
      "type": "object",
      "properties": {
        "scheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (according to the schedule, including jitter)."
        },
        "actualTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (real time)."
        },
        "startWorkflowResult": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "If action was start_workflow:"
        },
        "startWorkflowStatus": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus",
          "description": "If the action was start_workflow, this field will reflect an\neventually-consistent view of the started workflow's status."
        }
      }
    },
    "v1ScheduleActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for activity completion. The \"schedule\" time\nis when the activity is initially scheduled, not when the most recent retry is scheduled.\nLimits how long retries will be attempted. Either this or `start_to_close_timeout` must be\nspecified. When not specified, defaults to the workflow execution timeout.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "title": "Limits the time an activity task can stay in a task queue before a worker picks it up. The\n\"schedule\" time is when the most recent retry is scheduled. This timeout should usually not\nbe set: it's useful in specific scenarios like worker-specific task queues. This timeout is\nalways non retryable, as all a retry would achieve is to put it back into the same queue.\nDefaults to `schedule_to_close_timeout` or workflow execution timeout if that is not\nspecified. More info:\nhttps://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are provided by a default retry policy which is controlled through the service's\ndynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has\nelapsed. To disable retries set retry_policy.maximum_attempts to 1."
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to start the activity directly bypassing matching service and worker polling\nThe slot for executing the activity should be reserved when setting this field to true."
        },
        "useWorkflowBuildId": {
          "type": "boolean",
          "description": "If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,\nAssignment rules of the activity's Task Queue will be used to determine the Build ID."
        }
      }
    },
    "v1ScheduleInfo": {
      "type": "object",
      "properties": {
        "actionCount": {
          "type": "string",
          "format": "int64",
          "description": "Number of actions taken so far."
        },
        "missedCatchupWindow": {
          "type": "string",
          "format": "int64",
          "description": "Number of times a scheduled action was skipped due to missing the catchup window."
        },
        "overlapSkipped": {
          "type": "string",
          "format": "int64",
          "description": "Number of skipped actions due to overlap."
        },
        "bufferDropped": {
          "type": "string",
          "format": "int64",
          "description": "Number of dropped actions due to buffer limit."
        },
        "bufferSize": {
          "type": "string",
          "format": "int64",
          "description": "Number of actions in the buffer. The buffer holds the actions that cannot\nbe immediately triggered (due to the overlap policy). These actions can be a result of\nthe normal schedule or a backfill."
        },
        "runningWorkflows": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecution"
          },
          "description": "Currently-running workflows started by this schedule. (There might be\nmore than one if the overlap policy allows overlaps.)\nNote that the run_ids in here are the original execution run ids as\nstarted by the schedule. If the workflows retried, did continue-as-new,\nor were reset, they might still be running but with a different run_id."
        },
        "recentActions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "description": "Most recent ten actual action times (including manual triggers)."
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          },
          "description": "Next ten scheduled action times."
        },
        "createTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamps of schedule creation and last update."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time"
        },
        "invalidScheduleError": {
          "type": "string"
        }
      }
    },
    "v1ScheduleListEntry": {
      "type": "object",
      "properties": {
        "scheduleId": {
          "type": "string"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleListInfo"
        }
      },
      "description": "ScheduleListEntry is returned by ListSchedules."
    },
    "v1ScheduleListInfo": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec",
          "title": "From spec:\nSome fields are dropped from this copy of spec: timezone_data"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "From action:\nAction is a oneof field, but we need to encode this in JSON and oneof fields don't work\nwell with JSON. If action is start_workflow, this is set:"
        },
        "notes": {
          "type": "string",
          "title": "From state:"
        },
        "paused": {
          "type": "boolean"
        },
        "recentActions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "title": "From info (maybe fewer entries):"
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "description": "ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo\nthat's returned in ListSchedules."
    },
    "v1ScheduleNexusOperationCommandAttributes": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name, must exist in the endpoint registry or this command will fail."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "input": {
          "$ref": "#/definitions/v1Payload",
          "description": "Input for the operation. The server converts this into Nexus request content and the appropriate content headers\ninternally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the\ncontent is transformed back to the original Payload sent in this command."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nIndicates how long the caller is willing to wait for operation completion.\nCalls are retried internally by the server."
        },
        "nexusHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to the Nexus request.\nUsers are responsible for encrypting sensitive data in this header as it is stored in workflow history and\ntransmitted to external services as-is.\nThis is useful for propagating tracing information.\nNote these headers are not the same as Temporal headers on internal activities and child workflows, these are\ntransmitted to Nexus operations that may be external and are not traditional payloads."
        }
      }
    },
    "v1ScheduleOverlapPolicy": {
      "type": "string",
      "enum": [
        "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
        "SCHEDULE_OVERLAP_POLICY_SKIP",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
        "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
        "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
        "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
      ],
      "default": "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
      "description": "ScheduleOverlapPolicy controls what happens when a workflow would be started\nby a schedule, and is already running.\n\n - SCHEDULE_OVERLAP_POLICY_SKIP: SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the\nworkflow completes, the next scheduled event after that time will be considered.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ONE: SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the\ncurrent one completes, but only buffer one start in this way. If another start is\nsupposed to happen when the workflow is running, and one is already buffered, then\nonly the first one will be started after the running workflow finishes.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ALL: SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all\nhappen sequentially, immediately after the running workflow completes.\n - SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER: SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow\nrunning, cancel it, and start the new one after the old one completes cancellation.\n - SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER: SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow\nrunning, terminate it and start the new one immediately.\n - SCHEDULE_OVERLAP_POLICY_ALLOW_ALL: SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.\nNote that with this policy, last completion result and last failure will not be\navailable since workflows are not sequential."
    },
    "v1SchedulePatch": {
      "type": "object",
      "properties": {
        "triggerImmediately": {
          "$ref": "#/definitions/v1TriggerImmediatelyRequest",
          "description": "If set, trigger one action immediately."
        },
        "backfillRequest": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BackfillRequest"
          },
          "description": "If set, runs though the specified time period(s) and takes actions as if that time\npassed by right now, all at once. The overlap policy can be overridden for the\nscope of the backfill."
        },
        "pause": {
          "type": "string",
          "description": "If set, change the state to paused or unpaused (respectively) and set the\nnotes field to the value of the string."
        },
        "unpause": {
          "type": "string"
        }
      }
    },
    "v1SchedulePolicies": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "Policy for overlaps.\nNote that this can be changed after a schedule has taken some actions,\nand some changes might produce unintuitive results. In general, the later\npolicy overrides the earlier policy."
        },
        "catchupWindow": {
          "type": "string",
          "description": "Policy for catchups:\nIf the Temporal server misses an action due to one or more components\nbeing down, and comes back up, the action will be run if the scheduled\ntime is within this window from the current time.\nThis value defaults to one year, and can't be less than 10 seconds."
        },
        "pauseOnFailure": {
          "type": "boolean",
          "description": "If true, and a workflow run fails or times out, turn on \"paused\".\nThis applies after retry policies: the full chain of retries must fail to\ntrigger a pause here."
        },
        "keepOriginalWorkflowId": {
          "type": "boolean",
          "description": "If true, and the action would start a workflow, a timestamp will not be\nappended to the scheduled workflow id."
        }
      }
    },
    "v1ScheduleSpec": {
      "type": "object",
      "properties": {
        "structuredCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "cronString": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "cron_string holds a traditional cron specification as a string. It\naccepts 5, 6, or 7 fields, separated by spaces, and interprets them the\nsame way as CalendarSpec.\n5 fields:         minute, hour, day_of_month, month, day_of_week\n6 fields:         minute, hour, day_of_month, month, day_of_week, year\n7 fields: second, minute, hour, day_of_month, month, day_of_week, year\nIf year is not given, it defaults to *. If second is not given, it\ndefaults to 0.\nShorthands @yearly, @monthly, @weekly, @daily, and @hourly are also\naccepted instead of the 5-7 time fields.\nOptionally, the string can be preceded by CRON_TZ=<timezone name> or\nTZ=<timezone name>, which will get copied to timezone_name. (There must\nnot also be a timezone_name present.)\nOptionally \"#\" followed by a comment can appear at the end of the string.\nNote that the special case that some cron implementations have for\ntreating day_of_month and day_of_week as \"or\" instead of \"and\" when both\nare set is not implemented.\n@every <interval>[/<phase>] is accepted and gets compiled into an\nIntervalSpec instead. <interval> and <phase> should be a decimal integer\nwith a unit suffix s, m, h, or d."
        },
        "calendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "interval": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1IntervalSpec"
          },
          "description": "Interval-based specifications of times."
        },
        "excludeCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Any timestamps matching any of exclude_* will be skipped.\n\nuse exclude_structured_calendar"
        },
        "excludeStructuredCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          }
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "If start_time is set, any timestamps before start_time will be skipped.\n(Together, start_time and end_time make an inclusive interval.)"
        },
        "endTime": {
          "type": "string",
          "format": "date-time",
          "description": "If end_time is set, any timestamps after end_time will be skipped."
        },
        "jitter": {
          "type": "string",
          "title": "All timestamps will be incremented by a random value from 0 to this\namount of jitter. Default: 0"
        },
        "timezoneName": {
          "type": "string",
          "description": "Time zone to interpret all calendar-based specs in.\n\nIf unset, defaults to UTC. We recommend using UTC for your application if\nat all possible, to avoid various surprising properties of time zones.\n\nTime zones may be provided by name, corresponding to names in the IANA\ntime zone database (see https://www.iana.org/time-zones). The definition\nwill be loaded by the Temporal server from the environment it runs in.\n\nIf your application requires more control over the time zone definition\nused, it may pass in a complete definition in the form of a TZif file\nfrom the time zone database. If present, this will be used instead of\nloading anything from the environment. You are then responsible for\nupdating timezone_data when the definition changes.\n\nCalendar spec matching is based on literal matching of the clock time\nwith no special handling of DST: if you write a calendar spec that fires\nat 2:30am and specify a time zone that follows DST, that action will not\nbe triggered on the day that has no 2:30am. Similarly, an action that\nfires at 1:30am will be triggered twice on the day that has two 1:30s.\n\nAlso note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC)."
        },
        "timezoneData": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "ScheduleSpec is a complete description of a set of absolute timestamps\n(possibly infinite) that an action should occur at. The meaning of a\nScheduleSpec depends only on its contents and never changes, except that the\ndefinition of a time zone can change over time (most commonly, when daylight\nsaving time policy changes for an area). To create a totally self-contained\nScheduleSpec, use UTC or include timezone_data.\n\nFor input, you can provide zero or more of: structured_calendar, calendar,\ncron_string, interval, and exclude_structured_calendar, and all of them will\nbe used (the schedule will take action at the union of all of their times,\nminus the ones that match exclude_structured_calendar).\n\nOn input, calendar and cron_string fields will be compiled into\nstructured_calendar (and maybe interval and timezone_name), so if you\nDescribe a schedule, you'll see only structured_calendar, interval, etc.\n\nIf a spec has no matching times after the current time, then the schedule\nwill be subject to automatic deletion (after several days)."
    },
    "v1ScheduleState": {
      "type": "object",
      "properties": {
        "notes": {
          "type": "string",
          "description": "Informative human-readable message with contextual notes, e.g. the reason\na schedule is paused. The system may overwrite this message on certain\nconditions, e.g. when pause-on-failure happens."
        },
        "paused": {
          "type": "boolean",
          "description": "If true, do not take any actions based on the schedule spec."
        },
        "limitedActions": {
          "type": "boolean",
          "description": "If limited_actions is true, decrement remaining_actions after each\naction, and do not take any more scheduled actions if remaining_actions\nis zero. Actions may still be taken by explicit request (i.e. trigger\nimmediately or backfill). Skipped actions (due to overlap policy) do not\ncount against remaining actions.\nIf a schedule has no more remaining actions, then the schedule will be\nsubject to automatic deletion (after several days)."
        },
        "remainingActions": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1SearchAttributes": {
      "type": "object",
      "properties": {
        "indexedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.\nThe payload is not serialized in a user-defined way."
    },
    "v1ServerFailureInfo": {
      "type": "object",
      "properties": {
        "nonRetryable": {
          "type": "boolean"
        }
      }
    },
    "v1Severity": {
      "type": "string",
      "enum": [
        "SEVERITY_UNSPECIFIED",
        "SEVERITY_HIGH",
        "SEVERITY_MEDIUM",
        "SEVERITY_LOW"
      ],
      "default": "SEVERITY_UNSPECIFIED"
    },
    "v1ShutdownWorkerResponse": {
      "type": "object"
    },
    "v1SignalExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "description": "The workflow author-defined name of the signal to send to the workflow."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized value(s) to provide with the signal."
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed by the workflow that is sending a signal to the external \nworkflow that is receiving this signal."
        }
      }
    },
    "v1SignalExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED"
      ],
      "default": "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
      "title": "- SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED: Signal count limit is per workflow and controlled by server dynamic config \"history.maximumSignalsPerExecution\""
    },
    "v1SignalExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed the signal.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        }
      }
    },
    "v1SignalExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-signalled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "title": "name/type of the signal to fire in the external workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized arguments to provide to the signal handler"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1SignalWithStartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string",
          "description": "The run id of the workflow that was started - or just signaled, if it was already running."
        },
        "started": {
          "type": "boolean",
          "description": "If true, a new workflow was started."
        }
      }
    },
    "v1SignalWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1StartBatchOperationResponse": {
      "type": "object"
    },
    "v1StartChildWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Establish a cron schedule for the child workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment\nrules of the child's Task Queue will be used to independently assign a Build ID to it."
        }
      }
    },
    "v1StartChildWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1StartChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "cause": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedCause"
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1StartChildWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this child runs on a cron schedule, it will appear here"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment\nrules of the child's Task Queue will be used to independently assign a Build ID to it."
        }
      }
    },
    "v1StartOperationRequest": {
      "type": "object",
      "properties": {
        "service": {
          "type": "string",
          "description": "Name of service to start the operation in."
        },
        "operation": {
          "type": "string",
          "description": "Type of operation to start."
        },
        "requestId": {
          "type": "string",
          "description": "A request ID that can be used as an idempotentency key."
        },
        "callback": {
          "type": "string",
          "description": "Callback URL to call upon completion if the started operation is async."
        },
        "payload": {
          "$ref": "#/definitions/v1Payload",
          "description": "Full request body from the incoming HTTP request."
        },
        "callbackHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header that is expected to be attached to the callback request when the operation completes."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apinexusv1Link"
          },
          "description": "Links contain caller information and can be attached to the operations started by the handler."
        }
      },
      "description": "A request to start an operation."
    },
    "v1StartOperationResponse": {
      "type": "object",
      "properties": {
        "syncSuccess": {
          "$ref": "#/definitions/StartOperationResponseSync"
        },
        "asyncSuccess": {
          "$ref": "#/definitions/StartOperationResponseAsync"
        },
        "operationError": {
          "$ref": "#/definitions/v1UnsuccessfulOperationError",
          "description": "The operation completed unsuccessfully (failed or canceled)."
        }
      },
      "description": "Response variant for StartOperationRequest."
    },
    "v1StartTimeFilter": {
      "type": "object",
      "properties": {
        "earliestTime": {
          "type": "string",
          "format": "date-time"
        },
        "latestTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1StartTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "description": "An id for the timer, currently live timers must have different ids. Typically autogenerated\nby the SDK."
        },
        "startToFireTimeout": {
          "type": "string",
          "description": "How long until the timer fires, producing a `TIMER_FIRED` event.\n"
        }
      }
    },
    "v1StartWorkflowExecutionRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this start request. Typically UUIDv4."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to get the first workflow task inline in the response bypassing matching service and worker polling.\nIf set to `true` the caller is expected to have a worker available and capable of processing the task.\nThe returned task will be marked as started and is expected to be completed by the specified\n`workflow_task_timeout`."
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "These values will be available as ContinuedFailure and LastCompletionResult in the\nWorkflowExecutionStarted event and through SDKs. The are currently only used by the\nserver itself (for the schedules feature) and are not intended to be exposed in\nStartWorkflowExecution."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nIf the workflow gets a signal before the delay, a workflow task will be dispatched and the rest\nof the delay will be ignored."
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Callbacks to be called by the server when this workflow reaches a terminal state.\nIf the workflow continues-as-new, these callbacks will be carried over to the new execution.\nCallback addresses must be whitelisted in the server's dynamic configuration."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the workflow."
        }
      }
    },
    "v1StartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string",
          "description": "The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING)."
        },
        "started": {
          "type": "boolean",
          "description": "If true, a new workflow was started."
        },
        "eagerWorkflowTask": {
          "$ref": "#/definitions/v1PollWorkflowTaskQueueResponse",
          "description": "When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will\nreturn the first workflow task to be eagerly executed.\nThe caller is expected to have a worker available to process the task."
        }
      }
    },
    "v1StatusFilter": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1StickyExecutionAttributes": {
      "type": "object",
      "properties": {
        "workerTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "scheduleToStartTimeout": {
          "type": "string"
        }
      }
    },
    "v1StopBatchOperationResponse": {
      "type": "object"
    },
    "v1StructuredCalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match seconds (0-59)"
        },
        "minute": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match minutes (0-59)"
        },
        "hour": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match hours (0-23)"
        },
        "dayOfMonth": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match days of the month (1-31)"
        },
        "month": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match months (1-12)"
        },
        "year": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match years."
        },
        "dayOfWeek": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match days of the week (0-6; 0 is Sunday)."
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "title": "StructuredCalendarSpec describes an event specification relative to the\ncalendar, in a form that's easy to work with programmatically. Each field can\nbe one or more ranges.\nA timestamp matches if at least one range of each field matches the\ncorresponding fields of the timestamp, except for year: if year is missing,\nthat means all years match. For all fields besides year, at least one Range\nmust be present to match anything.\nTODO: add relative-to-end-of-month\nTODO: add nth day-of-week in month"
    },
    "v1TaskIdBlock": {
      "type": "object",
      "properties": {
        "startId": {
          "type": "string",
          "format": "int64"
        },
        "endId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1TaskQueue": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/v1TaskQueueKind",
          "description": "Default: TASK_QUEUE_KIND_NORMAL."
        },
        "normalName": {
          "type": "string",
          "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/task-queues/"
    },
    "v1TaskQueueKind": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_KIND_UNSPECIFIED",
        "TASK_QUEUE_KIND_NORMAL",
        "TASK_QUEUE_KIND_STICKY"
      ],
      "default": "TASK_QUEUE_KIND_UNSPECIFIED",
      "description": "The task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
      "title": "- TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history"
    },
    "v1TaskQueueMetadata": {
      "type": "object",
      "properties": {
        "maxTasksPerSecond": {
          "type": "number",
          "format": "double",
          "title": "Allows throttling dispatch of tasks from this queue"
        }
      },
      "title": "Only applies to activity task queues"
    },
    "v1TaskQueuePartitionMetadata": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "ownerHostName": {
          "type": "string"
        }
      }
    },
    "v1TaskQueueReachability": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "type": "string"
        },
        "reachability": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TaskReachability"
          },
          "description": "Task reachability for a worker in a single task queue.\nSee the TaskReachability docstring for information about each enum variant.\nIf reachability is empty, this worker is considered unreachable in this task queue."
        }
      },
      "description": "Reachability of tasks for a worker on a single task queue."
    },
    "v1TaskQueueStats": {
      "type": "object",
      "properties": {
        "approximateBacklogCount": {
          "type": "string",
          "format": "int64",
          "description": "The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually\nconverges to the right value. Can be relied upon for scaling decisions.\n\nSpecial note for workflow task queue type: this metric does not count sticky queue tasks. However, because\nthose tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size\ngrows."
        },
        "approximateBacklogAge": {
          "type": "string",
          "description": "Approximate age of the oldest task in the backlog based on the creation time of the task at the head of\nthe queue. Can be relied upon for scaling decisions.\n\nSpecial note for workflow task queue type: this metric does not count sticky queue tasks. However, because\nthose tasks only remain valid for a few seconds, they should not affect the result when backlog is older than\nfew seconds."
        },
        "tasksAddRate": {
          "type": "number",
          "format": "float",
          "description": "The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks\nwhether or not they were added to/dispatched from the backlog or they were dispatched immediately without going\nto the backlog (sync-matched).\n\nThe difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\nbacklog grows/shrinks.\n\nNote: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\ntasks_add_rate, because:\n- Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n  enable for activities by default in the latest SDKs.\n- Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n  workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n  worker instance."
        },
        "tasksDispatchRate": {
          "type": "number",
          "format": "float",
          "description": "The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes\ntasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without\ngoing to the backlog (sync-matched).\n\nThe difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\nbacklog grows/shrinks.\n\nNote: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\ntasks_dispatch_rate, because:\n- Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n  enable for activities by default in the latest SDKs.\n- Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n  workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n  worker instance."
        }
      },
      "description": "TaskQueueStats contains statistics about task queue backlog and activity.\n\nFor workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read\ncomments above each metric to understand the impact of sticky queue exclusion on that metric accuracy."
    },
    "v1TaskQueueStatus": {
      "type": "object",
      "properties": {
        "backlogCountHint": {
          "type": "string",
          "format": "int64"
        },
        "readLevel": {
          "type": "string",
          "format": "int64"
        },
        "ackLevel": {
          "type": "string",
          "format": "int64"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "taskIdBlock": {
          "$ref": "#/definitions/v1TaskIdBlock"
        }
      },
      "description": "Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior."
    },
    "v1TaskQueueType": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_TYPE_UNSPECIFIED",
        "TASK_QUEUE_TYPE_WORKFLOW",
        "TASK_QUEUE_TYPE_ACTIVITY",
        "TASK_QUEUE_TYPE_NEXUS"
      ],
      "default": "TASK_QUEUE_TYPE_UNSPECIFIED",
      "description": " - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests."
    },
    "v1TaskQueueTypeInfo": {
      "type": "object",
      "properties": {
        "pollers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollerInfo"
          },
          "description": "Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID."
        },
        "stats": {
          "$ref": "#/definitions/v1TaskQueueStats"
        }
      }
    },
    "v1TaskQueueVersionInfo": {
      "type": "object",
      "properties": {
        "typesInfo": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueTypeInfo"
          },
          "description": "Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum."
        },
        "taskReachability": {
          "$ref": "#/definitions/v1BuildIdTaskReachability",
          "description": "Task Reachability is eventually consistent; there may be a delay until it converges to the most\naccurate value but it is designed in a way to take the more conservative side until it converges.\nFor example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.\n\nNote: future activities who inherit their workflow's Build ID but not its Task Queue will not be\naccounted for reachability as server cannot know if they'll happen as they do not use\nassignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows\nwho inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make\nsure to query reachability for the parent/previous workflow's Task Queue as well."
        }
      }
    },
    "v1TaskQueueVersionSelection": {
      "type": "object",
      "properties": {
        "buildIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Include specific Build IDs."
        },
        "unversioned": {
          "type": "boolean",
          "description": "Include the unversioned queue."
        },
        "allActive": {
          "type": "boolean",
          "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls."
        }
      },
      "description": "Used for specifying versions the caller is interested in."
    },
    "v1TaskReachability": {
      "type": "string",
      "enum": [
        "TASK_REACHABILITY_UNSPECIFIED",
        "TASK_REACHABILITY_NEW_WORKFLOWS",
        "TASK_REACHABILITY_EXISTING_WORKFLOWS",
        "TASK_REACHABILITY_OPEN_WORKFLOWS",
        "TASK_REACHABILITY_CLOSED_WORKFLOWS"
      ],
      "default": "TASK_REACHABILITY_UNSPECIFIED",
      "description": "Specifies which category of tasks may reach a worker on a versioned task queue.\nUsed both in a reachability query and its response.\nDeprecated.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows."
    },
    "v1TerminateWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1TerminatedFailureInfo": {
      "type": "object"
    },
    "v1TimeoutFailureInfo": {
      "type": "object",
      "properties": {
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1TimeoutType": {
      "type": "string",
      "enum": [
        "TIMEOUT_TYPE_UNSPECIFIED",
        "TIMEOUT_TYPE_START_TO_CLOSE",
        "TIMEOUT_TYPE_SCHEDULE_TO_START",
        "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
        "TIMEOUT_TYPE_HEARTBEAT"
      ],
      "default": "TIMEOUT_TYPE_UNSPECIFIED"
    },
    "v1TimerCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "identity": {
          "type": "string",
          "title": "The id of the worker who requested this cancel"
        }
      }
    },
    "v1TimerFiredEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        }
      }
    },
    "v1TimerStartedEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The worker/user assigned id for this timer"
        },
        "startToFireTimeout": {
          "type": "string",
          "title": "How long until this timer fires"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1TimestampedBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1TimestampedCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1TriggerImmediatelyRequest": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "If set, override overlap policy for this one request."
        }
      }
    },
    "v1UnpauseActivityByIdResponse": {
      "type": "object"
    },
    "v1UnsuccessfulOperationError": {
      "type": "object",
      "properties": {
        "operationState": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#operationinfo."
        },
        "failure": {
          "$ref": "#/definitions/apinexusv1Failure"
        }
      }
    },
    "v1UpdateActivityOptionsByIdResponse": {
      "type": "object",
      "properties": {
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "title": "Activity options after an update"
        }
      }
    },
    "v1UpdateAdmittedEventOrigin": {
      "type": "string",
      "enum": [
        "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
        "UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY"
      ],
      "default": "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
      "description": "Records why a WorkflowExecutionUpdateAdmittedEvent was written to history.\nNote that not all admitted Updates result in this event.\n\n - UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY: The UpdateAdmitted event was created when reapplying events during reset\nor replication. I.e. an accepted Update on one branch of Workflow history\nwas converted into an admitted Update on a different branch."
    },
    "v1UpdateNamespaceInfo": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose.\nIf data already exists on the namespace, \nthis will merge with the existing key values."
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState",
          "description": "New namespace state, server will reject if transition is not allowed.\nAllowed transitions are:\n Registered -> [ Deleted | Deprecated | Handover ]\n Handover -> [ Registered ]\nDefault is NAMESPACE_STATE_UNSPECIFIED which is do not change state."
        }
      }
    },
    "v1UpdateNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        }
      }
    },
    "v1UpdateNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint",
          "description": "Data post acceptance. Can be used to issue additional updates to this record."
        }
      }
    },
    "v1UpdateRef": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "updateId": {
          "type": "string"
        }
      },
      "description": "The data needed by a client to refer to a previously invoked Workflow Update."
    },
    "v1UpdateScheduleResponse": {
      "type": "object"
    },
    "v1UpdateWorkerBuildIdCompatibilityResponse": {
      "type": "object"
    },
    "v1UpdateWorkerVersioningRulesResponse": {
      "type": "object",
      "properties": {
        "assignmentRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedBuildIdAssignmentRule"
          }
        },
        "compatibleRedirectRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedCompatibleBuildIdRedirectRule"
          }
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateWorkerVersioningRulesRequest to\nensure that the rules were not modified between the two updates, which\ncould lead to lost updates and other confusion."
        }
      }
    },
    "v1UpdateWorkflowExecutionLifecycleStage": {
      "type": "string",
      "enum": [
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED"
      ],
      "default": "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
      "description": "UpdateWorkflowExecutionLifecycleStage is specified by clients invoking\nWorkflow Updates and used to indicate to the server how long the\nclient wishes to wait for a return value from the API. If any value other\nthan UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED is sent by the\nclient then the API will complete before the Update is finished and will\nreturn a handle to the running Update so that it can later be polled for\ncompletion.\nIf specified stage wasn't reached before server timeout, server returns\nactual stage reached.\n\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED: An unspecified value for this enum.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED: The API call will not return until the Update request has been admitted\nby the server - it may be the case that due to a considerations like load\nor resource limits that an Update is made to wait before the server will\nindicate that it has been received and will be processed. This value\ndoes not wait for any sort of acknowledgement from a worker.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED: The API call will not return until the Update has passed validation on a worker.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED: The API call will not return until the Update has executed to completion\non a worker and has either been rejected or returned a value or an error."
    },
    "v1UpdateWorkflowExecutionRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "The namespace name of the target Workflow."
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "The target Workflow Id and (optionally) a specific Run Id thereof."
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no Run Id is set on\n`workflow_execution`), or specified (if it is) Workflow Execution is not\npart of the same execution chain as this Id."
        },
        "waitPolicy": {
          "$ref": "#/definitions/v1WaitPolicy",
          "description": "Specifies client's intent to wait for Update results.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached.\nActual reached stage will be included in the response."
        },
        "request": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The request information that will be delivered all the way down to the\nWorkflow Execution."
        }
      }
    },
    "v1UpdateWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "updateRef": {
          "$ref": "#/definitions/v1UpdateRef",
          "description": "Enough information for subsequent poll calls if needed. Never null."
        },
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of the Update if and only if the Workflow Update\nhas completed. If this response is being returned before the Update has\ncompleted then this field will not be set."
        },
        "stage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "The most advanced lifecycle stage that the Update is known to have\nreached, where lifecycle stages are ordered\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.\nUNSPECIFIED will be returned if and only if the server's maximum wait\ntime was reached before the Update reached the stage specified in the\nrequest WaitPolicy, and before the context deadline expired; clients may\nmay then retry the call as needed."
        }
      }
    },
    "v1UpsertWorkflowSearchAttributesCommandAttributes": {
      "type": "object",
      "properties": {
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1UpsertWorkflowSearchAttributesEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1UserMetadata": {
      "type": "object",
      "properties": {
        "summary": {
          "$ref": "#/definitions/v1Payload",
          "description": "Short-form text that provides a summary. This payload should be a \"json/plain\"-encoded payload\nthat is a single JSON string for use in user interfaces. User interface formatting may not\napply to this text when used in \"title\" situations. The payload data section is limited to 400\nbytes by default."
        },
        "details": {
          "$ref": "#/definitions/v1Payload",
          "description": "Long-form text that provides details. This payload should be a \"json/plain\"-encoded payload\nthat is a single JSON string for use in user interfaces. User interface formatting may apply to\nthis text in common use. The payload data section is limited to 20000 bytes by default."
        }
      },
      "description": "Information a user can set, often for use by user interfaces."
    },
    "v1VersionInfo": {
      "type": "object",
      "properties": {
        "current": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "recommended": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "instructions": {
          "type": "string"
        },
        "alerts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Alert"
          }
        },
        "lastUpdateTime": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions."
    },
    "v1WaitPolicy": {
      "type": "object",
      "properties": {
        "lifecycleStage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "Indicates the Update lifecycle stage that the Update must reach before\nAPI call is returned.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached."
        }
      },
      "description": "Specifies client's intent to wait for Update results."
    },
    "v1WorkerVersionCapabilities": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "title": "An opaque whole-worker identifier"
        },
        "useVersioning": {
          "type": "boolean",
          "description": "If set, the worker is opting in to worker versioning, and wishes to only receive appropriate\ntasks."
        }
      },
      "description": "Identifies the version(s) that a worker is compatible with when polling or identifying itself,\nand whether or not this worker is opting into the build-id based versioning feature. This is\nused by matching to determine which workers ought to receive what tasks."
    },
    "v1WorkerVersionStamp": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this\nmessage is included in requests which previously used that."
        },
        "useVersioning": {
          "type": "boolean",
          "description": "If set, the worker is opting in to worker versioning. Otherwise, this is used only as a\nmarker for workflow reset points and the BuildIDs search attribute."
        }
      },
      "title": "Identifies the version(s) of a worker that processed a task"
    },
    "v1WorkflowExecution": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      },
      "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
    },
    "v1WorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "type": "string",
          "title": "User provided reason for requesting cancellation\nTODO: shall we create a new field with name \"reason\" and deprecate this one?"
        },
        "externalInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?"
        },
        "externalWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker or client who requested this cancel"
        }
      }
    },
    "v1WorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1WorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized result of workflow completion (ie: The return value of the workflow function)"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionConfig": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "workflowExecutionTimeout": {
          "type": "string"
        },
        "workflowRunTimeout": {
          "type": "string"
        },
        "defaultWorkflowTaskTimeout": {
          "type": "string"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "User metadata provided on start workflow."
        }
      }
    },
    "v1WorkflowExecutionContinuedAsNewEventAttributes": {
      "type": "object",
      "properties": {
        "newExecutionRunId": {
          "type": "string",
          "title": "The run ID of the new workflow started by this continue-as-new"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "backoffStartInterval": {
          "type": "string",
          "title": "TODO: How and is this used?"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "TODO: David are these right?\nDeprecated. If a workflow's retry policy would cause a new run to start when the current one\nhas failed, this field would be populated with that failure. Now (when supported by server\nand sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "TODO: Is this the result of *this* workflow as it continued-as-new?"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the new execution inherits the Build ID of the current execution. Otherwise,\nthe assignment rules will be used to independently assign a Build ID to the new execution."
        }
      }
    },
    "v1WorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Serialized result of workflow failure (ex: An exception thrown, or error returned)"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionFilter": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      }
    },
    "v1WorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "type": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "startTime": {
          "type": "string",
          "format": "date-time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time"
        },
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        },
        "historyLength": {
          "type": "string",
          "format": "int64"
        },
        "parentNamespaceId": {
          "type": "string"
        },
        "parentExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "executionTime": {
          "type": "string",
          "format": "date-time"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "autoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "taskQueue": {
          "type": "string"
        },
        "stateTransitionCount": {
          "type": "string",
          "format": "int64"
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64"
        },
        "mostRecentWorkerVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "If set, the most recent worker version stamp that appeared in a workflow task completion"
        },
        "executionDuration": {
          "type": "string",
          "description": "Workflow execution duration is defined as difference between close time and execution time.\nThis field is only populated if the workflow is closed."
        },
        "rootExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about the root workflow execution.\nThe root workflow execution is defined as follows:\n1. A workflow without parent workflow is its own root workflow.\n2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\nNote: workflows continued as new or reseted may or may not have parents, check examples below.\n\nExamples:\n  Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 3: Workflow W1 continued as new W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n  Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n    - The root workflow of all three workflows is W1.\n  Scenario 5: Workflow W1 is reseted, creating W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2."
        },
        "assignedBuildId": {
          "type": "string",
          "description": "The currently assigned build ID for this execution. Presence of this value means worker versioning is used\nfor this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules\nwhen the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled\nagain, the assigned build ID may change according to the latest versioning rules.\nAssigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to\nthis execution."
        },
        "inheritedBuildId": {
          "type": "string",
          "description": "Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead\nof using the assignment rules."
        },
        "firstRunId": {
          "type": "string",
          "title": "The first run ID in the execution chain.\nExecutions created via the following operations are considered to be in the same chain\n- ContinueAsNew\n- Workflow Retry\n- Workflow Reset\n- Cron Schedule"
        }
      }
    },
    "v1WorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "signalName": {
          "type": "string",
          "title": "The name/type of the signal to fire"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Will be deserialized and provided as argument(s) to the signal handler"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker/client who sent this signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the sender of the signal and copied by temporal \nserver into the workflow task."
        },
        "skipGenerateWorkflowTask": {
          "type": "boolean",
          "description": "Indicates the signal did not generate a new workflow task when received."
        },
        "externalWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "When signal origin is a workflow execution, this field is set."
        }
      }
    },
    "v1WorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "parentWorkflowNamespace": {
          "type": "string",
          "description": "If this workflow is a child, the namespace our parent lives in.\nSDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only."
        },
        "parentWorkflowNamespaceId": {
          "type": "string"
        },
        "parentWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about parent workflow execution that initiated the child workflow these attributes belong to.\nIf the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated."
        },
        "parentInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "EventID of the child execution initiated event in parent workflow"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "SDK will deserialize this and provide it as arguments to the workflow function"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "continuedExecutionRunId": {
          "type": "string",
          "description": "Run id of the previous workflow which continued-as-new or retired or cron executed into this\nworkflow."
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "originalExecutionRunId": {
          "type": "string",
          "description": "This is the run id when the WorkflowExecutionStarted event was written.\nA workflow reset changes the execution run_id, but preserves this field."
        },
        "identity": {
          "type": "string",
          "title": "Identity of the client who requested this execution"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.\nUsed to identify a chain."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times we have tried to execute this workflow"
        },
        "workflowExecutionExpirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The absolute time at which the workflow will be timed out.\nThis is passed without change to the next run/retry of a workflow."
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this workflow runs on a cron schedule, it will appear here"
        },
        "firstWorkflowTaskBackoff": {
          "type": "string",
          "description": "For a cron workflow, this contains the amount of time between when this iteration of\nthe cron workflow was scheduled and when it should run next per its cron_schedule."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "prevAutoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "parentInitiatedEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "Version of the child execution initiated event in parent workflow\nIt should be used together with parent_initiated_event_id to identify\na child initiated event for global namespace"
        },
        "workflowId": {
          "type": "string",
          "description": "This field is new in 1.21."
        },
        "sourceVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "If this workflow intends to use anything other than the current overall default version for\nthe queue, then we include it here.\nDeprecated. use `inherited_build_id` instead"
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Completion callbacks attached when this workflow was started."
        },
        "rootWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about the root workflow execution.\nThe root workflow execution is defined as follows:\n1. A workflow without parent workflow is its own root workflow.\n2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\nNote: workflows continued as new or reseted may or may not have parents, check examples below.\n\nExamples:\n  Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 3: Workflow W1 continued as new W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n  Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n    - The root workflow of all three workflows is W1.\n  Scenario 5: Workflow W1 is reseted, creating W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2."
        },
        "inheritedBuildId": {
          "type": "string",
          "description": "When present, this execution is assigned to the build ID of its parent or previous execution."
        }
      },
      "title": "Always the first event in workflow history"
    },
    "v1WorkflowExecutionStatus": {
      "type": "string",
      "enum": [
        "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
        "WORKFLOW_EXECUTION_STATUS_RUNNING",
        "WORKFLOW_EXECUTION_STATUS_COMPLETED",
        "WORKFLOW_EXECUTION_STATUS_FAILED",
        "WORKFLOW_EXECUTION_STATUS_CANCELED",
        "WORKFLOW_EXECUTION_STATUS_TERMINATED",
        "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
        "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
      ],
      "default": "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
      "description": " - WORKFLOW_EXECUTION_STATUS_RUNNING: Value 1 is hardcoded in SQL persistence."
    },
    "v1WorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "title": "User/client provided reason for termination"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "identity": {
          "type": "string",
          "title": "id of the client who requested termination"
        }
      }
    },
    "v1WorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionUpdateAcceptedEventAttributes": {
      "type": "object",
      "properties": {
        "protocolInstanceId": {
          "type": "string",
          "description": "The instance ID of the update protocol that generated this event."
        },
        "acceptedRequestMessageId": {
          "type": "string",
          "description": "The message ID of the original request message that initiated this\nupdate. Needed so that the worker can recreate and deliver that same\nmessage as part of replay."
        },
        "acceptedRequestSequencingEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID used to sequence the original request message."
        },
        "acceptedRequest": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The message payload of the original request message that initiated this\nupdate."
        }
      }
    },
    "v1WorkflowExecutionUpdateAdmittedEventAttributes": {
      "type": "object",
      "properties": {
        "request": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The update request associated with this event."
        },
        "origin": {
          "$ref": "#/definitions/v1UpdateAdmittedEventOrigin",
          "description": "An explanation of why this event was written to history."
        }
      }
    },
    "v1WorkflowExecutionUpdateCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "meta": {
          "$ref": "#/definitions/v1Meta",
          "description": "The metadata about this update."
        },
        "acceptedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID indicating the acceptance of this update."
        },
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of executing the workflow update function."
        }
      }
    },
    "v1WorkflowExecutionUpdateRejectedEventAttributes": {
      "type": "object",
      "properties": {
        "protocolInstanceId": {
          "type": "string",
          "description": "The instance ID of the update protocol that generated this event."
        },
        "rejectedRequestMessageId": {
          "type": "string",
          "description": "The message ID of the original request message that initiated this\nupdate. Needed so that the worker can recreate and deliver that same\nmessage as part of replay."
        },
        "rejectedRequestSequencingEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID used to sequence the original request message."
        },
        "rejectedRequest": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The message payload of the original request message that initiated this\nupdate."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The cause of rejection."
        }
      }
    },
    "v1WorkflowIdConflictPolicy": {
      "type": "string",
      "enum": [
        "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
        "WORKFLOW_ID_CONFLICT_POLICY_FAIL",
        "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING",
        "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING"
      ],
      "default": "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
      "description": "Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.\nNote that it is *never* valid to have two actively running instances of the same workflow id.\n\nSee `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.\n\n - WORKFLOW_ID_CONFLICT_POLICY_FAIL: Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.\n - WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING: Don't start a new workflow; instead return a workflow handle for the running workflow.\n - WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING: Terminate the running workflow before starting a new one."
    },
    "v1WorkflowIdReusePolicy": {
      "type": "string",
      "enum": [
        "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
        "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
      ],
      "default": "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
      "description": "Defines whether to allow re-using a workflow id from a previously *closed* workflow.\nIf the request is denied, a `WorkflowExecutionAlreadyStartedFailure` is returned.\n\nSee `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.\n\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: Allow starting a workflow execution using the same workflow id.\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: Allow starting a workflow execution using the same workflow id, only when the last\nexecution's final state is one of [terminated, cancelled, timed out, failed].\n - WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: Do not permit re-use of the workflow id for this workflow. Future start workflow requests\ncould potentially change the policy, allowing re-use of the workflow id.\n - WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.\nIf specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on\nthe request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.\nIf no running workflow, then the behavior is the same as ALLOW_DUPLICATE."
    },
    "v1WorkflowPropertiesModifiedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1WorkflowPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "newTaskQueue": {
          "type": "string",
          "description": "If set to a nonempty string, future workflow tasks for this workflow shall be dispatched on\nthe provided queue."
        },
        "newWorkflowTaskTimeout": {
          "type": "string",
          "description": "If set, update the workflow task timeout to this value."
        },
        "newWorkflowRunTimeout": {
          "type": "string",
          "description": "If set, update the workflow run timeout to this value. May be set to 0 for no timeout."
        },
        "newWorkflowExecutionTimeout": {
          "type": "string",
          "description": "If set, update the workflow execution timeout to this value. May be set to 0 for no timeout."
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1WorkflowQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "type": "string",
          "description": "The workflow-author-defined identifier of the query. Typically a function name."
        },
        "queryArgs": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments that will be provided to the query handler."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the caller of the query and copied by temporal \nserver into the workflow task."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/queries/"
    },
    "v1WorkflowQueryResult": {
      "type": "object",
      "properties": {
        "resultType": {
          "$ref": "#/definitions/v1QueryResultType",
          "title": "Did the query succeed or fail?"
        },
        "answer": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Set when the query succeeds with the results"
        },
        "errorMessage": {
          "type": "string",
          "description": "Mutually exclusive with `answer`. Set when the query fails."
        }
      },
      "title": "Answer to a `WorkflowQuery`"
    },
    "v1WorkflowTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who completed this task"
        },
        "binaryChecksum": {
          "type": "string",
          "title": "Binary ID of the worker who completed this task"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task. If present, the `build_id` field\nwithin is also used as `binary_checksum`, which may be omitted in that case (it may also be\npopulated to preserve compatibility).\nDeprecated. Use the info inside the corresponding WorkflowTaskStartedEvent"
        },
        "sdkMetadata": {
          "$ref": "#/definitions/v1WorkflowTaskCompletedMetadata",
          "description": "Data the SDK wishes to record for itself, but server need not interpret, and does not\ndirectly impact workflow state."
        },
        "meteringMetadata": {
          "$ref": "#/definitions/v1MeteringMetadata",
          "title": "Local usage data sent during workflow task completion and recorded here for posterity"
        }
      }
    },
    "v1WorkflowTaskCompletedMetadata": {
      "type": "object",
      "properties": {
        "coreUsedFlags": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "During replay:\n* If a flag is not recognized (value is too high or not defined), it must fail the workflow\n  task.\n* If a flag is recognized, it is stored in a set of used flags for the run. Code checks for\n  that flag during and after this WFT are allowed to assume that the flag is present.\n* If a code check for a flag does not find the flag in the set of used flags, it must take\n  the branch corresponding to the absence of that flag.\n\nDuring non-replay execution of new WFTs:\n* The SDK is free to use all flags it knows about. It must record any newly-used (IE: not\n  previously recorded) flags when completing the WFT.\n\nSDKs which are too old to even know about this field at all are considered to produce\nundefined behavior if they replay workflows which used this mechanism.",
          "title": "Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:"
        },
        "langUsedFlags": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages\nhere as processing a workflow with a different language than the one which authored it is\nalready undefined behavior. See `core_used_patches` for more.\n"
        },
        "sdkName": {
          "type": "string",
          "description": "Name of the SDK that processed the task. This is usually something like \"temporal-go\" and is\nusually the same as client-name gRPC header. This should only be set if its value changed\nsince the last time recorded on the workflow (or be set on the first task).\n"
        },
        "sdkVersion": {
          "type": "string",
          "description": "Version of the SDK that processed the task. This is usually something like \"1.20.0\" and is\nusually the same as client-version gRPC header. This should only be set if its value changed\nsince the last time recorded on the workflow (or be set on the first task)."
        }
      }
    },
    "v1WorkflowTaskFailedCause": {
      "type": "string",
      "enum": [
        "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
        "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE",
        "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY",
        "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE",
        "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED"
      ],
      "default": "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
      "description": "Workflow tasks can fail for various reasons. Note that some of these reasons can only originate\nfrom the server, and some of them can only originate from the SDK/worker.\n\n - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND: Between starting and completing the workflow task (with a workflow completion command), some\nnew command (like a signal) was processed into workflow history. The outstanding task will be\nfailed with this reason, and a worker must pick up a new task.\n - WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE: The worker wishes to fail the task and have the next one be generated on a normal, not sticky\nqueue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.\n - WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR: The worker encountered a mismatch while replaying history between what was expected, and\nwhat the workflow code actually did.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED: We send the below error codes to users when their requests would violate a size constraint\nof their workflow. We do this to ensure that the state of their workflow does not become too\nlarge because that can cause severe performance degradation. You can modify the thresholds for\neach of these errors within your dynamic config.\n\nSpawning a new child workflow would cause this workflow to exceed its limit of pending child\nworkflows.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED: Starting a new activity would cause this workflow to exceed its limit of pending activities\nthat we track.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED: A workflow has a buffer of signals that have not yet reached their destination. We return this\nerror when sending a new signal would exceed the capacity of this buffer.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED: Similarly, we have a buffer of pending requests to cancel other workflows. We return this error\nwhen our capacity for pending cancel requests is already reached.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE: Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)\nhas wrong format, or missing required fields.\n - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE: Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid ScheduleNexusOperation command.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED: A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid RequestCancelNexusOperation command.\n - WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED: A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -\nfor the workflow's namespace).\nCheck the workflow task failure message for more information."
    },
    "v1WorkflowTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "cause": {
          "$ref": "#/definitions/v1WorkflowTaskFailedCause"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "The failure details"
        },
        "identity": {
          "type": "string",
          "title": "If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?"
        },
        "baseRunId": {
          "type": "string",
          "description": "The original run id of the workflow. For reset workflow."
        },
        "newRunId": {
          "type": "string",
          "description": "If the workflow is being reset, the new run id."
        },
        "forkEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "TODO: ?"
        },
        "binaryChecksum": {
          "type": "string",
          "title": "DEPRECATED since 1.21 - use `worker_version` instead.\nIf a worker explicitly failed this task, its binary id"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task. If present, the `build_id` field\nwithin is also used as `binary_checksum`, which may be omitted in that case (it may also be\npopulated to preserve compatibility).\nDeprecated. Use the info inside the corresponding WorkflowTaskStartedEvent"
        }
      }
    },
    "v1WorkflowTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "title": "The task queue this workflow task was enqueued in, which could be a normal or sticky queue"
        },
        "startToCloseTimeout": {
          "type": "string",
          "title": "How long the worker has to process this task once receiving it before it times out"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, how many attempts there have been to complete this task"
        }
      }
    },
    "v1WorkflowTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO: ? Appears unused?"
        },
        "suggestContinueAsNew": {
          "type": "boolean",
          "description": "True if this workflow should continue-as-new soon because its history size (in\neither event count or bytes) is getting large."
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64",
          "description": "Total history size in bytes, which the workflow might use to decide when to\ncontinue-as-new regardless of the suggestion. Note that history event count is\njust the event id of this event, so we don't include it explicitly here."
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker to whom this task was dispatched."
        },
        "buildIdRedirectCounter": {
          "type": "string",
          "format": "int64",
          "description": "Used by server internally to properly reapply build ID redirects to an execution\nwhen rebuilding it from events."
        }
      }
    },
    "v1WorkflowTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        }
      }
    },
    "v1WorkflowType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a workflow author to define the workflow. Typically, the\nname of a function. This is sometimes referred to as the workflow's \"name\""
    },
    "v1WorkflowTypeFilter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      }
    }
  }
}
