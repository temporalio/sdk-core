{
  "swagger": "2.0",
  "info": {
    "title": "temporal/api/workflowservice/v1/request_response.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "WorkflowService"
    },
    {
      "name": "OperatorService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/cluster-info": {
      "get": {
        "summary": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetClusterInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces": {
      "get": {
        "summary": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "RegisterNamespace creates a new namespace which can be used as a container for all resources.",
        "description": "A Namespace is a top level entity within Temporal, and is used as a container for resources\nlike workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\nisolation for all resources within the namespace. All resources belongs to exactly one\nnamespace.",
        "operationId": "RegisterNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceRequest"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}": {
      "get": {
        "summary": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCanceledById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete": {
      "post": {
        "summary": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\ntask.",
        "description": "This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCompletedById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\na new workflow task created for the workflow. Fails with `NotFound` if the task token is no\nlonger valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskFailedById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "summary": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.",
        "description": "If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\nthen it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\nthe workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\nsuch situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RecordActivityTaskHeartbeatById2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/pause": {
      "post": {
        "summary": "PauseActivity pauses the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be paused",
        "description": "Pausing an activity means:\n- If the activity is currently waiting for a retry or is running and subsequently fails,\n  it will not be rescheduled until it is unpaused.\n- If the activity is already paused, calling this method will have no effect.\n- If the activity is running and finishes successfully, the activity will be completed.\n- If the activity is running and finishes with failure:\n  * if there is no retry left - the activity will be completed.\n  * if there are more retries left - the activity will be paused.\nFor long-running activities:\n- activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n- The activity should respond to the cancellation accordingly.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "PauseActivity2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PauseActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePauseActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/reset": {
      "post": {
        "summary": "ResetActivity resets the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be reset.",
        "description": "Resetting an activity means:\n* number of attempts will be reset to 0.\n* activity timeouts will be reset.\n* if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:\n   it will be scheduled immediately (* see 'jitter' flag),\n\nFlags:\n\n'jitter': the activity will be scheduled at a random time within the jitter duration.\nIf the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.\n'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.\n'keep_paused': if the activity is paused, it will remain paused.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type.",
        "operationId": "ResetActivity2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/unpause": {
      "post": {
        "summary": "UnpauseActivity unpauses the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be unpaused.",
        "description": "If activity is not paused, this call will have no effect.\nIf the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).\nOnce the activity is unpaused, all timeout timers will be regenerated.\n\nFlags:\n'jitter': the activity will be scheduled at a random time within the jitter duration.\n'reset_attempts': the number of attempts will be reset.\n'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "UnpauseActivity2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UnpauseActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUnpauseActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/activities/update-options": {
      "post": {
        "summary": "UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be updated.",
        "operationId": "UpdateActivityOptions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateActivityOptionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateActivityOptionsBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/archived-workflows": {
      "get": {
        "summary": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListArchivedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations": {
      "get": {
        "summary": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListBatchOperationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "description": "List page size",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Next page token",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "summary": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Job ID defines the unique ID for the batch job",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "summary": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StopBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStopBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/current-deployment/{deployment.seriesName}": {
      "post": {
        "summary": "Sets a deployment as the current deployment for its deployment series. Can optionally update\nthe metadata of the deployment as well.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.",
        "operationId": "SetCurrentDeployment2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetCurrentDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetCurrentDeploymentBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/current-deployment/{seriesName}": {
      "get": {
        "summary": "Returns the current deployment (and its info) for a given deployment series.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.",
        "operationId": "GetCurrentDeployment2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetCurrentDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "seriesName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/deployments": {
      "get": {
        "summary": "Lists worker deployments in the namespace. Optionally can filter based on deployment series\nname.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `ListWorkerDeployments`.",
        "operationId": "ListDeployments2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListDeploymentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "seriesName",
            "description": "Optional. Use to filter based on exact series name match.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}": {
      "get": {
        "summary": "Describes a worker deployment.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `DescribeWorkerDeploymentVersion`.",
        "operationId": "DescribeDeployment2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.buildId",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}/reachability": {
      "get": {
        "summary": "Returns the reachability level of a worker deployment to help users decide when it is time\nto decommission a deployment. Reachability level is calculated based on the deployment's\n`status` and existing workflows that depend on the given deployment for their execution.\nCalculating reachability is relatively expensive. Therefore, server might return a recently\ncached value. In such a case, the `last_update_time` will inform you about the actual\nreachability calculation time.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.",
        "operationId": "GetDeploymentReachability2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetDeploymentReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.buildId",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules": {
      "get": {
        "summary": "List all schedules in a namespace.",
        "operationId": "ListSchedules2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSchedulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list schedules in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "description": "How many to return at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Token to get the next page of results.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "Query to filter schedules.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "summary": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Creates a new schedule.",
        "operationId": "CreateSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace the schedule should be created in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the new schedule.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "summary": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListScheduleMatchingTimesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "startTime",
            "description": "Time range to query.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "endTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "summary": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PatchScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePatchScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "summary": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/search-attributes": {
      "get": {
        "summary": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSearchAttributesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue.name}": {
      "get": {
        "summary": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n  - List of pollers\n  - Workflow Reachability status\n  - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeTaskQueueResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.kind",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.\n\n - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history\n\nThe task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "default": "TASK_QUEUE_KIND_UNSPECIFIED"
          },
          {
            "name": "taskQueue.normalName",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "taskQueueType",
            "description": "If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.\nOnly supported in default mode (use `task_queue_types` in ENHANCED mode instead).\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "default": "TASK_QUEUE_TYPE_UNSPECIFIED"
          },
          {
            "name": "reportStats",
            "description": "Report stats for the requested task queue type(s).",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportConfig",
            "description": "Report Task Queue Config",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "includeTaskQueueStatus",
            "description": "Deprecated, use `report_stats` instead.\nIf true, the task queue status will be included in the response.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "apiMode",
            "description": "Deprecated. ENHANCED mode is also being deprecated.\nSelect the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.\nConsult the documentation for each field to understand which mode it is supported in.\n\n - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
              "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
            ],
            "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED"
          },
          {
            "name": "versions.buildIds",
            "description": "Include specific Build IDs.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "versions.unversioned",
            "description": "Include the unversioned queue.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "versions.allActive",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "taskQueueTypes",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nTask queue types to report info about. If not specified, all types are considered.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reportPollers",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nReport list of pollers for requested task queue types and versions.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportTaskReachability",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nReport task reachability for the requested versions and all task types (task reachability is not reported\nper task type).",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/update-config": {
      "post": {
        "summary": "Updates task queue configuration.\nFor the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,\nwhich uncouples the rate limit from the worker lifecycle.\nIf the overall queue rate limit is unset, the worker-set rate limit takes effect.",
        "operationId": "UpdateTaskQueueConfig2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateTaskQueueConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Selects the task queue to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateTaskQueueConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "summary": "Deprecated. Use `GetWorkerVersioningRules`.\nFetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerBuildIdCompatibilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maxSets",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\ndefault major version set. 0 returns all sets.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "summary": "Fetches the Build ID assignment and redirect rules for a Task Queue.\nWARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerVersioningRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/update": {
      "post": {
        "summary": "UpdateNamespace is used to update the information and configuration of a registered\nnamespace.",
        "operationId": "UpdateNamespace2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateNamespaceBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}": {
      "get": {
        "summary": "Describes a worker deployment version.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeploymentVersion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkerDeploymentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Deprecated. Use `deployment_version`.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "reportTaskQueueStats",
            "description": "Report stats for task queues which have been polled by this version.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Used for manual deletion of Versions. User can delete a Version only when all the\nfollowing conditions are met:\n - It is not the Current or Ramping Version of its Deployment.\n - It has no active pollers (none of the task queues in the Version have pollers)\n - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition\n   can be skipped by passing `skip-drainage=true`.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeploymentVersion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkerDeploymentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Deprecated. Use `deployment_version`.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "skipDrainage",
            "description": "Pass to force deletion even if the Version is draining. In this case the open pinned\nworkflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "identity",
            "description": "Optional. The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}/update-metadata": {
      "post": {
        "summary": "Updates the user-given metadata attached to a Worker Deployment Version.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "UpdateWorkerDeploymentVersionMetadata2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkerDeploymentVersionMetadataResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments": {
      "get": {
        "summary": "Lists all Worker Deployments that are tracked in the Namespace.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "ListWorkerDeployments2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkerDeploymentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}": {
      "get": {
        "summary": "Describes a Worker Deployment.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeployment2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkerDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes records of (an old) Deployment. A deployment can only be deleted if\nit has no Version in it.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeployment2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkerDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "Optional. The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version": {
      "post": {
        "summary": "Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping\nVersion if it is the Version being set as Current.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentCurrentVersion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetWorkerDeploymentCurrentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetWorkerDeploymentCurrentVersionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version": {
      "post": {
        "summary": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for\ngradual ramp to unversioned workers too.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentRampingVersion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetWorkerDeploymentRampingVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetWorkerDeploymentRampingVersionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "summary": "Deprecated. Use `DescribeTaskQueue`.",
        "description": "Fetches task reachability to determine whether a worker may be retired.\nThe request may specify task queues to query for or let the server fetch all task queues mapped to the given\nbuild IDs.\n\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerTaskReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "buildIds",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\nThe number of build ids that can be queried in a single API call is limited.\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "taskQueues",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\nbuild ids in the namespace.\nMust specify at least one task queue if querying for an unversioned worker.\nThe number of task queues that the server will fetch reachability information for is limited.\nSee the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reachability",
            "description": "Type of reachability to query for.\n`TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\nUse `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\nOtherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\nunspecified.\nSee the TaskReachability docstring for information about each enum variant.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_REACHABILITY_UNSPECIFIED",
              "TASK_REACHABILITY_NEW_WORKFLOWS",
              "TASK_REACHABILITY_EXISTING_WORKFLOWS",
              "TASK_REACHABILITY_OPEN_WORKFLOWS",
              "TASK_REACHABILITY_CLOSED_WORKFLOWS"
            ],
            "default": "TASK_REACHABILITY_UNSPECIFIED"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workers": {
      "get": {
        "summary": "ListWorkers is a visibility API to list worker status information in a specific namespace.",
        "operationId": "ListWorkers2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "`query` in ListWorkers is used to filter workers based on worker status info.\nThe following worker status attributes are expected are supported as part of the query:\n* WorkerInstanceKey\n* WorkerIdentity\n* HostName\n* TaskQueue\n* DeploymentName\n* BuildId\n* SdkName\n* SdkVersion\n* StartTime\n* LastHeartbeatTime\n* Status\nCurrently metrics are not supported as a part of ListWorkers query.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workers/fetch-config": {
      "post": {
        "summary": "FetchWorkerConfig returns the worker configuration for a specific worker.",
        "operationId": "FetchWorkerConfig2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1FetchWorkerConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceFetchWorkerConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workers/heartbeat": {
      "post": {
        "summary": "WorkerHeartbeat receive heartbeat request from the worker.",
        "operationId": "RecordWorkerHeartbeat2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordWorkerHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordWorkerHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workers/update-config": {
      "post": {
        "summary": "UpdateWorkerConfig updates the worker configuration of one or more workers.\nCan be used to partially update the worker configuration.\nCan be used to update the configuration of multiple workers.",
        "operationId": "UpdateWorkerConfig2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkerConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkerConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-count": {
      "get": {
        "summary": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-rules": {
      "get": {
        "summary": "Return all namespace workflow rules",
        "operationId": "ListWorkflowRules2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Create a new workflow rule. The rules are used to control the workflow execution.\nThe rule will be applied to all running and new workflows in the namespace.\nIf the rule with such ID already exist this call will fail\nNote: the rules are part of namespace configuration and will be stored in the namespace config.\nNamespace config is eventually consistent.",
        "operationId": "CreateWorkflowRule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateWorkflowRuleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflow-rules/{ruleId}": {
      "get": {
        "summary": "DescribeWorkflowRule return the rule specification for existing rule id.\nIf there is no rule with such id - NOT FOUND error will be returned.",
        "operationId": "DescribeWorkflowRule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "ruleId",
            "description": "User-specified ID of the rule to read. Unique within the namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Delete rule by rule id",
        "operationId": "DeleteWorkflowRule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "ruleId",
            "description": "ID of the rule to delete. Unique within the namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows": {
      "get": {
        "summary": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "summary": "ExecuteMultiOperation executes multiple operations within a single workflow.",
        "description": "Operations are started atomically, meaning if *any* operation fails to be started, none are,\nand the request fails. Upon start, the API returns only when *all* operations have a response.\n\nUpon failure, it returns `MultiOperationExecutionFailure` where the status code\nequals the status code of the *first* operation that failed to be started.\n\nNOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ExecuteMultiOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceExecuteMultiOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}": {
      "get": {
        "summary": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history": {
      "get": {
        "summary": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n`NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\nthese, it should be passed here to fetch the next page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "waitNewEvent",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\nthe `history_event_filter_type`, or a timeout is hit.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "historyEventFilterType",
            "description": "Filter returned events such that they match the specified filter type.\nDefault: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
              "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
              "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
            ],
            "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
          },
          {
            "name": "skipArchival",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse": {
      "get": {
        "summary": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \norder (starting from last event). Fails with`NotFound` if the specified workflow execution is \nunknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryReverseResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}": {
      "post": {
        "summary": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1QueryWorkflowResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query.queryType",
            "description": "The workflow-author-defined identifier of the query. Typically a function name.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceQueryWorkflowBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{execution.workflowId}/trigger-rule": {
      "post": {
        "summary": "TriggerWorkflowRule allows to:\n * trigger existing rule for a specific workflow execution;\n * trigger rule for a specific workflow execution without creating a rule;\nThis is useful for one-off operations.",
        "operationId": "TriggerWorkflowRule2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TriggerWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTriggerWorkflowRuleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel": {
      "post": {
        "summary": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\na workflow execution.",
        "description": "This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\nworkflow history and a new workflow task created for the workflow. It returns success if the requested\nworkflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RequestCancelWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRequestCancelWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset": {
      "post": {
        "summary": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n`WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\nexecution instance.\nTODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}": {
      "post": {
        "summary": "SignalWorkflowExecution is used to send a signal to a running workflow execution.",
        "description": "This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\ntask being created for the execution.",
        "operationId": "SignalWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate": {
      "post": {
        "summary": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n`WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\nexecution instance.",
        "operationId": "TerminateWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TerminateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTerminateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update-options": {
      "post": {
        "summary": "UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.",
        "operationId": "UpdateWorkflowExecutionOptions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionOptionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionOptionsBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}": {
      "post": {
        "summary": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "request.input.name",
            "description": "The name of the Update handler to invoke on the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "summary": "StartWorkflowExecution starts a new workflow execution.",
        "description": "It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\nalso schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\ninstance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "summary": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\nit isn't yet started.",
        "description": "If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\nand a workflow task is generated.\n\nIf the workflow is not running or not found, then the workflow is created with\n`WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\nworkflow task is generated.",
        "operationId": "SignalWithStartWorkflowExecution2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWithStartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWithStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/api/v1/nexus/endpoints": {
      "get": {
        "summary": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\nnext_page_token field of the previous response to get the next page of results. An empty next_page_token\nindicates that there are no more results. During pagination, a newly added service with an ID lexicographically\nearlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNexusEndpointsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\nresponse, the token will be empty if there's no other page.\nNote: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "name",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "post": {
        "summary": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\nALREADY_EXISTS.\nReturns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointRequest"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/nexus/endpoints/{id}": {
      "get": {
        "summary": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "delete": {
        "summary": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Data version for this endpoint. Must match current version.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/nexus/endpoints/{id}/update": {
      "post": {
        "summary": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n`ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\nmatch.\nReturns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\nneed to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/OperatorServiceUpdateNexusEndpointBody"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/api/v1/system-info": {
      "get": {
        "summary": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetSystemInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster": {
      "get": {
        "summary": "GetClusterInfo returns information about temporal cluster",
        "operationId": "GetClusterInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetClusterInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces": {
      "get": {
        "summary": "ListNamespaces returns the information and configuration for all namespaces.",
        "operationId": "ListNamespaces",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNamespacesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "namespaceFilter.includeDeleted",
            "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "RegisterNamespace creates a new namespace which can be used as a container for all resources.",
        "description": "A Namespace is a top level entity within Temporal, and is used as a container for resources\nlike workflow executions, task queues, etc. A Namespace acts as a sandbox and provides\nisolation for all resources within the namespace. All resources belongs to exactly one\nnamespace.",
        "operationId": "RegisterNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1RegisterNamespaceRequest"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}": {
      "get": {
        "summary": "DescribeNamespace returns the information and configuration for a registered namespace.",
        "operationId": "DescribeNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "id",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}/search-attributes": {
      "get": {
        "summary": "ListSearchAttributes returns comprehensive information about search attributes.",
        "operationId": "ListSearchAttributes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSearchAttributesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/namespaces/{namespace}/update": {
      "post": {
        "summary": "UpdateNamespace is used to update the information and configuration of a registered\nnamespace.",
        "operationId": "UpdateNamespace",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNamespaceResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateNamespaceBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/cluster/nexus/endpoints": {
      "get": {
        "summary": "List all Nexus endpoints for the cluster, sorted by ID in ascending order. Set page_token in the request to the\nnext_page_token field of the previous response to get the next page of results. An empty next_page_token\nindicates that there are no more results. During pagination, a newly added service with an ID lexicographically\nearlier than the previous page's last endpoint's ID may be missed.",
        "operationId": "ListNexusEndpoints",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListNexusEndpointsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's\nresponse, the token will be empty if there's no other page.\nNote: the last page may be empty if the total number of endpoints registered is a multiple of the page size.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "name",
            "description": "Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "post": {
        "summary": "Create a Nexus endpoint. This will fail if an endpoint with the same name is already registered with a status of\nALREADY_EXISTS.\nReturns the created endpoint with its initial version. You may use this version for subsequent updates.",
        "operationId": "CreateNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/v1CreateNexusEndpointRequest"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/nexus/endpoints/{id}": {
      "get": {
        "summary": "Get a registered Nexus endpoint by ID. The returned version can be used for optimistic updates.",
        "operationId": "GetNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      },
      "delete": {
        "summary": "Delete an incoming Nexus service by ID.",
        "operationId": "DeleteNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Data version for this endpoint. Must match current version.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "int64"
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/cluster/nexus/endpoints/{id}/update": {
      "post": {
        "summary": "Optimistically update a Nexus endpoint based on provided version as obtained via the `GetNexusEndpoint` or\n`ListNexusEndpointResponse` APIs. This will fail with a status of FAILED_PRECONDITION if the version does not\nmatch.\nReturns the updated endpoint with its updated version. You may use this version for subsequent updates. You don't\nneed to increment the version yourself. The server will increment the version for you after each update.",
        "operationId": "UpdateNexusEndpoint",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateNexusEndpointResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "id",
            "description": "Server-generated unique endpoint ID.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/OperatorServiceUpdateNexusEndpointBody"
            }
          }
        ],
        "tags": [
          "OperatorService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/cancel": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCanceled",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/cancel-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCanceled`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCanceledById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCanceledByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCanceledByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/complete": {
      "post": {
        "summary": "RespondActivityTaskCompleted is called by workers when they successfully complete an activity\ntask.",
        "description": "This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history\nand a new workflow task created for the workflow. Fails with `NotFound` if the task token is\nno longer valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskCompleted",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/complete-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskCompleted`. This version allows clients to record completions by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskCompletedById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskCompletedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskCompletedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/fail": {
      "post": {
        "summary": "RespondActivityTaskFailed is called by workers when processing an activity task fails.",
        "description": "This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and\na new workflow task created for the workflow. Fails with `NotFound` if the task token is no\nlonger valid due to activity timeout, already being completed, or never having existed.",
        "operationId": "RespondActivityTaskFailed",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/fail-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskFailed`. This version allows clients to record failures by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RespondActivityTaskFailedById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RespondActivityTaskFailedByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRespondActivityTaskFailedByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/heartbeat": {
      "post": {
        "summary": "RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.",
        "description": "If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,\nthen it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to\nthe workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in\nsuch situations, in that event, the SDK should request cancellation of the activity.",
        "operationId": "RecordActivityTaskHeartbeat",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/heartbeat-by-id": {
      "post": {
        "summary": "See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by\nnamespace/workflow id/activity id instead of task token.",
        "operationId": "RecordActivityTaskHeartbeatById",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordActivityTaskHeartbeatByIdResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordActivityTaskHeartbeatByIdBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/pause": {
      "post": {
        "summary": "PauseActivity pauses the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be paused",
        "description": "Pausing an activity means:\n- If the activity is currently waiting for a retry or is running and subsequently fails,\n  it will not be rescheduled until it is unpaused.\n- If the activity is already paused, calling this method will have no effect.\n- If the activity is running and finishes successfully, the activity will be completed.\n- If the activity is running and finishes with failure:\n  * if there is no retry left - the activity will be completed.\n  * if there are more retries left - the activity will be paused.\nFor long-running activities:\n- activities in paused state will send a cancellation with \"activity_paused\" set to 'true' in response to 'RecordActivityTaskHeartbeat'.\n- The activity should respond to the cancellation accordingly.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "PauseActivity",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PauseActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePauseActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/reset": {
      "post": {
        "summary": "ResetActivity resets the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be reset.",
        "description": "Resetting an activity means:\n* number of attempts will be reset to 0.\n* activity timeouts will be reset.\n* if the activity is waiting for retry, and it is not paused or 'keep_paused' is not provided:\n   it will be scheduled immediately (* see 'jitter' flag),\n\nFlags:\n\n'jitter': the activity will be scheduled at a random time within the jitter duration.\nIf the activity currently paused it will be unpaused, unless 'keep_paused' flag is provided.\n'reset_heartbeats': the activity heartbeat timer and heartbeats will be reset.\n'keep_paused': if the activity is paused, it will remain paused.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type.",
        "operationId": "ResetActivity",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/unpause": {
      "post": {
        "summary": "UnpauseActivity unpauses the execution of an activity specified by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be unpaused.",
        "description": "If activity is not paused, this call will have no effect.\nIf the activity was paused while waiting for retry, it will be scheduled immediately (* see 'jitter' flag).\nOnce the activity is unpaused, all timeout timers will be regenerated.\n\nFlags:\n'jitter': the activity will be scheduled at a random time within the jitter duration.\n'reset_attempts': the number of attempts will be reset.\n'reset_heartbeat': the activity heartbeat timer and heartbeats will be reset.\n\nReturns a `NotFound` error if there is no pending activity with the provided ID or type",
        "operationId": "UnpauseActivity",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UnpauseActivityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUnpauseActivityBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/activities/update-options": {
      "post": {
        "summary": "UpdateActivityOptions is called by the client to update the options of an activity by its ID or type.\nIf there are multiple pending activities of the provided type - all of them will be updated.",
        "operationId": "UpdateActivityOptions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateActivityOptionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace of the workflow which scheduled this activity",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateActivityOptionsBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/archived-workflows": {
      "get": {
        "summary": "ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.",
        "operationId": "ListArchivedWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListArchivedWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations": {
      "get": {
        "summary": "ListBatchOperations returns a list of batch operations",
        "operationId": "ListBatchOperations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListBatchOperationsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "description": "List page size",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Next page token",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}": {
      "get": {
        "summary": "DescribeBatchOperation returns the information about a batch operation",
        "operationId": "DescribeBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "StartBatchOperation starts a new batch operation",
        "operationId": "StartBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Job ID defines the unique ID for the batch job",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/batch-operations/{jobId}/stop": {
      "post": {
        "summary": "StopBatchOperation stops a batch operation",
        "operationId": "StopBatchOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StopBatchOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace that contains the batch operation",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "jobId",
            "description": "Batch job id",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStopBatchOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/current-deployment/{deployment.seriesName}": {
      "post": {
        "summary": "Sets a deployment as the current deployment for its deployment series. Can optionally update\nthe metadata of the deployment as well.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced by `SetWorkerDeploymentCurrentVersion`.",
        "operationId": "SetCurrentDeployment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetCurrentDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetCurrentDeploymentBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/current-deployment/{seriesName}": {
      "get": {
        "summary": "Returns the current deployment (and its info) for a given deployment series.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced by `current_version` returned by `DescribeWorkerDeployment`.",
        "operationId": "GetCurrentDeployment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetCurrentDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "seriesName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/deployments": {
      "get": {
        "summary": "Lists worker deployments in the namespace. Optionally can filter based on deployment series\nname.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `ListWorkerDeployments`.",
        "operationId": "ListDeployments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListDeploymentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "seriesName",
            "description": "Optional. Use to filter based on exact series name match.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}": {
      "get": {
        "summary": "Describes a worker deployment.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `DescribeWorkerDeploymentVersion`.",
        "operationId": "DescribeDeployment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.buildId",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/deployments/{deployment.seriesName}/{deployment.buildId}/reachability": {
      "get": {
        "summary": "Returns the reachability level of a worker deployment to help users decide when it is time\nto decommission a deployment. Reachability level is calculated based on the deployment's\n`status` and existing workflows that depend on the given deployment for their execution.\nCalculating reachability is relatively expensive. Therefore, server might return a recently\ncached value. In such a case, the `last_update_time` will inform you about the actual\nreachability calculation time.\nExperimental. This API might significantly change or be removed in a future release.\nDeprecated. Replaced with `DrainageInfo` returned by `DescribeWorkerDeploymentVersion`.",
        "operationId": "GetDeploymentReachability",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetDeploymentReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.seriesName",
            "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deployment.buildId",
            "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules": {
      "get": {
        "summary": "List all schedules in a namespace.",
        "operationId": "ListSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListSchedulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace to list schedules in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "description": "How many to return at once.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "Token to get the next page of results.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "Query to filter schedules.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}": {
      "get": {
        "summary": "Returns the schedule description and current state of an existing schedule.",
        "operationId": "DescribeSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to describe.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes a schedule, removing it from the system.",
        "operationId": "DeleteSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to delete.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Creates a new schedule.",
        "operationId": "CreateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace the schedule should be created in.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the new schedule.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/matching-times": {
      "get": {
        "summary": "Lists matching times within a range.",
        "operationId": "ListScheduleMatchingTimes",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListScheduleMatchingTimesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to query.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "startTime",
            "description": "Time range to query.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "endTime",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/patch": {
      "post": {
        "summary": "Makes a specific change to a schedule or triggers an immediate action.",
        "operationId": "PatchSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1PatchScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to patch.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServicePatchScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/schedules/{scheduleId}/update": {
      "post": {
        "summary": "Changes the configuration or state of an existing schedule.",
        "operationId": "UpdateSchedule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateScheduleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "scheduleId",
            "description": "The id of the schedule to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateScheduleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue.name}": {
      "get": {
        "summary": "DescribeTaskQueue returns the following information about the target task queue, broken down by Build ID:\n  - List of pollers\n  - Workflow Reachability status\n  - Backlog info for Workflow and/or Activity tasks",
        "operationId": "DescribeTaskQueue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeTaskQueueResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.name",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue.kind",
            "description": "Default: TASK_QUEUE_KIND_NORMAL.\n\n - TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history\n\nThe task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_KIND_UNSPECIFIED",
              "TASK_QUEUE_KIND_NORMAL",
              "TASK_QUEUE_KIND_STICKY"
            ],
            "default": "TASK_QUEUE_KIND_UNSPECIFIED"
          },
          {
            "name": "taskQueue.normalName",
            "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "taskQueueType",
            "description": "If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.\nOnly supported in default mode (use `task_queue_types` in ENHANCED mode instead).\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_QUEUE_TYPE_UNSPECIFIED",
              "TASK_QUEUE_TYPE_WORKFLOW",
              "TASK_QUEUE_TYPE_ACTIVITY",
              "TASK_QUEUE_TYPE_NEXUS"
            ],
            "default": "TASK_QUEUE_TYPE_UNSPECIFIED"
          },
          {
            "name": "reportStats",
            "description": "Report stats for the requested task queue type(s).",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportConfig",
            "description": "Report Task Queue Config",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "includeTaskQueueStatus",
            "description": "Deprecated, use `report_stats` instead.\nIf true, the task queue status will be included in the response.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "apiMode",
            "description": "Deprecated. ENHANCED mode is also being deprecated.\nSelect the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.\nConsult the documentation for each field to understand which mode it is supported in.\n\n - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
              "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
            ],
            "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED"
          },
          {
            "name": "versions.buildIds",
            "description": "Include specific Build IDs.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "versions.unversioned",
            "description": "Include the unversioned queue.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "versions.allActive",
            "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "taskQueueTypes",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nTask queue types to report info about. If not specified, all types are considered.\n\n - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string",
              "enum": [
                "TASK_QUEUE_TYPE_UNSPECIFIED",
                "TASK_QUEUE_TYPE_WORKFLOW",
                "TASK_QUEUE_TYPE_ACTIVITY",
                "TASK_QUEUE_TYPE_NEXUS"
              ]
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reportPollers",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nReport list of pollers for requested task queue types and versions.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "reportTaskReachability",
            "description": "Deprecated (as part of the ENHANCED mode deprecation).\nReport task reachability for the requested versions and all task types (task reachability is not reported\nper task type).",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/update-config": {
      "post": {
        "summary": "Updates task queue configuration.\nFor the overall queue rate limit: the rate limit set by this api overrides the worker-set rate limit,\nwhich uncouples the rate limit from the worker lifecycle.\nIf the overall queue rate limit is unset, the worker-set rate limit takes effect.",
        "operationId": "UpdateTaskQueueConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateTaskQueueConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Selects the task queue to update.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateTaskQueueConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-build-id-compatibility": {
      "get": {
        "summary": "Deprecated. Use `GetWorkerVersioningRules`.\nFetches the worker build id versioning sets for a task queue.",
        "operationId": "GetWorkerBuildIdCompatibility",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerBuildIdCompatibilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "description": "Must be set, the task queue to interrogate about worker id compatibility.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "maxSets",
            "description": "Limits how many compatible sets will be returned. Specify 1 to only return the current\ndefault major version set. 0 returns all sets.",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/task-queues/{taskQueue}/worker-versioning-rules": {
      "get": {
        "summary": "Fetches the Build ID assignment and redirect rules for a Task Queue.\nWARNING: Worker Versioning is not yet stable and the API and behavior may change incompatibly.",
        "operationId": "GetWorkerVersioningRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerVersioningRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "taskQueue",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}": {
      "get": {
        "summary": "Describes a worker deployment version.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeploymentVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkerDeploymentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Deprecated. Use `deployment_version`.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "reportTaskQueueStats",
            "description": "Report stats for task queues which have been polled by this version.",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Used for manual deletion of Versions. User can delete a Version only when all the\nfollowing conditions are met:\n - It is not the Current or Ramping Version of its Deployment.\n - It has no active pollers (none of the task queues in the Version have pollers)\n - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition\n   can be skipped by passing `skip-drainage=true`.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeploymentVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkerDeploymentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "version",
            "description": "Deprecated. Use `deployment_version`.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "skipDrainage",
            "description": "Pass to force deletion even if the Version is draining. In this case the open pinned\nworkflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "identity",
            "description": "Optional. The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployment-versions/{deploymentVersion.deploymentName}/{deploymentVersion.buildId}/update-metadata": {
      "post": {
        "summary": "Updates the user-given metadata attached to a Worker Deployment Version.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "UpdateWorkerDeploymentVersionMetadata",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkerDeploymentVersionMetadataResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.deploymentName",
            "description": "Identifies the Worker Deployment this Version is part of.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentVersion.buildId",
            "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployments": {
      "get": {
        "summary": "Lists all Worker Deployments that are tracked in the Namespace.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "ListWorkerDeployments",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkerDeploymentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}": {
      "get": {
        "summary": "Describes a Worker Deployment.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DescribeWorkerDeployment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkerDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Deletes records of (an old) Deployment. A deployment can only be deleted if\nit has no Version in it.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "DeleteWorkerDeployment",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkerDeploymentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "identity",
            "description": "Optional. The identity of the client who initiated this request.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}/set-current-version": {
      "post": {
        "summary": "Set/unset the Current Version of a Worker Deployment. Automatically unsets the Ramping\nVersion if it is the Version being set as Current.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentCurrentVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetWorkerDeploymentCurrentVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetWorkerDeploymentCurrentVersionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-deployments/{deploymentName}/set-ramping-version": {
      "post": {
        "summary": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage. Can be used for\ngradual ramp to unversioned workers too.\nExperimental. This API might significantly change or be removed in a future release.",
        "operationId": "SetWorkerDeploymentRampingVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SetWorkerDeploymentRampingVersionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "deploymentName",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSetWorkerDeploymentRampingVersionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/worker-task-reachability": {
      "get": {
        "summary": "Deprecated. Use `DescribeTaskQueue`.",
        "description": "Fetches task reachability to determine whether a worker may be retired.\nThe request may specify task queues to query for or let the server fetch all task queues mapped to the given\nbuild IDs.\n\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.",
        "operationId": "GetWorkerTaskReachability",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkerTaskReachabilityResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "buildIds",
            "description": "Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.\nThe number of build ids that can be queried in a single API call is limited.\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "taskQueues",
            "description": "Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given\nbuild ids in the namespace.\nMust specify at least one task queue if querying for an unversioned worker.\nThe number of task queues that the server will fetch reachability information for is limited.\nSee the `GetWorkerTaskReachabilityResponse` documentation for more information.",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "reachability",
            "description": "Type of reachability to query for.\n`TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.\nUse `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.\nOtherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left\nunspecified.\nSee the TaskReachability docstring for information about each enum variant.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "TASK_REACHABILITY_UNSPECIFIED",
              "TASK_REACHABILITY_NEW_WORKFLOWS",
              "TASK_REACHABILITY_EXISTING_WORKFLOWS",
              "TASK_REACHABILITY_OPEN_WORKFLOWS",
              "TASK_REACHABILITY_CLOSED_WORKFLOWS"
            ],
            "default": "TASK_REACHABILITY_UNSPECIFIED"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workers": {
      "get": {
        "summary": "ListWorkers is a visibility API to list worker status information in a specific namespace.",
        "operationId": "ListWorkers",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkersResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "description": "`query` in ListWorkers is used to filter workers based on worker status info.\nThe following worker status attributes are expected are supported as part of the query:\n* WorkerInstanceKey\n* WorkerIdentity\n* HostName\n* TaskQueue\n* DeploymentName\n* BuildId\n* SdkName\n* SdkVersion\n* StartTime\n* LastHeartbeatTime\n* Status\nCurrently metrics are not supported as a part of ListWorkers query.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workers/fetch-config": {
      "post": {
        "summary": "FetchWorkerConfig returns the worker configuration for a specific worker.",
        "operationId": "FetchWorkerConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1FetchWorkerConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceFetchWorkerConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workers/heartbeat": {
      "post": {
        "summary": "WorkerHeartbeat receive heartbeat request from the worker.",
        "operationId": "RecordWorkerHeartbeat",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RecordWorkerHeartbeatResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRecordWorkerHeartbeatBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workers/update-config": {
      "post": {
        "summary": "UpdateWorkerConfig updates the worker configuration of one or more workers.\nCan be used to partially update the worker configuration.\nCan be used to update the configuration of multiple workers.",
        "operationId": "UpdateWorkerConfig",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkerConfigResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "Namespace this worker belongs to.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkerConfigBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflow-count": {
      "get": {
        "summary": "CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.",
        "operationId": "CountWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CountWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflow-rules": {
      "get": {
        "summary": "Return all namespace workflow rules",
        "operationId": "ListWorkflowRules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowRulesResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "post": {
        "summary": "Create a new workflow rule. The rules are used to control the workflow execution.\nThe rule will be applied to all running and new workflows in the namespace.\nIf the rule with such ID already exist this call will fail\nNote: the rules are part of namespace configuration and will be stored in the namespace config.\nNamespace config is eventually consistent.",
        "operationId": "CreateWorkflowRule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1CreateWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceCreateWorkflowRuleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflow-rules/{ruleId}": {
      "get": {
        "summary": "DescribeWorkflowRule return the rule specification for existing rule id.\nIf there is no rule with such id - NOT FOUND error will be returned.",
        "operationId": "DescribeWorkflowRule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "ruleId",
            "description": "User-specified ID of the rule to read. Unique within the namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      },
      "delete": {
        "summary": "Delete rule by rule id",
        "operationId": "DeleteWorkflowRule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DeleteWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "ruleId",
            "description": "ID of the rule to delete. Unique within the namespace.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows": {
      "get": {
        "summary": "ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.",
        "operationId": "ListWorkflowExecutions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ListWorkflowExecutionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "pageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "query",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/execute-multi-operation": {
      "post": {
        "summary": "ExecuteMultiOperation executes multiple operations within a single workflow.",
        "description": "Operations are started atomically, meaning if *any* operation fails to be started, none are,\nand the request fails. Upon start, the API returns only when *all* operations have a response.\n\nUpon failure, it returns `MultiOperationExecutionFailure` where the status code\nequals the status code of the *first* operation that failed to be started.\n\nNOTE: Experimental API.",
        "operationId": "ExecuteMultiOperation",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ExecuteMultiOperationResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceExecuteMultiOperationBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}": {
      "get": {
        "summary": "DescribeWorkflowExecution returns information about the specified workflow execution.",
        "operationId": "DescribeWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1DescribeWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/history": {
      "get": {
        "summary": "GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with\n`NotFound` if the specified workflow execution is unknown to the service.",
        "operationId": "GetWorkflowExecutionHistory",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "description": "If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of\nthese, it should be passed here to fetch the next page.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "waitNewEvent",
            "description": "If set to true, the RPC call will not resolve until there is a new event which matches\nthe `history_event_filter_type`, or a timeout is hit.",
            "in": "query",
            "required": false,
            "type": "boolean"
          },
          {
            "name": "historyEventFilterType",
            "description": "Filter returned events such that they match the specified filter type.\nDefault: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.",
            "in": "query",
            "required": false,
            "type": "string",
            "enum": [
              "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
              "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
              "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
            ],
            "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
          },
          {
            "name": "skipArchival",
            "in": "query",
            "required": false,
            "type": "boolean"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/history-reverse": {
      "get": {
        "summary": "GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse \norder (starting from last event). Fails with`NotFound` if the specified workflow execution is \nunknown to the service.",
        "operationId": "GetWorkflowExecutionHistoryReverse",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetWorkflowExecutionHistoryReverseResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.runId",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "maximumPageSize",
            "in": "query",
            "required": false,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "nextPageToken",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "byte"
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/query/{query.queryType}": {
      "post": {
        "summary": "QueryWorkflow requests a query be executed for a specified workflow execution.",
        "operationId": "QueryWorkflow",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1QueryWorkflowResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "query.queryType",
            "description": "The workflow-author-defined identifier of the query. Typically a function name.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceQueryWorkflowBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{execution.workflowId}/trigger-rule": {
      "post": {
        "summary": "TriggerWorkflowRule allows to:\n * trigger existing rule for a specific workflow execution;\n * trigger rule for a specific workflow execution without creating a rule;\nThis is useful for one-off operations.",
        "operationId": "TriggerWorkflowRule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TriggerWorkflowRuleResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "execution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTriggerWorkflowRuleBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/cancel": {
      "post": {
        "summary": "RequestCancelWorkflowExecution is called by workers when they want to request cancellation of\na workflow execution.",
        "description": "This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the\nworkflow history and a new workflow task created for the workflow. It returns success if the requested\nworkflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.",
        "operationId": "RequestCancelWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1RequestCancelWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceRequestCancelWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/reset": {
      "post": {
        "summary": "ResetWorkflowExecution will reset an existing workflow execution to a specified\n`WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current\nexecution instance.\nTODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?",
        "operationId": "ResetWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1ResetWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceResetWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/signal/{signalName}": {
      "post": {
        "summary": "SignalWorkflowExecution is used to send a signal to a running workflow execution.",
        "description": "This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow\ntask being created for the execution.",
        "operationId": "SignalWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/terminate": {
      "post": {
        "summary": "TerminateWorkflowExecution terminates an existing workflow execution by recording a\n`WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the\nexecution instance.",
        "operationId": "TerminateWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1TerminateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceTerminateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update-options": {
      "post": {
        "summary": "UpdateWorkflowExecutionOptions partially updates the WorkflowExecutionOptions of an existing workflow execution.",
        "operationId": "UpdateWorkflowExecutionOptions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionOptionsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionOptionsBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowExecution.workflowId}/update/{request.input.name}": {
      "post": {
        "summary": "Invokes the specified Update function on user Workflow code.",
        "operationId": "UpdateWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "description": "The namespace name of the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowExecution.workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "request.input.name",
            "description": "The name of the Update handler to invoke on the target Workflow.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceUpdateWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}": {
      "post": {
        "summary": "StartWorkflowExecution starts a new workflow execution.",
        "description": "It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and\nalso schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an\ninstance already exists with same workflow id.",
        "operationId": "StartWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/namespaces/{namespace}/workflows/{workflowId}/signal-with-start/{signalName}": {
      "post": {
        "summary": "SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if\nit isn't yet started.",
        "description": "If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history\nand a workflow task is generated.\n\nIf the workflow is not running or not found, then the workflow is created with\n`WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a\nworkflow task is generated.",
        "operationId": "SignalWithStartWorkflowExecution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1SignalWithStartWorkflowExecutionResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "namespace",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "workflowId",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "signalName",
            "description": "The workflow author-defined name of the signal to send to the workflow",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/WorkflowServiceSignalWithStartWorkflowExecutionBody"
            }
          }
        ],
        "tags": [
          "WorkflowService"
        ]
      }
    },
    "/system-info": {
      "get": {
        "summary": "GetSystemInfo returns information about the system.",
        "operationId": "GetSystemInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/v1GetSystemInfoResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/rpcStatus"
            }
          }
        },
        "tags": [
          "WorkflowService"
        ]
      }
    }
  },
  "definitions": {
    "CallbackInfoTrigger": {
      "type": "object",
      "properties": {
        "workflowClosed": {
          "$ref": "#/definitions/CallbackInfoWorkflowClosed"
        }
      }
    },
    "CallbackInfoWorkflowClosed": {
      "type": "object",
      "description": "Trigger for when the workflow is closed."
    },
    "CallbackInternal": {
      "type": "object",
      "properties": {
        "data": {
          "type": "string",
          "format": "byte",
          "description": "Opaque internal data."
        }
      },
      "description": "Callbacks to be delivered internally within the system.\nThis variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.\nThe only reason that this is exposed is because callbacks are replicated across clusters via the\nWorkflowExecutionStarted event, which is defined in the public API."
    },
    "CallbackNexus": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "Callback URL."
        },
        "header": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to callback request."
        }
      }
    },
    "CountWorkflowExecutionsResponseAggregationGroup": {
      "type": "object",
      "properties": {
        "groupValues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Payload"
          }
        },
        "count": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "DeploymentInfoTaskQueueInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/v1TaskQueueType"
        },
        "firstPollerTime": {
          "type": "string",
          "format": "date-time",
          "description": "When server saw the first poller for this task queue in this deployment."
        }
      }
    },
    "DescribeTaskQueueResponseEffectiveRateLimit": {
      "type": "object",
      "properties": {
        "requestsPerSecond": {
          "type": "number",
          "format": "float",
          "description": "The effective rate limit for the task queue."
        },
        "rateLimitSource": {
          "$ref": "#/definitions/v1RateLimitSource",
          "title": "Source of the RateLimit Configuration,which can be one of the following values:\n- SOURCE_API: The rate limit that is set via the TaskQueueConfig api.\n- SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.\n- SOURCE_SYSTEM: The rate limit is the default value set by the system"
        }
      }
    },
    "DescribeWorkerDeploymentVersionResponseVersionTaskQueue": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/v1TaskQueueType"
        },
        "stats": {
          "$ref": "#/definitions/v1TaskQueueStats",
          "description": "Only set if `report_task_queue_stats` is set on the request."
        },
        "statsByPriorityKey": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueStats"
          },
          "description": "Task queue stats breakdown by priority key. Only contains actively used priority keys.\nOnly set if `report_task_queue_stats` is set to true in the request."
        }
      }
    },
    "EndpointTargetExternal": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "URL to call."
        }
      },
      "description": "Target an external server by URL.\nAt a later point, this will support providing credentials, in the meantime, an http.RoundTripper can be injected\ninto the server to modify the request."
    },
    "EndpointTargetWorker": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace to route requests to."
        },
        "taskQueue": {
          "type": "string",
          "description": "Nexus task queue to route requests to."
        }
      },
      "description": "Target a worker polling on a Nexus task queue in a specific namespace."
    },
    "ExecuteMultiOperationRequestOperation": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1StartWorkflowExecutionRequest",
          "title": "Additional restrictions:\n- setting `cron_schedule` is invalid\n- setting `request_eager_execution` is invalid\n- setting `workflow_start_delay` is invalid"
        },
        "updateWorkflow": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionRequest",
          "title": "Additional restrictions:\n- setting `first_execution_run_id` is invalid\n- setting `workflow_execution.run_id` is invalid"
        }
      }
    },
    "LinkBatchJob": {
      "type": "object",
      "properties": {
        "jobId": {
          "type": "string"
        }
      },
      "description": "A link to a built-in batch job.\nBatch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).\nThis link can be put on workflow history events generated by actions taken by a batch job."
    },
    "LinkWorkflowEvent": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "eventRef": {
          "$ref": "#/definitions/WorkflowEventEventReference"
        },
        "requestIdRef": {
          "$ref": "#/definitions/WorkflowEventRequestIdReference"
        }
      }
    },
    "ListWorkerDeploymentsResponseWorkerDeploymentSummary": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "routingConfig": {
          "$ref": "#/definitions/v1RoutingConfig"
        },
        "latestVersionSummary": {
          "$ref": "#/definitions/WorkerDeploymentInfoWorkerDeploymentVersionSummary",
          "description": "Summary of the version that was added most recently in the Worker Deployment."
        },
        "currentVersionSummary": {
          "$ref": "#/definitions/WorkerDeploymentInfoWorkerDeploymentVersionSummary",
          "description": "Summary of the current version of the Worker Deployment."
        },
        "rampingVersionSummary": {
          "$ref": "#/definitions/WorkerDeploymentInfoWorkerDeploymentVersionSummary",
          "description": "Summary of the ramping version of the Worker Deployment."
        }
      },
      "title": "A subset of WorkerDeploymentInfo"
    },
    "OperatorServiceUpdateNexusEndpointBody": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Data version for this endpoint. Must match current version."
        },
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec"
        }
      }
    },
    "PauseInfoManual": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the actor that paused the activity."
        },
        "reason": {
          "type": "string",
          "description": "Reason for pausing the activity."
        }
      }
    },
    "PauseInfoRule": {
      "type": "object",
      "properties": {
        "ruleId": {
          "type": "string",
          "description": "The rule that paused the activity."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the actor that created the rule."
        },
        "reason": {
          "type": "string",
          "description": "Reason why rule was created. Populated from rule description."
        }
      }
    },
    "PendingActivityInfoPauseInfo": {
      "type": "object",
      "properties": {
        "pauseTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the activity was paused."
        },
        "manual": {
          "$ref": "#/definitions/PauseInfoManual",
          "title": "activity was paused by the manual intervention"
        },
        "rule": {
          "$ref": "#/definitions/PauseInfoRule",
          "title": "activity was paused by the rule"
        }
      }
    },
    "PostResetOperationSignalWorkflow": {
      "type": "object",
      "properties": {
        "signalName": {
          "type": "string",
          "description": "The workflow author-defined name of the signal to send to the workflow."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized value(s) to provide with the signal."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionSignaled event."
        }
      },
      "description": "SignalWorkflow represents sending a signal after a workflow reset.\nKeep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest."
    },
    "PostResetOperationUpdateWorkflowOptions": {
      "type": "object",
      "properties": {
        "workflowExecutionOptions": {
          "$ref": "#/definitions/v1WorkflowExecutionOptions",
          "description": "Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask."
        },
        "updateMask": {
          "type": "string",
          "description": "Controls which fields from `workflow_execution_options` will be applied.\nTo unset a field, set it to null and use the update mask to indicate that it should be mutated."
        }
      },
      "description": "UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.\nKeep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest."
    },
    "StartOperationResponseAsync": {
      "type": "object",
      "properties": {
        "operationId": {
          "type": "string",
          "description": "Deprecated. Renamed to operation_token."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apinexusv1Link"
          }
        },
        "operationToken": {
          "type": "string"
        }
      },
      "description": "The operation will complete asynchronously.\nThe returned ID can be used to reference this operation."
    },
    "StartOperationResponseSync": {
      "type": "object",
      "properties": {
        "payload": {
          "$ref": "#/definitions/v1Payload"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apinexusv1Link"
          }
        }
      },
      "description": "An operation completed successfully."
    },
    "UpdateTaskQueueConfigRequestRateLimitUpdate": {
      "type": "object",
      "properties": {
        "rateLimit": {
          "$ref": "#/definitions/v1RateLimit",
          "title": "Rate Limit to be updated"
        },
        "reason": {
          "type": "string",
          "description": "Reason for why the rate limit was set."
        }
      }
    },
    "UpdateWorkerBuildIdCompatibilityRequestAddNewCompatibleVersion": {
      "type": "object",
      "properties": {
        "newBuildId": {
          "type": "string",
          "description": "A new id to be added to an existing compatible set."
        },
        "existingCompatibleBuildId": {
          "type": "string",
          "description": "A build id which must already exist in the version sets known by the task queue. The new\nid will be stored in the set containing this id, marking it as compatible with\nthe versions within."
        },
        "makeSetDefault": {
          "type": "boolean",
          "description": "When set, establishes the compatible set being targeted as the overall default for the\nqueue. If a different set was the current default, the targeted set will replace it as\nthe new default."
        }
      }
    },
    "UpdateWorkerBuildIdCompatibilityRequestMergeSets": {
      "type": "object",
      "properties": {
        "primarySetBuildId": {
          "type": "string",
          "title": "A build ID in the set whose default will become the merged set default"
        },
        "secondarySetBuildId": {
          "type": "string",
          "title": "A build ID in the set which will be merged into the primary set"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestAddCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        }
      },
      "description": "Adds the rule to the list of redirect rules for this Task Queue. There\ncan be at most one redirect rule for each distinct Source Build ID."
    },
    "UpdateWorkerVersioningRulesRequestCommitBuildId": {
      "type": "object",
      "properties": {
        "targetBuildId": {
          "type": "string"
        },
        "force": {
          "type": "boolean",
          "description": "To prevent committing invalid Build IDs, we reject the request if no\npollers has been seen recently for this Build ID. Use the `force`\noption to disable this validation."
        }
      },
      "description": "This command is intended to be used to complete the rollout of a Build\nID and cleanup unnecessary rules possibly created during a gradual\nrollout. Specifically, this command will make the following changes\natomically:\n 1. Adds an assignment rule (with full ramp) for the target Build ID at\n    the end of the list.\n 2. Removes all previously added assignment rules to the given target\n    Build ID (if any).\n 3. Removes any fully-ramped assignment rule for other Build IDs."
    },
    "UpdateWorkerVersioningRulesRequestDeleteBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32"
        },
        "force": {
          "type": "boolean",
          "title": "By default presence of one unconditional rule is enforced, otherwise\nthe delete operation will be rejected. Set `force` to true to\nbypass this validation. An unconditional assignment rule:\n  - Has no hint filter\n  - Has no ramp"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestDeleteCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "sourceBuildId": {
          "type": "string"
        }
      }
    },
    "UpdateWorkerVersioningRulesRequestInsertBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32",
          "description": "Use this option to insert the rule in a particular index. By\ndefault, the new rule is inserted at the beginning of the list\n(index 0). If the given index is too larger the rule will be\ninserted at the end of the list."
        },
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        }
      },
      "description": "Inserts the rule to the list of assignment rules for this Task Queue.\nThe rules are evaluated in order, starting from index 0. The first\napplicable rule will be applied and the rest will be ignored."
    },
    "UpdateWorkerVersioningRulesRequestReplaceBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "ruleIndex": {
          "type": "integer",
          "format": "int32"
        },
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        },
        "force": {
          "type": "boolean",
          "title": "By default presence of one unconditional rule is enforced, otherwise\nthe replace operation will be rejected. Set `force` to true to\nbypass this validation. An unconditional assignment rule:\n  - Has no hint filter\n  - Has no ramp"
        }
      },
      "description": "Replaces the assignment rule at a given index."
    },
    "UpdateWorkerVersioningRulesRequestReplaceCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        }
      },
      "description": "Replaces the routing rule with the given source Build ID."
    },
    "VersioningOverridePinnedOverride": {
      "type": "object",
      "properties": {
        "behavior": {
          "$ref": "#/definitions/VersioningOverridePinnedOverrideBehavior",
          "description": "Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.\nSee `PinnedOverrideBehavior` for details."
        },
        "version": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "Required."
        }
      }
    },
    "VersioningOverridePinnedOverrideBehavior": {
      "type": "string",
      "enum": [
        "PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED",
        "PINNED_OVERRIDE_BEHAVIOR_PINNED"
      ],
      "default": "PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED",
      "description": "Used to specify different sub-types of Pinned override that we plan to add in the future.\n\n - PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED: Unspecified.\n - PINNED_OVERRIDE_BEHAVIOR_PINNED: Override workflow behavior to be Pinned."
    },
    "WorkerConfigAutoscalingPollerBehavior": {
      "type": "object",
      "properties": {
        "minPollers": {
          "type": "integer",
          "format": "int32",
          "description": "At least this many poll calls will always be attempted (assuming slots are available).\nCannot be zero."
        },
        "maxPollers": {
          "type": "integer",
          "format": "int32",
          "description": "At most this many poll calls will ever be open at once. Must be >= `minimum`."
        },
        "initialPollers": {
          "type": "integer",
          "format": "int32",
          "description": "This many polls will be attempted initially before scaling kicks in. Must be between\n `minimum` and `maximum`."
        }
      }
    },
    "WorkerConfigSimplePollerBehavior": {
      "type": "object",
      "properties": {
        "maxPollers": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "WorkerDeploymentInfoWorkerDeploymentVersionSummary": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `deployment_version`."
        },
        "status": {
          "$ref": "#/definitions/v1WorkerDeploymentVersionStatus",
          "description": "The status of the Worker Deployment Version."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "Required."
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "drainageStatus": {
          "$ref": "#/definitions/v1VersionDrainageStatus",
          "description": "Deprecated. Use `drainage_info` instead."
        },
        "drainageInfo": {
          "$ref": "#/definitions/v1VersionDrainageInfo",
          "title": "Information about workflow drainage to help the user determine when it is safe\nto decommission a Version. Not present while version is current or ramping"
        },
        "currentSinceTime": {
          "type": "string",
          "format": "date-time",
          "description": "Unset if not current."
        },
        "rampingSinceTime": {
          "type": "string",
          "format": "date-time",
          "description": "Unset if not ramping. Updated when the version first starts ramping, not on each ramp change."
        },
        "routingUpdateTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed."
        },
        "firstActivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this version first became current or ramping."
        },
        "lastDeactivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this version last stopped being current or ramping."
        }
      }
    },
    "WorkerDeploymentVersionInfoVersionTaskQueueInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/v1TaskQueueType"
        }
      }
    },
    "WorkflowEventEventReference": {
      "type": "object",
      "properties": {
        "eventId": {
          "type": "string",
          "format": "int64"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        }
      },
      "description": "EventReference is a direct reference to a history event through the event ID."
    },
    "WorkflowEventRequestIdReference": {
      "type": "object",
      "properties": {
        "requestId": {
          "type": "string"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        }
      },
      "description": "RequestIdReference is a indirect reference to a history event through the request ID."
    },
    "WorkflowRuleActionActionActivityPause": {
      "type": "object"
    },
    "WorkflowRuleSpecActivityStartingTrigger": {
      "type": "object",
      "properties": {
        "predicate": {
          "type": "string",
          "title": "Activity predicate is a SQL-like string filter parameter.\nIt is used to match against workflow data.\nThe following activity attributes are supported as part of the predicate:\n- ActivityType: An Activity Type is the mapping of a name to an Activity Definition..\n- ActivityId: The ID of the activity.\n- ActivityAttempt: The number attempts of the activity.\n- BackoffInterval: The current amount of time between scheduled attempts of the activity.\n- ActivityStatus: The status of the activity. Can be one of \"Scheduled\", \"Started\", \"Paused\".\n- TaskQueue: The name of the task queue the workflow specified that the activity should run on.\nActivity predicate support the following operators:\n * =, !=, >, >=, <, <=\n * AND, OR, ()\n * BETWEEN ... AND\n   STARTS_WITH"
        }
      },
      "description": "Activity trigger will be triggered when an activity is about to start."
    },
    "WorkflowServiceCreateScheduleBody": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "description": "The schedule spec, policies, action, and initial state."
        },
        "initialPatch": {
          "$ref": "#/definitions/v1SchedulePatch",
          "description": "Optional initial patch (e.g. to run the action once immediately)."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this create request for idempotence. Typically UUIDv4."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo",
          "description": "Memo and search attributes to attach to the schedule itself."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "WorkflowServiceCreateWorkflowRuleBody": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1WorkflowRuleSpec",
          "description": "The rule specification ."
        },
        "forceScan": {
          "type": "boolean",
          "description": "If true, the rule will be applied to the currently running workflows via batch job.\nIf not set , the rule will only be applied when triggering condition is satisfied.\nvisibility_query in the rule will be used to select the workflows to apply the rule to."
        },
        "requestId": {
          "type": "string",
          "description": "Used to de-dupe requests. Typically should be UUID."
        },
        "identity": {
          "type": "string",
          "description": "Identity of the actor who created the rule. Will be stored with the rule."
        },
        "description": {
          "type": "string",
          "description": "Rule description.Will be stored with the rule."
        }
      }
    },
    "WorkflowServiceExecuteMultiOperationBody": {
      "type": "object",
      "properties": {
        "operations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ExecuteMultiOperationRequestOperation"
          },
          "description": "List of operations to execute within a single workflow.\n\nPreconditions:\n- The list of operations must not be empty.\n- The workflow ids must match across operations.\n- The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.\n\nNote that additional operation-specific restrictions have to be considered."
        }
      }
    },
    "WorkflowServiceFetchWorkerConfigBody": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "reason": {
          "type": "string",
          "description": "Reason for sending worker command, can be used for audit purpose."
        },
        "selector": {
          "$ref": "#/definitions/v1WorkerSelector",
          "description": "Defines which workers should receive this command.\nonly single worker is supported at this time."
        }
      }
    },
    "WorkflowServicePatchScheduleBody": {
      "type": "object",
      "properties": {
        "patch": {
          "$ref": "#/definitions/v1SchedulePatch"
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
        }
      }
    },
    "WorkflowServicePauseActivityBody": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the workflow which scheduled this activity"
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "id": {
          "type": "string",
          "description": "Only the activity with this ID will be paused."
        },
        "type": {
          "type": "string",
          "description": "Pause all running activities of this type."
        },
        "reason": {
          "type": "string",
          "description": "Reason to pause the activity."
        }
      }
    },
    "WorkflowServiceQueryWorkflowBody": {
      "type": "object",
      "properties": {
        "execution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "query": {
          "type": "object",
          "properties": {
            "queryArgs": {
              "$ref": "#/definitions/v1Payloads",
              "description": "Serialized arguments that will be provided to the query handler."
            },
            "header": {
              "$ref": "#/definitions/v1Header",
              "description": "Headers that were passed by the caller of the query and copied by temporal\nserver into the workflow task."
            }
          },
          "title": "See https://docs.temporal.io/docs/concepts/queries/"
        },
        "queryRejectCondition": {
          "$ref": "#/definitions/v1QueryRejectCondition",
          "description": "QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.\nDefault: QUERY_REJECT_CONDITION_NONE."
        }
      }
    },
    "WorkflowServiceRecordActivityTaskHeartbeatBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arbitrary data, of which the most recent call is kept, to store for this activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRecordActivityTaskHeartbeatByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity we're heartbeating"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arbitrary data, of which the most recent call is kept, to store for this activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRecordWorkerHeartbeatBody": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "workerHeartbeat": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkerHeartbeat"
          }
        }
      }
    },
    "WorkflowServiceRequestCancelWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe cancellation requests"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionCanceled event."
        }
      }
    },
    "WorkflowServiceResetActivityBody": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the workflow which scheduled this activity"
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "id": {
          "type": "string",
          "description": "Only activity with this ID will be reset."
        },
        "type": {
          "type": "string",
          "description": "Reset all running activities with of this type."
        },
        "matchAll": {
          "type": "boolean",
          "description": "Reset all running activities."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "description": "Indicates that activity should reset heartbeat details.\nThis flag will be applied only to the new instance of the activity."
        },
        "keepPaused": {
          "type": "boolean",
          "title": "If activity is paused, it will remain paused after reset"
        },
        "jitter": {
          "type": "string",
          "title": "If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.\n(unless it is paused and keep_paused is set)"
        },
        "restoreOriginalOptions": {
          "type": "boolean",
          "description": "If set, the activity options will be restored to the defaults.\nDefault options are then options activity was created with.\nThey are part of the first SCHEDULE event."
        }
      },
      "title": "NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities"
    },
    "WorkflowServiceResetWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "The workflow to reset. If this contains a run ID then the workflow will be reset back to the\nprovided event ID in that run. Otherwise it will be reset to the provided event ID in the\ncurrent run. In all cases the current run will be terminated and a new run started.",
          "title": "The workflow to reset. If this contains a run ID then the workflow will be reset back to the\nprovided event ID in that run. Otherwise it will be reset to the provided event ID in the\ncurrent run. In all cases the current run will be terminated and a new run started."
        },
        "reason": {
          "type": "string"
        },
        "workflowTaskFinishEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n`WORKFLOW_TASK_STARTED` event to reset to."
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe reset requests"
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "title": "Deprecated. Use `options`.\nDefault: RESET_REAPPLY_TYPE_SIGNAL"
        },
        "resetReapplyExcludeTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ResetReapplyExcludeType"
          },
          "title": "Event types not to be reapplied"
        },
        "postResetOperations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PostResetOperation"
          },
          "title": "Operations to perform after the workflow has been reset. These operations will be applied\nto the *new* run of the workflow execution in the order they are provided.\nAll operations are applied to the workflow before the first new workflow task is generated"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCanceledBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the cancellation"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more.\nDeprecated. Use `deployment_options` instead."
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "Deployment info of the worker that completed this task. Must be present if user has set\n`WorkerDeploymentOptions` regardless of versioning being enabled or not.\nDeprecated. Replaced with `deployment_options`."
        },
        "deploymentOptions": {
          "$ref": "#/definitions/v1WorkerDeploymentOptions",
          "description": "Worker deployment options that user has set in the worker."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCanceledByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to confirm is cancelled"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the cancellation"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "deploymentOptions": {
          "$ref": "#/definitions/v1WorkerDeploymentOptions",
          "description": "Worker deployment options that user has set in the worker."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCompletedBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "The result of successfully executing the activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more.\nDeprecated. Use `deployment_options` instead."
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "Deployment info of the worker that completed this task. Must be present if user has set\n`WorkerDeploymentOptions` regardless of versioning being enabled or not.\nDeprecated. Replaced with `deployment_options`."
        },
        "deploymentOptions": {
          "$ref": "#/definitions/v1WorkerDeploymentOptions",
          "description": "Worker deployment options that user has set in the worker."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskCompletedByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to complete"
        },
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "The serialized result of activity execution"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      }
    },
    "WorkflowServiceRespondActivityTaskFailedBody": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "The task token as received in `PollActivityTaskQueueResponse`"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Detailed failure information"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional details to be stored as last activity heartbeat"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this task. This message's `build_id` field should\nalways be set by SDKs. Workers opting into versioning will also set the `use_versioning`\nfield to true. See message docstrings for more.\nDeprecated. Use `deployment_options` instead."
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "Deployment info of the worker that completed this task. Must be present if user has set\n`WorkerDeploymentOptions` regardless of versioning being enabled or not.\nDeprecated. Replaced with `deployment_options`."
        },
        "deploymentOptions": {
          "$ref": "#/definitions/v1WorkerDeploymentOptions",
          "description": "Worker deployment options that user has set in the worker."
        }
      }
    },
    "WorkflowServiceRespondActivityTaskFailedByIdBody": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string",
          "title": "Id of the workflow which scheduled this activity"
        },
        "runId": {
          "type": "string",
          "title": "Run Id of the workflow which scheduled this activity"
        },
        "activityId": {
          "type": "string",
          "title": "Id of the activity to fail"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Detailed failure information"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional details to be stored as last activity heartbeat"
        }
      }
    },
    "WorkflowServiceSetCurrentDeploymentBody": {
      "type": "object",
      "properties": {
        "deployment": {
          "type": "object",
          "properties": {
            "buildId": {
              "type": "string",
              "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges."
            }
          },
          "description": "`Deployment` identifies a deployment of Temporal workers. The combination of deployment series\nname + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker\nprograms to specify these values.\nDeprecated."
        },
        "identity": {
          "type": "string",
          "description": "Optional. The identity of the client who initiated this request."
        },
        "updateMetadata": {
          "$ref": "#/definitions/v1UpdateDeploymentMetadata",
          "description": "Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed\nwhen describing a deployment. It is a good place for information such as operator name,\nlinks to internal deployment pipelines, etc."
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "WorkflowServiceSetWorkerDeploymentCurrentVersionBody": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `build_id`."
        },
        "buildId": {
          "type": "string",
          "title": "The build id of the Version that you want to set as Current.\nPass an empty value to set the Current Version to nil.\nA nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)"
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "Optional. This can be the value of conflict_token from a Describe, or another Worker\nDeployment API. Passing a non-nil conflict token will cause this request to fail if the\nDeployment's configuration has been modified between the API call that generated the\ntoken and this one."
        },
        "identity": {
          "type": "string",
          "description": "Optional. The identity of the client who initiated this request."
        },
        "ignoreMissingTaskQueues": {
          "type": "boolean",
          "description": "Optional. By default this request would be rejected if not all the expected Task Queues are\nbeing polled by the new Version, to protect against accidental removal of Task Queues, or\nworker health issues. Pass `true` here to bypass this protection.\nThe set of expected Task Queues is the set of all the Task Queues that were ever poller by\nthe existing Current Version of the Deployment, with the following exclusions:\n  - Task Queues that are not used anymore (inferred by having empty backlog and a task\n    add_rate of 0.)\n  - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue\n    having a different Current Version than the Current Version of this deployment.)\nWARNING: Do not set this flag unless you are sure that the missing task queue pollers are not\nneeded. If the request is unexpectedly rejected due to missing pollers, then that means the\npollers have not reached to the server yet. Only set this if you expect those pollers to\nnever arrive."
        }
      },
      "description": "Set/unset the Current Version of a Worker Deployment."
    },
    "WorkflowServiceSetWorkerDeploymentRampingVersionBody": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `build_id`."
        },
        "buildId": {
          "type": "string",
          "title": "The build id of the Version that you want to ramp traffic to.\nPass an empty value to set the Ramping Version to nil.\nA nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)"
        },
        "percentage": {
          "type": "number",
          "format": "float",
          "description": "Ramp percentage to set. Valid range: [0,100]."
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "Optional. This can be the value of conflict_token from a Describe, or another Worker\nDeployment API. Passing a non-nil conflict token will cause this request to fail if the\nDeployment's configuration has been modified between the API call that generated the\ntoken and this one."
        },
        "identity": {
          "type": "string",
          "description": "Optional. The identity of the client who initiated this request."
        },
        "ignoreMissingTaskQueues": {
          "type": "boolean",
          "description": "Optional. By default this request would be rejected if not all the expected Task Queues are\nbeing polled by the new Version, to protect against accidental removal of Task Queues, or\nworker health issues. Pass `true` here to bypass this protection.\nThe set of expected Task Queues equals to all the Task Queues ever polled from the existing\nCurrent Version of the Deployment, with the following exclusions:\n  - Task Queues that are not used anymore (inferred by having empty backlog and a task\n    add_rate of 0.)\n  - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue\n    having a different Current Version than the Current Version of this deployment.)\nWARNING: Do not set this flag unless you are sure that the missing task queue poller are not\nneeded. If the request is unexpectedly rejected due to missing pollers, then that means the\npollers have not reached to the server yet. Only set this if you expect those pollers to\nnever arrive.\nNote: this check only happens when the ramping version is about to change, not every time\nthat the percentage changes. Also note that the check is against the deployment's Current\nVersion, not the previous Ramping Version."
        }
      },
      "description": "Set/unset the Ramping Version of a Worker Deployment and its ramp percentage."
    },
    "WorkflowServiceSignalWithStartWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "title": "The task queue to start this workflow on, if it will be started"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "title": "Total workflow execution timeout including retries and continue as new"
        },
        "workflowRunTimeout": {
          "type": "string",
          "title": "Timeout of a single workflow run"
        },
        "workflowTaskTimeout": {
          "type": "string",
          "title": "Timeout of a single workflow task"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe signal w/ start requests"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.\nNote that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "signalInput": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "title": "Retry policy for the workflow"
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nNote that the signal will be delivered with the first workflow task. If the workflow gets\nanother SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately\nand the rest of the delay period will be ignored, even if that request also had a delay.\nSignal via SignalWorkflowExecution will not unblock the workflow."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events."
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\nTo unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      }
    },
    "WorkflowServiceSignalWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "requestId": {
          "type": "string",
          "title": "Used to de-dupe sent signals"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionSignaled event."
        }
      },
      "description": "Keep the parameters in sync with:\n  - temporal.api.batch.v1.BatchOperationSignal.\n  - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow."
    },
    "WorkflowServiceStartBatchOperationBody": {
      "type": "object",
      "properties": {
        "visibilityQuery": {
          "type": "string",
          "title": "Visibility query defines the the group of workflow to apply the batch operation\nThis field and `executions` are mutually exclusive"
        },
        "reason": {
          "type": "string",
          "title": "Reason to perform the batch operation"
        },
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecution"
          },
          "title": "Executions to apply the batch operation\nThis field and `visibility_query` are mutually exclusive"
        },
        "maxOperationsPerSecond": {
          "type": "number",
          "format": "float",
          "description": "Limit for the number of operations processed per second within this batch.\nIts purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system\noverload and minimize potential delays in executing ongoing tasks for user workers.\nNote that when no explicit limit is provided, the server will operate according to its limit defined by the\ndynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the\nserver's configured limit."
        },
        "terminationOperation": {
          "$ref": "#/definitions/v1BatchOperationTermination"
        },
        "signalOperation": {
          "$ref": "#/definitions/v1BatchOperationSignal"
        },
        "cancellationOperation": {
          "$ref": "#/definitions/v1BatchOperationCancellation"
        },
        "deletionOperation": {
          "$ref": "#/definitions/v1BatchOperationDeletion"
        },
        "resetOperation": {
          "$ref": "#/definitions/v1BatchOperationReset"
        },
        "updateWorkflowOptionsOperation": {
          "$ref": "#/definitions/v1BatchOperationUpdateWorkflowExecutionOptions"
        },
        "unpauseActivitiesOperation": {
          "$ref": "#/definitions/v1BatchOperationUnpauseActivities"
        },
        "resetActivitiesOperation": {
          "$ref": "#/definitions/v1BatchOperationResetActivities"
        },
        "updateActivityOptionsOperation": {
          "$ref": "#/definitions/v1BatchOperationUpdateActivityOptions"
        }
      }
    },
    "WorkflowServiceStartWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this start request. Typically UUIDv4."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to get the first workflow task inline in the response bypassing matching service and worker polling.\nIf set to `true` the caller is expected to have a worker available and capable of processing the task.\nThe returned task will be marked as started and is expected to be completed by the specified\n`workflow_task_timeout`."
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "These values will be available as ContinuedFailure and LastCompletionResult in the\nWorkflowExecutionStarted event and through SDKs. The are currently only used by the\nserver itself (for the schedules feature) and are not intended to be exposed in\nStartWorkflowExecution."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nIf the workflow gets a signal before the delay, a workflow task will be dispatched and the rest\nof the delay will be ignored."
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Callbacks to be called by the server when this workflow reaches a terminal state.\nIf the workflow continues-as-new, these callbacks will be carried over to the new execution.\nCallback addresses must be whitelisted in the server's dynamic configuration."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the workflow."
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\nTo unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
        },
        "onConflictOptions": {
          "$ref": "#/definitions/v1OnConflictOptions",
          "description": "Defines actions to be done to the existing running workflow when the conflict policy\nWORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a\nempty object (ie., all options with default value), it won't do anything to the existing\nrunning workflow. If set, it will add a history event to the running workflow."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      }
    },
    "WorkflowServiceStopBatchOperationBody": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "title": "Reason to stop a batch operation"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the operator"
        }
      }
    },
    "WorkflowServiceTerminateWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
        },
        "reason": {
          "type": "string"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized additional information to attach to the termination event"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no run id is set on\n`workflow_execution`), or specified (if it is) workflow execution is not part of the same\nexecution chain as this id."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the WorkflowExecutionTerminated event."
        }
      }
    },
    "WorkflowServiceTriggerWorkflowRuleBody": {
      "type": "object",
      "properties": {
        "execution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "title": "Execution info of the workflow which scheduled this activity"
        },
        "id": {
          "type": "string"
        },
        "spec": {
          "$ref": "#/definitions/v1WorkflowRuleSpec",
          "description": "Note: Rule ID and expiration date are not used in the trigger request."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        }
      }
    },
    "WorkflowServiceUnpauseActivityBody": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the workflow which scheduled this activity"
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "id": {
          "type": "string",
          "description": "Only the activity with this ID will be unpaused."
        },
        "type": {
          "type": "string",
          "description": "Unpause all running activities with of this type."
        },
        "unpauseAll": {
          "type": "boolean",
          "description": "Unpause all running activities."
        },
        "resetAttempts": {
          "type": "boolean",
          "description": "Providing this flag will also reset the number of attempts."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "description": "Providing this flag will also reset the heartbeat details."
        },
        "jitter": {
          "type": "string",
          "description": "If set, the activity will start at a random time within the specified jitter duration."
        }
      }
    },
    "WorkflowServiceUpdateActivityOptionsBody": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the workflow which scheduled this activity"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "title": "Activity options. Partial updates are accepted and controlled by update_mask"
        },
        "updateMask": {
          "type": "string",
          "title": "Controls which fields from `activity_options` will be applied"
        },
        "id": {
          "type": "string",
          "description": "Only activity with this ID will be updated."
        },
        "type": {
          "type": "string",
          "description": "Update all running activities of this type."
        },
        "matchAll": {
          "type": "boolean",
          "description": "Update all running activities."
        },
        "restoreOriginal": {
          "type": "boolean",
          "description": "If set, the activity options will be restored to the default.\nDefault options are then options activity was created with.\nThey are part of the first SCHEDULE event.\nThis flag cannot be combined with any other option; if you supply\nrestore_original together with other options, the request will be rejected."
        }
      },
      "title": "NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions"
    },
    "WorkflowServiceUpdateNamespaceBody": {
      "type": "object",
      "properties": {
        "updateInfo": {
          "$ref": "#/definitions/v1UpdateNamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "securityToken": {
          "type": "string"
        },
        "deleteBadBinary": {
          "type": "string"
        },
        "promoteNamespace": {
          "type": "boolean",
          "description": "promote local namespace to global namespace. Ignored if namespace is already global namespace."
        }
      }
    },
    "WorkflowServiceUpdateScheduleBody": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "description": "The new schedule. The four main fields of the schedule (spec, action,\npolicies, state) are replaced completely by the values in this message."
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This can be the value of conflict_token from a DescribeScheduleResponse,\nwhich will cause this request to fail if the schedule has been modified\nbetween the Describe and this Update.\nIf missing, the schedule will be updated unconditionally."
        },
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this update request for idempotence. Typically UUIDv4."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes",
          "description": "Schedule search attributes to be updated.\nDo not set this field if you do not want to update the search attributes.\nA non-null empty object will set the search attributes to an empty map.\nNote: you cannot only update the search attributes with `UpdateScheduleRequest`,\nyou must also set the `schedule` field; otherwise, it will unset the schedule."
        }
      }
    },
    "WorkflowServiceUpdateTaskQueueConfigBody": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string"
        },
        "taskQueueType": {
          "$ref": "#/definitions/v1TaskQueueType"
        },
        "updateQueueRateLimit": {
          "$ref": "#/definitions/UpdateTaskQueueConfigRequestRateLimitUpdate",
          "description": "Update to queue-wide rate limit.\nIf not set, this configuration is unchanged.\nNOTE: A limit set by the worker is overriden; and restored again when reset.\nIf the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit."
        },
        "updateFairnessKeyRateLimitDefault": {
          "$ref": "#/definitions/UpdateTaskQueueConfigRequestRateLimitUpdate",
          "description": "Update to the default fairness key rate limit.\nIf not set, this configuration is unchanged.\nIf the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit."
        }
      }
    },
    "WorkflowServiceUpdateWorkerConfigBody": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the client who initiated this request."
        },
        "reason": {
          "type": "string",
          "description": "Reason for sending worker command, can be used for audit purpose."
        },
        "workerConfig": {
          "$ref": "#/definitions/v1WorkerConfig",
          "description": "Partial updates are accepted and controlled by update_mask.\nThe worker configuration to set."
        },
        "updateMask": {
          "type": "string",
          "title": "Controls which fields from `worker_config` will be applied"
        },
        "selector": {
          "$ref": "#/definitions/v1WorkerSelector",
          "description": "Defines which workers should receive this command."
        }
      }
    },
    "WorkflowServiceUpdateWorkerDeploymentVersionMetadataBody": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `deployment_version`."
        },
        "deploymentVersion": {
          "type": "object",
          "description": "Required.",
          "title": "Required."
        },
        "upsertEntries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        },
        "removeEntries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of keys to remove from the metadata."
        },
        "identity": {
          "type": "string",
          "description": "Optional. The identity of the client who initiated this request."
        }
      },
      "description": "Used to update the user-defined metadata of a Worker Deployment Version."
    },
    "WorkflowServiceUpdateWorkflowExecutionBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "The target Workflow Id and (optionally) a specific Run Id thereof.",
          "title": "The target Workflow Id and (optionally) a specific Run Id thereof."
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no Run Id is set on\n`workflow_execution`), or specified (if it is) Workflow Execution is not\npart of the same execution chain as this Id."
        },
        "waitPolicy": {
          "$ref": "#/definitions/v1WaitPolicy",
          "description": "Specifies client's intent to wait for Update results.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached.\nActual reached stage will be included in the response."
        },
        "request": {
          "type": "object",
          "properties": {
            "meta": {
              "$ref": "#/definitions/v1Meta"
            },
            "input": {
              "type": "object",
              "properties": {
                "header": {
                  "$ref": "#/definitions/v1Header",
                  "description": "Headers that are passed with the Update from the requesting entity.\nThese can include things like auth or tracing tokens."
                },
                "args": {
                  "$ref": "#/definitions/v1Payloads",
                  "description": "The arguments to pass to the named Update handler."
                }
              }
            }
          },
          "description": "The request information that will be delivered all the way down to the\nWorkflow Execution.",
          "title": "The request information that will be delivered all the way down to the\nWorkflow Execution."
        }
      }
    },
    "WorkflowServiceUpdateWorkflowExecutionOptionsBody": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "type": "object",
          "properties": {
            "runId": {
              "type": "string"
            }
          },
          "description": "The target Workflow Id and (optionally) a specific Run Id thereof.",
          "title": "The target Workflow Id and (optionally) a specific Run Id thereof."
        },
        "workflowExecutionOptions": {
          "$ref": "#/definitions/v1WorkflowExecutionOptions",
          "description": "Workflow Execution options. Partial updates are accepted and controlled by update_mask."
        },
        "updateMask": {
          "type": "string",
          "description": "Controls which fields from `workflow_execution_options` will be applied.\nTo unset a field, set it to null and use the update mask to indicate that it should be mutated."
        }
      },
      "description": "Keep the parameters in sync with:\n  - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.\n  - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions."
    },
    "apicommonv1Link": {
      "type": "object",
      "properties": {
        "workflowEvent": {
          "$ref": "#/definitions/LinkWorkflowEvent"
        },
        "batchJob": {
          "$ref": "#/definitions/LinkBatchJob"
        }
      },
      "description": "Link can be associated with history events. It might contain information about an external entity\nrelated to the history event. For example, workflow A makes a Nexus call that starts workflow B:\nin this case, a history event in workflow A could contain a Link to the workflow started event in\nworkflow B, and vice-versa."
    },
    "apifailurev1Failure": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "source": {
          "type": "string",
          "description": "The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK\nIn some SDKs this is used to rehydrate the stack trace into an exception object."
        },
        "stackTrace": {
          "type": "string"
        },
        "encodedAttributes": {
          "$ref": "#/definitions/v1Payload",
          "description": "Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of\nerrors originating in user code which might contain sensitive information.\nThe `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto\nmessage.\n\nSDK authors:\n- The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:\n  - Uses a JSON object to represent `{ message, stack_trace }`.\n  - Overwrites the original message with \"Encoded failure\" to indicate that more information could be extracted.\n  - Overwrites the original stack_trace with an empty string.\n  - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed\n    by the user-provided PayloadCodec\n\n- If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes."
        },
        "cause": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "applicationFailureInfo": {
          "$ref": "#/definitions/v1ApplicationFailureInfo"
        },
        "timeoutFailureInfo": {
          "$ref": "#/definitions/v1TimeoutFailureInfo"
        },
        "canceledFailureInfo": {
          "$ref": "#/definitions/v1CanceledFailureInfo"
        },
        "terminatedFailureInfo": {
          "$ref": "#/definitions/v1TerminatedFailureInfo"
        },
        "serverFailureInfo": {
          "$ref": "#/definitions/v1ServerFailureInfo"
        },
        "resetWorkflowFailureInfo": {
          "$ref": "#/definitions/v1ResetWorkflowFailureInfo"
        },
        "activityFailureInfo": {
          "$ref": "#/definitions/v1ActivityFailureInfo"
        },
        "childWorkflowExecutionFailureInfo": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailureInfo"
        },
        "nexusOperationExecutionFailureInfo": {
          "$ref": "#/definitions/v1NexusOperationFailureInfo"
        },
        "nexusHandlerFailureInfo": {
          "$ref": "#/definitions/v1NexusHandlerFailureInfo"
        }
      }
    },
    "apinexusv1Failure": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "details": {
          "type": "string",
          "format": "byte",
          "description": "UTF-8 encoded JSON serializable details."
        }
      },
      "title": "A general purpose failure message.\nSee: https://github.com/nexus-rpc/api/blob/main/SPEC.md#failure"
    },
    "apinexusv1Link": {
      "type": "object",
      "properties": {
        "url": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#links."
        },
        "type": {
          "type": "string"
        }
      }
    },
    "apinexusv1Request": {
      "type": "object",
      "properties": {
        "header": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Headers extracted from the original request in the Temporal frontend.\nWhen using Nexus over HTTP, this includes the request's HTTP headers ignoring multiple values."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "The timestamp when the request was scheduled in the frontend."
        },
        "startOperation": {
          "$ref": "#/definitions/v1StartOperationRequest"
        },
        "cancelOperation": {
          "$ref": "#/definitions/v1CancelOperationRequest"
        }
      },
      "description": "A Nexus request."
    },
    "apinexusv1Response": {
      "type": "object",
      "properties": {
        "startOperation": {
          "$ref": "#/definitions/v1StartOperationResponse"
        },
        "cancelOperation": {
          "$ref": "#/definitions/v1CancelOperationResponse"
        }
      },
      "description": "A response indicating that the handler has successfully processed a request."
    },
    "apiupdatev1Request": {
      "type": "object",
      "properties": {
        "meta": {
          "$ref": "#/definitions/v1Meta"
        },
        "input": {
          "$ref": "#/definitions/v1Input"
        }
      },
      "description": "The client request that triggers a Workflow Update."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "rpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "v1ActivityFailureInfo": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "identity": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityOptions": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\nretries will be attempted. Either this or `start_to_close_timeout` must be specified.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\ntimeout is always non retryable, as all a retry would achieve is to put it back into the same\nqueue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\nspecified.\n"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be\nspecified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        }
      }
    },
    "v1ActivityPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to."
        },
        "newRetryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "If set, update the retry policy of the activity, replacing it with the specified one.\nThe number of attempts at the activity is preserved."
        }
      }
    },
    "v1ActivityTaskCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1ActivityTaskCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Additional information that the activity reported upon confirming cancellation"
        },
        "latestCancelRequestedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same\nactivity"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker who canceled this activity"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1ActivityTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized results of the activity. IE: The return value of the activity function"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that completed this task"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1ActivityTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Failure details"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that failed this task"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1ActivityTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string",
          "title": "The worker/user assigned identifier for the activity"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for an activity completion. Limits how long\nretries will be attempted. Either this or `start_to_close_timeout` must be specified.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "description": "Limits time an activity task can stay in a task queue before a worker picks it up. This\ntimeout is always non retryable, as all a retry would achieve is to put it back into the same\nqueue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not\nspecified.\n"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be\nspecified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are assigned a default retry policy controlled by the service's dynamic\nconfiguration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set\nretry_policy.maximum_attempts to 1."
        },
        "useWorkflowBuildId": {
          "type": "boolean",
          "title": "If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,\nAssignment rules of the activity's Task Queue will be used to determine the Build ID.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "description": "Priority metadata. If this message is not present, or any fields are not\npresent, they inherit the values from the workflow."
        }
      }
    },
    "v1ActivityTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker that picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO ??"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times this task has been attempted"
        },
        "lastFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Will be set to the most recent failure details, if this task has previously failed and then\nbeen retried."
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker to whom this task was dispatched.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "buildIdRedirectCounter": {
          "type": "string",
          "format": "int64",
          "title": "Used by server internally to properly reapply build ID redirects to an execution\nwhen rebuilding it from events.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1ActivityTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "If this activity had failed, was retried, and then timed out, that failure is stored as the\n`cause` in here."
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ActivityType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a activity author to define the activity. Typically, the\nname of a function. This is sometimes referred to as the activity's \"name\""
    },
    "v1AddOrUpdateRemoteClusterResponse": {
      "type": "object"
    },
    "v1AddSearchAttributesResponse": {
      "type": "object"
    },
    "v1Alert": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string"
        },
        "severity": {
          "$ref": "#/definitions/v1Severity"
        }
      },
      "description": "Alert contains notification and severity."
    },
    "v1ApplicationErrorCategory": {
      "type": "string",
      "enum": [
        "APPLICATION_ERROR_CATEGORY_UNSPECIFIED",
        "APPLICATION_ERROR_CATEGORY_BENIGN"
      ],
      "default": "APPLICATION_ERROR_CATEGORY_UNSPECIFIED",
      "description": " - APPLICATION_ERROR_CATEGORY_BENIGN: Expected application error with little/no severity."
    },
    "v1ApplicationFailureInfo": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string"
        },
        "nonRetryable": {
          "type": "boolean"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "nextRetryDelay": {
          "type": "string",
          "description": "next_retry_delay can be used by the client to override the activity\nretry interval calculated by the retry policy. Retry attempts will\nstill be subject to the maximum retries limit and total time limit\ndefined by the policy."
        },
        "category": {
          "$ref": "#/definitions/v1ApplicationErrorCategory"
        }
      }
    },
    "v1ArchivalState": {
      "type": "string",
      "enum": [
        "ARCHIVAL_STATE_UNSPECIFIED",
        "ARCHIVAL_STATE_DISABLED",
        "ARCHIVAL_STATE_ENABLED"
      ],
      "default": "ARCHIVAL_STATE_UNSPECIFIED"
    },
    "v1BackfillRequest": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time range to evaluate schedule in. Currently, this time range is\nexclusive on start_time and inclusive on end_time. (This is admittedly\ncounterintuitive and it may change in the future, so to be safe, use a\nstart time strictly before a scheduled time.) Also note that an action\nnominally scheduled in the interval but with jitter that pushes it after\nend_time will not be included."
        },
        "endTime": {
          "type": "string",
          "format": "date-time"
        },
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "If set, override overlap policy for this request."
        }
      }
    },
    "v1BadBinaries": {
      "type": "object",
      "properties": {
        "binaries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1BadBinaryInfo"
          }
        }
      }
    },
    "v1BadBinaryInfo": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string"
        },
        "operator": {
          "type": "string"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1BatchOperationCancellation": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationCancellation sends cancel requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationDeletion": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationDeletion sends deletion requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest."
    },
    "v1BatchOperationInfo": {
      "type": "object",
      "properties": {
        "jobId": {
          "type": "string",
          "title": "Batch job ID"
        },
        "state": {
          "$ref": "#/definitions/v1BatchOperationState",
          "title": "Batch operation state"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation start time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation close time"
        }
      }
    },
    "v1BatchOperationReset": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "options": {
          "$ref": "#/definitions/v1ResetOptions",
          "description": "Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored."
        },
        "resetType": {
          "$ref": "#/definitions/v1ResetType",
          "description": "Deprecated. Use `options`."
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "description": "Deprecated. Use `options`."
        },
        "postResetOperations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PostResetOperation"
          },
          "title": "Operations to perform after the workflow has been reset. These operations will be applied\nto the *new* run of the workflow execution in the order they are provided.\nAll operations are applied to the workflow before the first new workflow task is generated"
        }
      },
      "description": "BatchOperationReset sends reset requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest."
    },
    "v1BatchOperationResetActivities": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "type": {
          "type": "string"
        },
        "matchAll": {
          "type": "boolean"
        },
        "resetAttempts": {
          "type": "boolean",
          "description": "Setting this flag will also reset the number of attempts."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "description": "Setting this flag will also reset the heartbeat details."
        },
        "keepPaused": {
          "type": "boolean",
          "title": "If activity is paused, it will remain paused after reset"
        },
        "jitter": {
          "type": "string",
          "description": "If set, the activity will start at a random time within the specified jitter\nduration, introducing variability to the start time."
        },
        "restoreOriginalOptions": {
          "type": "boolean",
          "description": "If set, the activity options will be restored to the defaults.\nDefault options are then options activity was created with.\nThey are part of the first ActivityTaskScheduled event."
        }
      },
      "title": "BatchOperationResetActivities sends activity reset requests in a batch.\nNOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest"
    },
    "v1BatchOperationSignal": {
      "type": "object",
      "properties": {
        "signal": {
          "type": "string",
          "title": "The workflow author-defined name of the signal to send to the workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide with the signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the signal to the processing workflow.\nThese can include things like auth or tracing tokens."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationSignal sends signals to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest."
    },
    "v1BatchOperationState": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_STATE_UNSPECIFIED",
        "BATCH_OPERATION_STATE_RUNNING",
        "BATCH_OPERATION_STATE_COMPLETED",
        "BATCH_OPERATION_STATE_FAILED"
      ],
      "default": "BATCH_OPERATION_STATE_UNSPECIFIED"
    },
    "v1BatchOperationTermination": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized value(s) to provide to the termination event"
        },
        "identity": {
          "type": "string",
          "title": "The identity of the worker/client"
        }
      },
      "description": "BatchOperationTermination sends terminate requests to batch workflows.\nKeep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.\nIgnore first_execution_run_id because this is used for single workflow operation."
    },
    "v1BatchOperationType": {
      "type": "string",
      "enum": [
        "BATCH_OPERATION_TYPE_UNSPECIFIED",
        "BATCH_OPERATION_TYPE_TERMINATE",
        "BATCH_OPERATION_TYPE_CANCEL",
        "BATCH_OPERATION_TYPE_SIGNAL",
        "BATCH_OPERATION_TYPE_DELETE",
        "BATCH_OPERATION_TYPE_RESET",
        "BATCH_OPERATION_TYPE_UPDATE_EXECUTION_OPTIONS",
        "BATCH_OPERATION_TYPE_UNPAUSE_ACTIVITY",
        "BATCH_OPERATION_TYPE_UPDATE_ACTIVITY_OPTIONS",
        "BATCH_OPERATION_TYPE_RESET_ACTIVITY"
      ],
      "default": "BATCH_OPERATION_TYPE_UNSPECIFIED"
    },
    "v1BatchOperationUnpauseActivities": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "type": {
          "type": "string"
        },
        "matchAll": {
          "type": "boolean"
        },
        "resetAttempts": {
          "type": "boolean",
          "description": "Setting this flag will also reset the number of attempts."
        },
        "resetHeartbeat": {
          "type": "boolean",
          "description": "Setting this flag will also reset the heartbeat details."
        },
        "jitter": {
          "type": "string",
          "description": "If set, the activity will start at a random time within the specified jitter\nduration, introducing variability to the start time."
        }
      },
      "description": "BatchOperationUnpauseActivities sends unpause requests to batch workflows."
    },
    "v1BatchOperationUpdateActivityOptions": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "type": {
          "type": "string"
        },
        "matchAll": {
          "type": "boolean"
        },
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "description": "Update Activity options. Partial updates are accepted and controlled by update_mask."
        },
        "updateMask": {
          "type": "string",
          "title": "Controls which fields from `activity_options` will be applied"
        },
        "restoreOriginal": {
          "type": "boolean",
          "description": "If set, the activity options will be restored to the default.\nDefault options are then options activity was created with.\nThey are part of the first ActivityTaskScheduled event.\nThis flag cannot be combined with any other option; if you supply\nrestore_original together with other options, the request will be rejected."
        }
      },
      "title": "BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.\nNOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest"
    },
    "v1BatchOperationUpdateWorkflowExecutionOptions": {
      "type": "object",
      "properties": {
        "identity": {
          "type": "string",
          "description": "The identity of the worker/client."
        },
        "workflowExecutionOptions": {
          "$ref": "#/definitions/v1WorkflowExecutionOptions",
          "description": "Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask."
        },
        "updateMask": {
          "type": "string",
          "description": "Controls which fields from `workflow_execution_options` will be applied.\nTo unset a field, set it to null and use the update mask to indicate that it should be mutated."
        }
      },
      "description": "BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.\nKeep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest."
    },
    "v1BuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "targetBuildId": {
          "type": "string"
        },
        "percentageRamp": {
          "$ref": "#/definitions/v1RampByPercentage",
          "description": "This ramp is useful for gradual Blue/Green deployments (and similar)\nwhere you want to send a certain portion of the traffic to the target\nBuild ID."
        }
      },
      "description": "Assignment rules are applied to *new* Workflow and Activity executions at\nschedule time to assign them to a Build ID.\n\nAssignment rules will not be used in the following cases:\n   - Child Workflows or Continue-As-New Executions who inherit their\n     parent/previous Workflow's assigned Build ID (by setting the\n     `inherit_build_id` flag - default behavior in SDKs when the same Task Queue\n     is used.)\n   - An Activity that inherits the assigned Build ID of its Workflow (by\n     setting the `use_workflow_build_id` flag - default behavior in SDKs\n     when the same Task Queue is used.)\n\nIn absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)\nthe task will be dispatched to Workers of the Build ID determined by the\nassignment rules (or inherited). Otherwise, the final Build ID will be\ndetermined by the redirect rules.\n\nOnce a Workflow completes its first Workflow Task in a particular Build ID it\nstays in that Build ID regardless of changes to assignment rules. Redirect\nrules can be used to move the workflow to another compatible Build ID.\n\nWhen using Worker Versioning on a Task Queue, in the steady state,\nthere should typically be a single assignment rule to send all new executions\nto the latest Build ID. Existence of at least one such \"unconditional\"\nrule at all times is enforces by the system, unless the `force` flag is used\nby the user when replacing/deleting these rules (for exceptional cases).\n\nDuring a deployment, one or more additional rules can be added to assign a\nsubset of the tasks to a new Build ID based on a \"ramp percentage\".\n\nWhen there are multiple assignment rules for a Task Queue, the rules are\nevaluated in order, starting from index 0. The first applicable rule will be\napplied and the rest will be ignored.\n\nIn the event that no assignment rule is applicable on a task (or the Task\nQueue is simply not versioned), the tasks will be dispatched to an\nunversioned Worker."
    },
    "v1BuildIdReachability": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "A build id or empty if unversioned."
        },
        "taskQueueReachability": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueueReachability"
          },
          "description": "Reachability per task queue."
        }
      },
      "description": "Reachability of tasks for a worker by build id, in one or more task queues."
    },
    "v1BuildIdTaskReachability": {
      "type": "string",
      "enum": [
        "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
        "BUILD_ID_TASK_REACHABILITY_REACHABLE",
        "BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
        "BUILD_ID_TASK_REACHABILITY_UNREACHABLE"
      ],
      "default": "BUILD_ID_TASK_REACHABILITY_UNSPECIFIED",
      "description": "Specifies which category of tasks may reach a versioned worker of a certain Build ID.\n\nTask Reachability is eventually consistent; there may be a delay (up to few minutes) until it\nconverges to the most accurate value but it is designed in a way to take the more conservative\nside until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.\n\nNote: future activities who inherit their workflow's Build ID but not its Task Queue will not be\naccounted for reachability as server cannot know if they'll happen as they do not use\nassignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows\nwho inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make\nsure to query reachability for the parent/previous workflow's Task Queue as well.\n\n - BUILD_ID_TASK_REACHABILITY_UNSPECIFIED: Task reachability is not reported\n - BUILD_ID_TASK_REACHABILITY_REACHABLE: Build ID may be used by new workflows or activities (base on versioning rules), or there MAY\nbe open workflows or backlogged activities assigned to it.\n - BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY: Build ID does not have open workflows and is not reachable by new workflows,\nbut MAY have closed workflows within the namespace retention period.\nNot applicable to activity-only task queues.\n - BUILD_ID_TASK_REACHABILITY_UNREACHABLE: Build ID is not used for new executions, nor it has been used by any existing execution\nwithin the retention period."
    },
    "v1CalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "string",
          "title": "Expression to match seconds. Default: 0"
        },
        "minute": {
          "type": "string",
          "title": "Expression to match minutes. Default: 0"
        },
        "hour": {
          "type": "string",
          "title": "Expression to match hours. Default: 0"
        },
        "dayOfMonth": {
          "type": "string",
          "title": "Expression to match days of the month. Default: *"
        },
        "month": {
          "type": "string",
          "title": "Expression to match months. Default: *"
        },
        "year": {
          "type": "string",
          "title": "Expression to match years. Default: *"
        },
        "dayOfWeek": {
          "type": "string",
          "title": "Expression to match days of the week. Default: *"
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "description": "CalendarSpec describes an event specification relative to the calendar,\nsimilar to a traditional cron specification, but with labeled fields. Each\nfield can be one of:\n  *: matches always\n  x: matches when the field equals x\n  x/y : matches when the field equals x+n*y where n is an integer\n  x-z: matches when the field is between x and z inclusive\n  w,x,y,...: matches when the field is one of the listed values\nEach x, y, z, ... is either a decimal integer, or a month or day of week name\nor abbreviation (in the appropriate fields).\nA timestamp matches if all fields match.\nNote that fields have different default values, for convenience.\nNote that the special case that some cron implementations have for treating\nday_of_month and day_of_week as \"or\" instead of \"and\" when both are set is\nnot implemented.\nday_of_week can accept 0 or 7 as Sunday\nCalendarSpec gets compiled into StructuredCalendarSpec, which is what will be\nreturned if you describe the schedule."
    },
    "v1Callback": {
      "type": "object",
      "properties": {
        "nexus": {
          "$ref": "#/definitions/CallbackNexus"
        },
        "internal": {
          "$ref": "#/definitions/CallbackInternal"
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links associated with the callback. It can be used to link to underlying resources of the\ncallback."
        }
      },
      "description": "Callback to attach to various events in the system, e.g. workflow run completion."
    },
    "v1CallbackInfo": {
      "type": "object",
      "properties": {
        "callback": {
          "$ref": "#/definitions/v1Callback",
          "description": "Information on how this callback should be invoked (e.g. its URL and type)."
        },
        "trigger": {
          "$ref": "#/definitions/CallbackInfoTrigger",
          "description": "Trigger for this callback."
        },
        "registrationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the callback was registered."
        },
        "state": {
          "$ref": "#/definitions/v1CallbackState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the callback.\nThis number represents a minimum bound since the attempt is incremented after the callback request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        },
        "blockedReason": {
          "type": "string",
          "description": "If the state is BLOCKED, blocked reason provides additional information."
        }
      },
      "description": "CallbackInfo contains the state of an attached workflow callback."
    },
    "v1CallbackState": {
      "type": "string",
      "enum": [
        "CALLBACK_STATE_UNSPECIFIED",
        "CALLBACK_STATE_STANDBY",
        "CALLBACK_STATE_SCHEDULED",
        "CALLBACK_STATE_BACKING_OFF",
        "CALLBACK_STATE_FAILED",
        "CALLBACK_STATE_SUCCEEDED",
        "CALLBACK_STATE_BLOCKED"
      ],
      "default": "CALLBACK_STATE_UNSPECIFIED",
      "description": "State of a callback.\n\n - CALLBACK_STATE_UNSPECIFIED: Default value, unspecified state.\n - CALLBACK_STATE_STANDBY: Callback is standing by, waiting to be triggered.\n - CALLBACK_STATE_SCHEDULED: Callback is in the queue waiting to be executed or is currently executing.\n - CALLBACK_STATE_BACKING_OFF: Callback has failed with a retryable error and is backing off before the next attempt.\n - CALLBACK_STATE_FAILED: Callback has failed.\n - CALLBACK_STATE_SUCCEEDED: Callback has succeeded.\n - CALLBACK_STATE_BLOCKED: Callback is blocked (eg: by circuit breaker)."
    },
    "v1CancelExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1CancelOperationRequest": {
      "type": "object",
      "properties": {
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Type of operation to cancel."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID as originally generated by a Handler.\n\nDeprecated. Renamed to operation_token."
        },
        "operationToken": {
          "type": "string",
          "description": "Operation token as originally generated by a Handler."
        }
      },
      "description": "A request to cancel an operation."
    },
    "v1CancelOperationResponse": {
      "type": "object",
      "description": "Response variant for CancelOperationRequest."
    },
    "v1CancelTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The same timer id from the start timer command"
        }
      }
    },
    "v1CancelWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1CanceledFailureInfo": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ChildWorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionFailureInfo": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ChildWorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1ChildWorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        }
      }
    },
    "v1ChildWorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        }
      }
    },
    "v1ClusterMetadata": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string",
          "description": "Name of the cluster name."
        },
        "clusterId": {
          "type": "string",
          "description": "Id of the cluster."
        },
        "address": {
          "type": "string",
          "description": "gRPC address."
        },
        "httpAddress": {
          "type": "string",
          "description": "HTTP address, if one exists."
        },
        "initialFailoverVersion": {
          "type": "string",
          "format": "int64",
          "description": "A unique failover version across all connected clusters."
        },
        "historyShardCount": {
          "type": "integer",
          "format": "int32",
          "description": "History service shard number."
        },
        "isConnectionEnabled": {
          "type": "boolean",
          "description": "A flag to indicate if a connection is active."
        }
      }
    },
    "v1ClusterReplicationConfig": {
      "type": "object",
      "properties": {
        "clusterName": {
          "type": "string"
        }
      }
    },
    "v1Command": {
      "type": "object",
      "properties": {
        "commandType": {
          "$ref": "#/definitions/v1CommandType"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the command. This is sometimes carried over to the history event if one is\ncreated as a result of the command. Most commands won't have this information, and how this\ninformation is used is dependent upon the interface that reads it.\n\nCurrent well-known uses:\n * start_child_workflow_execution_command_attributes - populates\n   temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details\n   are used by user interfaces to show fixed as-of-start workflow summary and details.\n * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer\n   started where the summary is used to identify the timer."
        },
        "scheduleActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1ScheduleActivityTaskCommandAttributes"
        },
        "startTimerCommandAttributes": {
          "$ref": "#/definitions/v1StartTimerCommandAttributes"
        },
        "completeWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CompleteWorkflowExecutionCommandAttributes"
        },
        "failWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1FailWorkflowExecutionCommandAttributes"
        },
        "requestCancelActivityTaskCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelActivityTaskCommandAttributes"
        },
        "cancelTimerCommandAttributes": {
          "$ref": "#/definitions/v1CancelTimerCommandAttributes"
        },
        "cancelWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1CancelWorkflowExecutionCommandAttributes"
        },
        "requestCancelExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionCommandAttributes"
        },
        "recordMarkerCommandAttributes": {
          "$ref": "#/definitions/v1RecordMarkerCommandAttributes"
        },
        "continueAsNewWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1ContinueAsNewWorkflowExecutionCommandAttributes"
        },
        "startChildWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionCommandAttributes"
        },
        "signalExternalWorkflowExecutionCommandAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionCommandAttributes"
        },
        "upsertWorkflowSearchAttributesCommandAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesCommandAttributes"
        },
        "protocolMessageCommandAttributes": {
          "$ref": "#/definitions/v1ProtocolMessageCommandAttributes"
        },
        "modifyWorkflowPropertiesCommandAttributes": {
          "$ref": "#/definitions/v1ModifyWorkflowPropertiesCommandAttributes",
          "title": "16 is available for use - it was used as part of a prototype that never made it into a release"
        },
        "scheduleNexusOperationCommandAttributes": {
          "$ref": "#/definitions/v1ScheduleNexusOperationCommandAttributes"
        },
        "requestCancelNexusOperationCommandAttributes": {
          "$ref": "#/definitions/v1RequestCancelNexusOperationCommandAttributes"
        }
      }
    },
    "v1CommandType": {
      "type": "string",
      "enum": [
        "COMMAND_TYPE_UNSPECIFIED",
        "COMMAND_TYPE_SCHEDULE_ACTIVITY_TASK",
        "COMMAND_TYPE_REQUEST_CANCEL_ACTIVITY_TASK",
        "COMMAND_TYPE_START_TIMER",
        "COMMAND_TYPE_COMPLETE_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_FAIL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_CANCEL_TIMER",
        "COMMAND_TYPE_CANCEL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_RECORD_MARKER",
        "COMMAND_TYPE_CONTINUE_AS_NEW_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_START_CHILD_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION",
        "COMMAND_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "COMMAND_TYPE_PROTOCOL_MESSAGE",
        "COMMAND_TYPE_MODIFY_WORKFLOW_PROPERTIES",
        "COMMAND_TYPE_SCHEDULE_NEXUS_OPERATION",
        "COMMAND_TYPE_REQUEST_CANCEL_NEXUS_OPERATION"
      ],
      "default": "COMMAND_TYPE_UNSPECIFIED",
      "description": "Whenever this list of command types is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering."
    },
    "v1CompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "sourceBuildId": {
          "type": "string"
        },
        "targetBuildId": {
          "type": "string",
          "description": "Target Build ID must be compatible with the Source Build ID; that is it\nmust be able to process event histories made by the Source Build ID by\nusing [Patching](https://docs.temporal.io/workflows#patching) or other\nmeans."
        }
      },
      "description": "These rules apply to tasks assigned to a particular Build ID\n(`source_build_id`) to redirect them to another *compatible* Build ID\n(`target_build_id`).\n\nIt is user's responsibility to ensure that the target Build ID is compatible\nwith the source Build ID (e.g. by using the Patching API).\n\nMost deployments are not expected to need these rules, however following\nsituations can greatly benefit from redirects:\n - Need to move long-running Workflow Executions from an old Build ID to a\n   newer one.\n - Need to hotfix some broken or stuck Workflow Executions.\n\nIn steady state, redirect rules are beneficial when dealing with old\nExecutions ran on now-decommissioned Build IDs:\n - To redirecting the Workflow Queries to the current (compatible) Build ID.\n - To be able to Reset an old Execution so it can run on the current\n   (compatible) Build ID.\n\nRedirect rules can be chained."
    },
    "v1CompatibleVersionSet": {
      "type": "object",
      "properties": {
        "buildIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "All the compatible versions, unordered, except for the last element, which is considered the set \"default\"."
        }
      },
      "description": "Used by the worker versioning APIs, represents an unordered set of one or more versions which are\nconsidered to be compatible with each other. Currently the versions are always worker build IDs."
    },
    "v1CompleteWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1ConfigMetadata": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "description": "Reason for why the config was set."
        },
        "updateIdentity": {
          "type": "string",
          "description": "Identity of the last updater.\nSet by the request's identity field."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time of the last update."
        }
      }
    },
    "v1ContinueAsNewInitiator": {
      "type": "string",
      "enum": [
        "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
        "CONTINUE_AS_NEW_INITIATOR_WORKFLOW",
        "CONTINUE_AS_NEW_INITIATOR_RETRY",
        "CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE"
      ],
      "default": "CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED",
      "title": "- CONTINUE_AS_NEW_INITIATOR_WORKFLOW: The workflow itself requested to continue as new\n - CONTINUE_AS_NEW_INITIATOR_RETRY: The workflow continued as new because it is retrying\n - CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE: The workflow continued as new because cron has triggered a new execution"
    },
    "v1ContinueAsNewWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "backoffStartInterval": {
          "type": "string",
          "description": "How long the workflow start will be delayed - not really a \"backoff\" in the traditional sense."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator",
          "title": "Should be removed"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Should be removed"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Should be removed"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Should be removed. Not necessarily unused but unclear and not exposed by SDKs."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the new execution inherits the Build ID of the current execution. Otherwise,\nthe assignment rules will be used to independently assign a Build ID to the new execution.\nDeprecated. Only considered for versioning v0.2."
        }
      }
    },
    "v1CountWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "count": {
          "type": "string",
          "format": "int64",
          "description": "If `query` is not grouping by any field, the count is an approximate number\nof workflows that matches the query.\nIf `query` is grouping by a field, the count is simply the sum of the counts\nof the groups returned in the response. This number can be smaller than the\ntotal number of workflows matching the query."
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/CountWorkflowExecutionsResponseAggregationGroup"
          },
          "description": "`groups` contains the groups if the request is grouping by a field.\nThe list might not be complete, and the counts of each group is approximate."
        }
      }
    },
    "v1CreateNexusEndpointRequest": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec",
          "description": "Endpoint definition to create."
        }
      }
    },
    "v1CreateNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint",
          "description": "Data post acceptance. Can be used to issue additional updates to this record."
        }
      }
    },
    "v1CreateScheduleResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1CreateWorkflowRuleResponse": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1WorkflowRule",
          "description": "Created rule."
        },
        "jobId": {
          "type": "string",
          "description": "Batch Job ID if force-scan flag was provided. Otherwise empty."
        }
      }
    },
    "v1DataBlob": {
      "type": "object",
      "properties": {
        "encodingType": {
          "$ref": "#/definitions/v1EncodingType"
        },
        "data": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1DeleteNamespaceResponse": {
      "type": "object",
      "properties": {
        "deletedNamespace": {
          "type": "string",
          "description": "Temporary namespace name that is used during reclaim resources step."
        }
      }
    },
    "v1DeleteNexusEndpointResponse": {
      "type": "object"
    },
    "v1DeleteScheduleResponse": {
      "type": "object"
    },
    "v1DeleteWorkerDeploymentResponse": {
      "type": "object"
    },
    "v1DeleteWorkerDeploymentVersionResponse": {
      "type": "object"
    },
    "v1DeleteWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1DeleteWorkflowRuleResponse": {
      "type": "object"
    },
    "v1Deployment": {
      "type": "object",
      "properties": {
        "seriesName": {
          "type": "string",
          "description": "Different versions of the same worker service/application are related together by having a\nshared series name.\nOut of all deployments of a series, one can be designated as the current deployment, which\nreceives new workflow executions and new tasks of workflows with\n`VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior."
        },
        "buildId": {
          "type": "string",
          "description": "Build ID changes with each version of the worker when the worker program code and/or config\nchanges."
        }
      },
      "description": "`Deployment` identifies a deployment of Temporal workers. The combination of deployment series\nname + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker\nprograms to specify these values.\nDeprecated."
    },
    "v1DeploymentInfo": {
      "type": "object",
      "properties": {
        "deployment": {
          "$ref": "#/definitions/v1Deployment"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "taskQueueInfos": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/DeploymentInfoTaskQueueInfo"
          }
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          },
          "description": "A user-defined set of key-values. Can be updated as part of write operations to the\ndeployment, such as `SetCurrentDeployment`."
        },
        "isCurrent": {
          "type": "boolean",
          "description": "If this deployment is the current deployment of its deployment series."
        }
      },
      "description": "`DeploymentInfo` holds information about a deployment. Deployment information is tracked\nautomatically by server as soon as the first poll from that deployment reaches the server. There\ncan be multiple task queue workers in a single deployment which are listed in this message.\nDeprecated."
    },
    "v1DeploymentListInfo": {
      "type": "object",
      "properties": {
        "deployment": {
          "$ref": "#/definitions/v1Deployment"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "isCurrent": {
          "type": "boolean",
          "description": "If this deployment is the current deployment of its deployment series."
        }
      },
      "description": "DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in\nListDeployments.\nDeprecated."
    },
    "v1DeploymentReachability": {
      "type": "string",
      "enum": [
        "DEPLOYMENT_REACHABILITY_UNSPECIFIED",
        "DEPLOYMENT_REACHABILITY_REACHABLE",
        "DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY",
        "DEPLOYMENT_REACHABILITY_UNREACHABLE"
      ],
      "default": "DEPLOYMENT_REACHABILITY_UNSPECIFIED",
      "description": "Specify the reachability level for a deployment so users can decide if it is time to\ndecommission the deployment.\n\n - DEPLOYMENT_REACHABILITY_UNSPECIFIED: Reachability level is not specified.\n - DEPLOYMENT_REACHABILITY_REACHABLE: The deployment is reachable by new and/or open workflows. The deployment cannot be\ndecommissioned safely.\n - DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY: The deployment is not reachable by new or open workflows, but might be still needed by\nQueries sent to closed workflows. The deployment can be decommissioned safely if user does\nnot query closed workflows.\n - DEPLOYMENT_REACHABILITY_UNREACHABLE: The deployment is not reachable by any workflow because all the workflows who needed this\ndeployment went out of retention period. The deployment can be decommissioned safely."
    },
    "v1DeploymentTransition": {
      "type": "object",
      "properties": {
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "The target deployment of the transition. Null means a so-far-versioned workflow is\ntransitioning to unversioned workers."
        }
      },
      "description": "Holds information about ongoing transition of a workflow execution from one deployment to another.\nDeprecated. Use DeploymentVersionTransition."
    },
    "v1DeploymentVersionTransition": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `deployment_version`."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The target Version of the transition.\nIf nil, a so-far-versioned workflow is transitioning to unversioned workers."
        }
      },
      "description": "Holds information about ongoing transition of a workflow execution from one worker\ndeployment version to another.\nExperimental. Might change in the future."
    },
    "v1DeprecateNamespaceResponse": {
      "type": "object",
      "description": "Deprecated."
    },
    "v1DescribeBatchOperationResponse": {
      "type": "object",
      "properties": {
        "operationType": {
          "$ref": "#/definitions/v1BatchOperationType",
          "title": "Batch operation type"
        },
        "jobId": {
          "type": "string",
          "title": "Batch job ID"
        },
        "state": {
          "$ref": "#/definitions/v1BatchOperationState",
          "title": "Batch operation state"
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation start time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time",
          "title": "Batch operation close time"
        },
        "totalOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Total operation count"
        },
        "completeOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Complete operation count"
        },
        "failureOperationCount": {
          "type": "string",
          "format": "int64",
          "title": "Failure operation count"
        },
        "identity": {
          "type": "string",
          "title": "Identity indicates the operator identity"
        },
        "reason": {
          "type": "string",
          "title": "Reason indicates the reason to stop a operation"
        }
      }
    },
    "v1DescribeDeploymentResponse": {
      "type": "object",
      "properties": {
        "deploymentInfo": {
          "$ref": "#/definitions/v1DeploymentInfo"
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "v1DescribeNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "failoverHistory": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1FailoverStatus"
          },
          "description": "Contains the historical state of failover_versions for the cluster, truncated to contain only the last N\nstates to ensure that the list does not grow unbounded."
        }
      }
    },
    "v1DescribeScheduleResponse": {
      "type": "object",
      "properties": {
        "schedule": {
          "$ref": "#/definitions/v1Schedule",
          "title": "The complete current schedule details. This may not match the schedule as\ncreated because:\n- some types of schedule specs may get compiled into others (e.g.\n  CronString into StructuredCalendarSpec)\n- some unspecified fields may be replaced by defaults\n- some fields in the state are modified automatically\n- the schedule may have been modified by UpdateSchedule or PatchSchedule"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleInfo",
          "description": "Extra schedule state info."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo",
          "description": "The memo and search attributes that the schedule was created with."
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateSchedule to ensure that the\nschedule was not modified between a Describe and an Update, which could\nlead to lost updates and other confusion."
        }
      }
    },
    "v1DescribeTaskQueueMode": {
      "type": "string",
      "enum": [
        "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
        "DESCRIBE_TASK_QUEUE_MODE_ENHANCED"
      ],
      "default": "DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED",
      "description": " - DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED: Unspecified means legacy behavior.\n - DESCRIBE_TASK_QUEUE_MODE_ENHANCED: Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info."
    },
    "v1DescribeTaskQueueResponse": {
      "type": "object",
      "properties": {
        "pollers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollerInfo"
          }
        },
        "stats": {
          "$ref": "#/definitions/v1TaskQueueStats",
          "description": "Statistics for the task queue.\nOnly set if `report_stats` is set on the request."
        },
        "statsByPriorityKey": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueStats"
          },
          "description": "Task queue stats breakdown by priority key. Only contains actively used priority keys.\nOnly set if `report_stats` is set on the request."
        },
        "versioningInfo": {
          "$ref": "#/definitions/v1TaskQueueVersioningInfo",
          "description": "Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.\nWhen not present, it means the tasks are routed to Unversioned workers (workers with\nUNVERSIONED or unspecified WorkerVersioningMode.)\nTask Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion\nand SetWorkerDeploymentRampingVersion on Worker Deployments.\nNote: This information is not relevant to Pinned workflow executions and their activities as\nthey are always routed to their Pinned Deployment Version. However, new workflow executions\nare typically not Pinned until they complete their first task (unless they are started with\na Pinned VersioningOverride or are Child Workflows of a Pinned parent)."
        },
        "config": {
          "$ref": "#/definitions/v1TaskQueueConfig",
          "description": "Only populated if report_task_queue_config is set to true."
        },
        "effectiveRateLimit": {
          "$ref": "#/definitions/DescribeTaskQueueResponseEffectiveRateLimit"
        },
        "taskQueueStatus": {
          "$ref": "#/definitions/v1TaskQueueStatus",
          "description": "Deprecated.\nStatus of the task queue. Only populated when `include_task_queue_status` is set to true in the request."
        },
        "versionsInfo": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueVersionInfo"
          },
          "description": "Deprecated.\nOnly returned in ENHANCED mode.\nThis map contains Task Queue information for each Build ID. Empty string as key value means unversioned."
        }
      }
    },
    "v1DescribeWorkerDeploymentResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value is returned so that it can be optionally passed to APIs\nthat write to the Worker Deployment state to ensure that the state\ndid not change between this read and a future write."
        },
        "workerDeploymentInfo": {
          "$ref": "#/definitions/v1WorkerDeploymentInfo"
        }
      }
    },
    "v1DescribeWorkerDeploymentVersionResponse": {
      "type": "object",
      "properties": {
        "workerDeploymentVersionInfo": {
          "$ref": "#/definitions/v1WorkerDeploymentVersionInfo"
        },
        "versionTaskQueues": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/DescribeWorkerDeploymentVersionResponseVersionTaskQueue"
          },
          "description": "All the Task Queues that have ever polled from this Deployment version."
        }
      }
    },
    "v1DescribeWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "executionConfig": {
          "$ref": "#/definitions/v1WorkflowExecutionConfig"
        },
        "workflowExecutionInfo": {
          "$ref": "#/definitions/v1WorkflowExecutionInfo"
        },
        "pendingActivities": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingActivityInfo"
          }
        },
        "pendingChildren": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingChildExecutionInfo"
          }
        },
        "pendingWorkflowTask": {
          "$ref": "#/definitions/v1PendingWorkflowTaskInfo"
        },
        "callbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CallbackInfo"
          }
        },
        "pendingNexusOperations": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PendingNexusOperationInfo"
          }
        },
        "workflowExtendedInfo": {
          "$ref": "#/definitions/v1WorkflowExecutionExtendedInfo"
        }
      }
    },
    "v1DescribeWorkflowRuleResponse": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1WorkflowRule",
          "description": "The rule that was read."
        }
      }
    },
    "v1EncodingType": {
      "type": "string",
      "enum": [
        "ENCODING_TYPE_UNSPECIFIED",
        "ENCODING_TYPE_PROTO3",
        "ENCODING_TYPE_JSON"
      ],
      "default": "ENCODING_TYPE_UNSPECIFIED"
    },
    "v1Endpoint": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "format": "int64",
          "description": "Data version for this endpoint, incremented for every update issued via the UpdateNexusEndpoint API."
        },
        "id": {
          "type": "string",
          "description": "Unique server-generated endpoint ID."
        },
        "spec": {
          "$ref": "#/definitions/v1EndpointSpec",
          "description": "Spec for the endpoint."
        },
        "createdTime": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time when the endpoint was created."
        },
        "lastModifiedTime": {
          "type": "string",
          "format": "date-time",
          "description": "The date and time when the endpoint was last modified.\nWill not be set if the endpoint has never been modified."
        },
        "urlPrefix": {
          "type": "string",
          "description": "Server exposed URL prefix for invocation of operations on this endpoint.\nThis doesn't include the protocol, hostname or port as the server does not know how it should be accessed\npublicly. The URL is stable in the face of endpoint renames."
        }
      },
      "description": "A cluster-global binding from an endpoint ID to a target for dispatching incoming Nexus requests."
    },
    "v1EndpointSpec": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Endpoint name, unique for this cluster. Must match `[a-zA-Z_][a-zA-Z0-9_]*`.\nRenaming an endpoint breaks all workflow callers that reference this endpoint, causing operations to fail."
        },
        "description": {
          "$ref": "#/definitions/v1Payload",
          "description": "Markdown description serialized as a single JSON string.\nIf the Payload is encrypted, the UI and CLI may decrypt with the configured codec server endpoint.\nBy default, the server enforces a limit of 20,000 bytes for this entire payload."
        },
        "target": {
          "$ref": "#/definitions/v1EndpointTarget",
          "description": "Target to route requests to."
        }
      },
      "description": "Contains mutable fields for an Endpoint."
    },
    "v1EndpointTarget": {
      "type": "object",
      "properties": {
        "worker": {
          "$ref": "#/definitions/EndpointTargetWorker"
        },
        "external": {
          "$ref": "#/definitions/EndpointTargetExternal"
        }
      },
      "description": "Target to route requests to."
    },
    "v1EventType": {
      "type": "string",
      "enum": [
        "EVENT_TYPE_UNSPECIFIED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_SCHEDULED",
        "EVENT_TYPE_WORKFLOW_TASK_STARTED",
        "EVENT_TYPE_WORKFLOW_TASK_COMPLETED",
        "EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT",
        "EVENT_TYPE_WORKFLOW_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_SCHEDULED",
        "EVENT_TYPE_ACTIVITY_TASK_STARTED",
        "EVENT_TYPE_ACTIVITY_TASK_COMPLETED",
        "EVENT_TYPE_ACTIVITY_TASK_FAILED",
        "EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT",
        "EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED",
        "EVENT_TYPE_ACTIVITY_TASK_CANCELED",
        "EVENT_TYPE_TIMER_STARTED",
        "EVENT_TYPE_TIMER_FIRED",
        "EVENT_TYPE_TIMER_CANCELED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED",
        "EVENT_TYPE_MARKER_RECORDED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT",
        "EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED",
        "EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED",
        "EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED",
        "EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY",
        "EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED",
        "EVENT_TYPE_NEXUS_OPERATION_SCHEDULED",
        "EVENT_TYPE_NEXUS_OPERATION_STARTED",
        "EVENT_TYPE_NEXUS_OPERATION_COMPLETED",
        "EVENT_TYPE_NEXUS_OPERATION_FAILED",
        "EVENT_TYPE_NEXUS_OPERATION_CANCELED",
        "EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT",
        "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED",
        "EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED",
        "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED",
        "EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED"
      ],
      "default": "EVENT_TYPE_UNSPECIFIED",
      "description": "- EVENT_TYPE_UNSPECIFIED: Place holder and should never appear in a Workflow execution history\n - EVENT_TYPE_WORKFLOW_EXECUTION_STARTED: Workflow execution has been triggered/started\nIt contains Workflow execution inputs, as well as Workflow timeout configurations\n - EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED: Workflow execution has successfully completed and contains Workflow execution results\n - EVENT_TYPE_WORKFLOW_EXECUTION_FAILED: Workflow execution has unsuccessfully completed and contains the Workflow execution error\n - EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT: Workflow execution has timed out by the Temporal Server\nUsually due to the Workflow having not been completed within timeout settings\n - EVENT_TYPE_WORKFLOW_TASK_SCHEDULED: Workflow Task has been scheduled and the SDK client should now be able to process any new history events\n - EVENT_TYPE_WORKFLOW_TASK_STARTED: Workflow Task has started and the SDK client has picked up the Workflow Task and is processing new history events\n - EVENT_TYPE_WORKFLOW_TASK_COMPLETED: Workflow Task has completed\nThe SDK client picked up the Workflow Task and processed new history events\nSDK client may or may not ask the Temporal Server to do additional work, such as:\nEVENT_TYPE_ACTIVITY_TASK_SCHEDULED\nEVENT_TYPE_TIMER_STARTED\nEVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES\nEVENT_TYPE_MARKER_RECORDED\nEVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED\nEVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED\nEVENT_TYPE_WORKFLOW_EXECUTION_FAILED\nEVENT_TYPE_WORKFLOW_EXECUTION_CANCELED\nEVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW\n - EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT: Workflow Task encountered a timeout\nEither an SDK client with a local cache was not available at the time, or it took too long for the SDK client to process the task\n - EVENT_TYPE_WORKFLOW_TASK_FAILED: Workflow Task encountered a failure\nUsually this means that the Workflow was non-deterministic\nHowever, the Workflow reset functionality also uses this event\n - EVENT_TYPE_ACTIVITY_TASK_SCHEDULED: Activity Task was scheduled\nThe SDK client should pick up this activity task and execute\nThis event type contains activity inputs, as well as activity timeout configurations\n - EVENT_TYPE_ACTIVITY_TASK_STARTED: Activity Task has started executing\nThe SDK client has picked up the Activity Task and is processing the Activity invocation\n - EVENT_TYPE_ACTIVITY_TASK_COMPLETED: Activity Task has finished successfully\nThe SDK client has picked up and successfully completed the Activity Task\nThis event type contains Activity execution results\n - EVENT_TYPE_ACTIVITY_TASK_FAILED: Activity Task has finished unsuccessfully\nThe SDK picked up the Activity Task but unsuccessfully completed it\nThis event type contains Activity execution errors\n - EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT: Activity has timed out according to the Temporal Server\nActivity did not complete within the timeout settings\n - EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED: A request to cancel the Activity has occurred\nThe SDK client will be able to confirm cancellation of an Activity during an Activity heartbeat\n - EVENT_TYPE_ACTIVITY_TASK_CANCELED: Activity has been cancelled\n - EVENT_TYPE_TIMER_STARTED: A timer has started\n - EVENT_TYPE_TIMER_FIRED: A timer has fired\n - EVENT_TYPE_TIMER_CANCELED: A time has been cancelled\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED: A request has been made to cancel the Workflow execution\n - EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED: SDK client has confirmed the cancellation request and the Workflow execution has been cancelled\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Workflow has requested that the Temporal Server try to cancel another Workflow\n - EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server could not cancel the targeted Workflow\nThis is usually because the target Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED: Temporal Server has successfully requested the cancellation of the target Workflow\n - EVENT_TYPE_MARKER_RECORDED: A marker has been recorded.\nThis event type is transparent to the Temporal Server\nThe Server will only store it and will not try to understand it.\n - EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED: Workflow has received a Signal event\nThe event type contains the Signal name, as well as a Signal payload\n - EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED: Workflow execution has been forcefully terminated\nThis is usually because the terminate Workflow API was called\n - EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW: Workflow has successfully completed and a new Workflow has been started within the same transaction\nContains last Workflow execution results as well as new Workflow execution inputs\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to start a child Workflow\n - EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution cannot be started/triggered\nUsually due to a child Workflow ID collision\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED: Child Workflow execution has successfully started/triggered\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED: Child Workflow execution has successfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED: Child Workflow execution has unsuccessfully completed\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED: Child Workflow execution has been cancelled\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT: Child Workflow execution has timed out by the Temporal Server\n - EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED: Child Workflow execution has been terminated\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED: Temporal Server will try to Signal the targeted Workflow\nContains the Signal name, as well as a Signal payload\n - EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED: Temporal Server cannot Signal the targeted Workflow\nUsually because the Workflow could not be found\n - EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED: Temporal Server has successfully Signaled the targeted Workflow\n - EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES: Workflow search attributes should be updated and synchronized with the visibility store\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ADMITTED: An update was admitted. Note that not all admitted updates result in this\nevent. See UpdateAdmittedEventOrigin for situations in which this event\nis created.\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_ACCEPTED: An update was accepted (i.e. passed validation, perhaps because no validator was defined)\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_REJECTED: This event is never written to history.\n - EVENT_TYPE_WORKFLOW_EXECUTION_UPDATE_COMPLETED: An update completed\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of the workflow as a whole have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_ACTIVITY_PROPERTIES_MODIFIED_EXTERNALLY: Some property or properties of an already-scheduled activity have changed by non-workflow code.\nThe distinction of external vs. command-based modification is important so the SDK can\nmaintain determinism when using the command-based approach.\n - EVENT_TYPE_WORKFLOW_PROPERTIES_MODIFIED: Workflow properties modified by user workflow code\n - EVENT_TYPE_NEXUS_OPERATION_SCHEDULED: A Nexus operation was scheduled using a ScheduleNexusOperation command.\n - EVENT_TYPE_NEXUS_OPERATION_STARTED: An asynchronous Nexus operation was started by a Nexus handler.\n - EVENT_TYPE_NEXUS_OPERATION_COMPLETED: A Nexus operation completed successfully.\n - EVENT_TYPE_NEXUS_OPERATION_FAILED: A Nexus operation failed.\n - EVENT_TYPE_NEXUS_OPERATION_CANCELED: A Nexus operation completed as canceled.\n - EVENT_TYPE_NEXUS_OPERATION_TIMED_OUT: A Nexus operation timed out.\n - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUESTED: A Nexus operation was requested to be canceled using a RequestCancelNexusOperation command.\n - EVENT_TYPE_WORKFLOW_EXECUTION_OPTIONS_UPDATED: Workflow execution options updated by user.\n - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_COMPLETED: A cancellation request for a Nexus operation was successfully delivered to the Nexus handler.\n - EVENT_TYPE_NEXUS_OPERATION_CANCEL_REQUEST_FAILED: A cancellation request for a Nexus operation resulted in an error.",
      "title": "Whenever this list of events is changed do change the function shouldBufferEvent in mutableStateBuilder.go to make sure to do the correct event ordering"
    },
    "v1ExecuteMultiOperationResponse": {
      "type": "object",
      "properties": {
        "responses": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ExecuteMultiOperationResponseResponse"
          }
        }
      },
      "description": "IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination (\"Update-with-Start\") when both\n  1. the workflow update for the requested update ID has already completed, and\n  2. the workflow for the requested workflow ID has already been closed,\nthen you'll receive\n  - an update response containing the update's outcome, and\n  - a start response with a `status` field that reflects the workflow's current state."
    },
    "v1ExecuteMultiOperationResponseResponse": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1StartWorkflowExecutionResponse"
        },
        "updateWorkflow": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionResponse"
        }
      }
    },
    "v1ExternalWorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds\nto"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-cancelled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        }
      }
    },
    "v1ExternalWorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which was signaled.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        }
      }
    },
    "v1FailWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      }
    },
    "v1FailoverStatus": {
      "type": "object",
      "properties": {
        "failoverTime": {
          "type": "string",
          "format": "date-time",
          "title": "Timestamp when the Cluster switched to the following failover_version"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        }
      },
      "title": "Represents a historical replication status of a Namespace"
    },
    "v1FetchWorkerConfigResponse": {
      "type": "object",
      "properties": {
        "workerConfig": {
          "$ref": "#/definitions/v1WorkerConfig",
          "description": "The worker configuration."
        }
      }
    },
    "v1GetClusterInfoResponse": {
      "type": "object",
      "properties": {
        "supportedClients": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Key is client name i.e \"temporal-go\", \"temporal-java\", or \"temporal-cli\".\nValue is ranges of supported versions of this client i.e \">1.1.1 <=1.4.0 || ^5.0.0\"."
        },
        "serverVersion": {
          "type": "string"
        },
        "clusterId": {
          "type": "string"
        },
        "versionInfo": {
          "$ref": "#/definitions/v1VersionInfo"
        },
        "clusterName": {
          "type": "string"
        },
        "historyShardCount": {
          "type": "integer",
          "format": "int32"
        },
        "persistenceStore": {
          "type": "string"
        },
        "visibilityStore": {
          "type": "string"
        }
      },
      "description": "GetClusterInfoResponse contains information about Temporal cluster."
    },
    "v1GetCurrentDeploymentResponse": {
      "type": "object",
      "properties": {
        "currentDeploymentInfo": {
          "$ref": "#/definitions/v1DeploymentInfo"
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "v1GetDeploymentReachabilityResponse": {
      "type": "object",
      "properties": {
        "deploymentInfo": {
          "$ref": "#/definitions/v1DeploymentInfo"
        },
        "reachability": {
          "$ref": "#/definitions/v1DeploymentReachability"
        },
        "lastUpdateTime": {
          "type": "string",
          "format": "date-time",
          "description": "Reachability level might come from server cache. This timestamp specifies when the value\nwas actually calculated."
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "v1GetNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint"
        }
      }
    },
    "v1GetSearchAttributesResponse": {
      "type": "object",
      "properties": {
        "keys": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          }
        }
      }
    },
    "v1GetSystemInfoResponse": {
      "type": "object",
      "properties": {
        "serverVersion": {
          "type": "string",
          "description": "Version of the server."
        },
        "capabilities": {
          "$ref": "#/definitions/v1GetSystemInfoResponseCapabilities",
          "description": "All capabilities the system supports."
        }
      }
    },
    "v1GetSystemInfoResponseCapabilities": {
      "type": "object",
      "properties": {
        "signalAndQueryHeader": {
          "type": "boolean",
          "description": "True if signal and query headers are supported."
        },
        "internalErrorDifferentiation": {
          "type": "boolean",
          "description": "True if internal errors are differentiated from other types of errors for purposes of\nretrying non-internal errors.\n\nWhen unset/false, clients retry all failures. When true, clients should only retry\nnon-internal errors."
        },
        "activityFailureIncludeHeartbeat": {
          "type": "boolean",
          "title": "True if RespondActivityTaskFailed API supports including heartbeat details"
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Supports scheduled workflow features."
        },
        "encodedFailureAttributes": {
          "type": "boolean",
          "title": "True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes"
        },
        "buildIdBasedVersioning": {
          "type": "boolean",
          "title": "True if server supports dispatching Workflow and Activity tasks based on a worker's build_id\n(see:\nhttps://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)"
        },
        "upsertMemo": {
          "type": "boolean",
          "title": "True if server supports upserting workflow memo"
        },
        "eagerWorkflowStart": {
          "type": "boolean",
          "title": "True if server supports eager workflow task dispatching for the StartWorkflowExecution API"
        },
        "sdkMetadata": {
          "type": "boolean",
          "title": "True if the server knows about the sdk metadata field on WFT completions and will record\nit in history"
        },
        "countGroupByExecutionStatus": {
          "type": "boolean",
          "title": "True if the server supports count group by execution status"
        },
        "nexus": {
          "type": "boolean",
          "description": "True if the server supports Nexus operations.\nThis flag is dependent both on server version and for Nexus to be enabled via server configuration."
        }
      },
      "description": "System capability details."
    },
    "v1GetWorkerBuildIdCompatibilityResponse": {
      "type": "object",
      "properties": {
        "majorVersionSets": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CompatibleVersionSet"
          },
          "description": "Major version sets, in order from oldest to newest. The last element of the list will always\nbe the current default major version. IE: New workflows will target the most recent version\nin that version set.\n\nThere may be fewer sets returned than exist, if the request chose to limit this response."
        }
      },
      "title": "[cleanup-wv-pre-release]"
    },
    "v1GetWorkerTaskReachabilityResponse": {
      "type": "object",
      "properties": {
        "buildIdReachability": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BuildIdReachability"
          },
          "description": "Task reachability, broken down by build id and then task queue.\nWhen requesting a large number of task queues or all task queues associated with the given build ids in a\nnamespace, all task queues will be listed in the response but some of them may not contain reachability\ninformation due to a server enforced limit. When reaching the limit, task queues that reachability information\ncould not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue\nanother call to get the reachability for those task queues.\n\nOpen source users can adjust this limit by setting the server's dynamic config value for\n`limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store."
        }
      },
      "description": "[cleanup-wv-pre-release]\nDeprecated. Use `DescribeTaskQueue`."
    },
    "v1GetWorkerVersioningRulesResponse": {
      "type": "object",
      "properties": {
        "assignmentRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedBuildIdAssignmentRule"
          }
        },
        "compatibleRedirectRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedCompatibleBuildIdRedirectRule"
          }
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateWorkerVersioningRulesRequest to\nensure that the rules were not modified between this List and the Update,\nwhich could lead to lost updates and other confusion."
        }
      },
      "title": "[cleanup-wv-pre-release]"
    },
    "v1GetWorkflowExecutionHistoryResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "rawHistory": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1DataBlob"
          },
          "description": "Raw history is an alternate representation of history that may be returned if configured on\nthe frontend. This is not supported by all SDKs. Either this or `history` will be set."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        },
        "archived": {
          "type": "boolean"
        }
      }
    },
    "v1GetWorkflowExecutionHistoryReverseResponse": {
      "type": "object",
      "properties": {
        "history": {
          "$ref": "#/definitions/v1History"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Will be set if there are more history events than were included in this response"
        }
      }
    },
    "v1HandlerError": {
      "type": "object",
      "properties": {
        "errorType": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors."
        },
        "failure": {
          "$ref": "#/definitions/apinexusv1Failure"
        },
        "retryBehavior": {
          "$ref": "#/definitions/v1NexusHandlerErrorRetryBehavior",
          "description": "Retry behavior, defaults to the retry behavior of the error type as defined in the spec."
        }
      }
    },
    "v1Header": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "Contains metadata that can be attached to a variety of requests, like starting a workflow, and\ncan be propagated between, for example, workflows and activities."
    },
    "v1History": {
      "type": "object",
      "properties": {
        "events": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1HistoryEvent"
          }
        }
      }
    },
    "v1HistoryEvent": {
      "type": "object",
      "properties": {
        "eventId": {
          "type": "string",
          "format": "int64",
          "description": "Monotonically increasing event number, starts at 1."
        },
        "eventTime": {
          "type": "string",
          "format": "date-time"
        },
        "eventType": {
          "$ref": "#/definitions/v1EventType"
        },
        "version": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "taskId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: What is this? Appears unused by SDKs"
        },
        "workerMayIgnore": {
          "type": "boolean",
          "description": "Set to true when the SDK may ignore the event as it does not impact workflow state or\ninformation in any way that the SDK need be concerned with. If an SDK encounters an event\ntype which it does not understand, it must error unless this is true. If it is true, it's\nacceptable for the event type and/or attributes to be uninterpretable."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the event. This is often carried over from commands and client calls. Most events\nwon't have this information, and how this information is used is dependent upon the interface\nthat reads it.\n\nCurrent well-known uses:\n * workflow_execution_started_event_attributes - summary and details from start workflow.\n * timer_started_event_attributes - summary represents an identifier for the timer for use by\n   user interfaces."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links associated with the event."
        },
        "workflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionStartedEventAttributes"
        },
        "workflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCompletedEventAttributes"
        },
        "workflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionFailedEventAttributes"
        },
        "workflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTimedOutEventAttributes"
        },
        "workflowTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskScheduledEventAttributes"
        },
        "workflowTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskStartedEventAttributes"
        },
        "workflowTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskCompletedEventAttributes"
        },
        "workflowTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskTimedOutEventAttributes"
        },
        "workflowTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowTaskFailedEventAttributes"
        },
        "activityTaskScheduledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskScheduledEventAttributes"
        },
        "activityTaskStartedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskStartedEventAttributes"
        },
        "activityTaskCompletedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCompletedEventAttributes"
        },
        "activityTaskFailedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskFailedEventAttributes"
        },
        "activityTaskTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskTimedOutEventAttributes"
        },
        "timerStartedEventAttributes": {
          "$ref": "#/definitions/v1TimerStartedEventAttributes"
        },
        "timerFiredEventAttributes": {
          "$ref": "#/definitions/v1TimerFiredEventAttributes"
        },
        "activityTaskCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCancelRequestedEventAttributes"
        },
        "activityTaskCanceledEventAttributes": {
          "$ref": "#/definitions/v1ActivityTaskCanceledEventAttributes"
        },
        "timerCanceledEventAttributes": {
          "$ref": "#/definitions/v1TimerCanceledEventAttributes"
        },
        "markerRecordedEventAttributes": {
          "$ref": "#/definitions/v1MarkerRecordedEventAttributes"
        },
        "workflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionSignaledEventAttributes"
        },
        "workflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionTerminatedEventAttributes"
        },
        "workflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionCanceledEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "requestCancelExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1RequestCancelExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionCancelRequestedEventAttributes"
        },
        "workflowExecutionContinuedAsNewEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionContinuedAsNewEventAttributes"
        },
        "startChildWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionInitiatedEventAttributes"
        },
        "startChildWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionStartedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionStartedEventAttributes"
        },
        "childWorkflowExecutionCompletedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCompletedEventAttributes"
        },
        "childWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionFailedEventAttributes"
        },
        "childWorkflowExecutionCanceledEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionCanceledEventAttributes"
        },
        "childWorkflowExecutionTimedOutEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTimedOutEventAttributes"
        },
        "childWorkflowExecutionTerminatedEventAttributes": {
          "$ref": "#/definitions/v1ChildWorkflowExecutionTerminatedEventAttributes"
        },
        "signalExternalWorkflowExecutionInitiatedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionInitiatedEventAttributes"
        },
        "signalExternalWorkflowExecutionFailedEventAttributes": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedEventAttributes"
        },
        "externalWorkflowExecutionSignaledEventAttributes": {
          "$ref": "#/definitions/v1ExternalWorkflowExecutionSignaledEventAttributes"
        },
        "upsertWorkflowSearchAttributesEventAttributes": {
          "$ref": "#/definitions/v1UpsertWorkflowSearchAttributesEventAttributes"
        },
        "workflowExecutionUpdateAcceptedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateAcceptedEventAttributes"
        },
        "workflowExecutionUpdateRejectedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateRejectedEventAttributes"
        },
        "workflowExecutionUpdateCompletedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateCompletedEventAttributes"
        },
        "workflowPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedExternallyEventAttributes"
        },
        "activityPropertiesModifiedExternallyEventAttributes": {
          "$ref": "#/definitions/v1ActivityPropertiesModifiedExternallyEventAttributes"
        },
        "workflowPropertiesModifiedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowPropertiesModifiedEventAttributes"
        },
        "workflowExecutionUpdateAdmittedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionUpdateAdmittedEventAttributes"
        },
        "nexusOperationScheduledEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationScheduledEventAttributes"
        },
        "nexusOperationStartedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationStartedEventAttributes"
        },
        "nexusOperationCompletedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCompletedEventAttributes"
        },
        "nexusOperationFailedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationFailedEventAttributes"
        },
        "nexusOperationCanceledEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCanceledEventAttributes"
        },
        "nexusOperationTimedOutEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationTimedOutEventAttributes"
        },
        "nexusOperationCancelRequestedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCancelRequestedEventAttributes"
        },
        "workflowExecutionOptionsUpdatedEventAttributes": {
          "$ref": "#/definitions/v1WorkflowExecutionOptionsUpdatedEventAttributes"
        },
        "nexusOperationCancelRequestCompletedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCancelRequestCompletedEventAttributes"
        },
        "nexusOperationCancelRequestFailedEventAttributes": {
          "$ref": "#/definitions/v1NexusOperationCancelRequestFailedEventAttributes"
        }
      },
      "description": "History events are the method by which Temporal SDKs advance (or recreate) workflow state.\nSee the `EventType` enum for more info about what each event is for."
    },
    "v1HistoryEventFilterType": {
      "type": "string",
      "enum": [
        "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED",
        "HISTORY_EVENT_FILTER_TYPE_ALL_EVENT",
        "HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT"
      ],
      "default": "HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED"
    },
    "v1IndexedValueType": {
      "type": "string",
      "enum": [
        "INDEXED_VALUE_TYPE_UNSPECIFIED",
        "INDEXED_VALUE_TYPE_TEXT",
        "INDEXED_VALUE_TYPE_KEYWORD",
        "INDEXED_VALUE_TYPE_INT",
        "INDEXED_VALUE_TYPE_DOUBLE",
        "INDEXED_VALUE_TYPE_BOOL",
        "INDEXED_VALUE_TYPE_DATETIME",
        "INDEXED_VALUE_TYPE_KEYWORD_LIST"
      ],
      "default": "INDEXED_VALUE_TYPE_UNSPECIFIED"
    },
    "v1Input": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed with the Update from the requesting entity.\nThese can include things like auth or tracing tokens."
        },
        "name": {
          "type": "string",
          "description": "The name of the Update handler to invoke on the target Workflow."
        },
        "args": {
          "$ref": "#/definitions/v1Payloads",
          "description": "The arguments to pass to the named Update handler."
        }
      }
    },
    "v1IntervalSpec": {
      "type": "object",
      "properties": {
        "interval": {
          "type": "string"
        },
        "phase": {
          "type": "string"
        }
      },
      "description": "IntervalSpec matches times that can be expressed as:\nepoch + n * interval + phase\nwhere n is an integer.\nphase defaults to zero if missing. interval is required.\nBoth interval and phase must be non-negative and are truncated to the nearest\nsecond before any calculations.\nFor example, an interval of 1 hour with phase of zero would match every hour,\non the hour. The same interval but a phase of 19 minutes would match every\nxx:19:00. An interval of 28 days with phase zero would match\n2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3\ndays, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead."
    },
    "v1ListArchivedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListBatchOperationsResponse": {
      "type": "object",
      "properties": {
        "operationInfo": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BatchOperationInfo"
          },
          "title": "BatchOperationInfo contains the basic info about batch operation"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListClosedWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListClustersResponse": {
      "type": "object",
      "properties": {
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterMetadata"
          },
          "title": "List of all cluster information"
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListDeploymentsResponse": {
      "type": "object",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        },
        "deployments": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1DeploymentListInfo"
          }
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "v1ListNamespacesResponse": {
      "type": "object",
      "properties": {
        "namespaces": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1DescribeNamespaceResponse"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListNexusEndpointsResponse": {
      "type": "object",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "description": "Token for getting the next page."
        },
        "endpoints": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Endpoint"
          }
        }
      }
    },
    "v1ListOpenWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListScheduleMatchingTimesResponse": {
      "type": "object",
      "properties": {
        "startTime": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      }
    },
    "v1ListSchedulesResponse": {
      "type": "object",
      "properties": {
        "schedules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleListEntry"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListSearchAttributesResponse": {
      "type": "object",
      "properties": {
        "customAttributes": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          },
          "description": "Mapping between custom (user-registered) search attribute name to its IndexedValueType."
        },
        "systemAttributes": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1IndexedValueType"
          },
          "description": "Mapping between system (predefined) search attribute name to its IndexedValueType."
        },
        "storageSchema": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Mapping from the attribute name to the visibility storage native type."
        }
      }
    },
    "v1ListTaskQueuePartitionsResponse": {
      "type": "object",
      "properties": {
        "activityTaskQueuePartitions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        },
        "workflowTaskQueuePartitions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TaskQueuePartitionMetadata"
          }
        }
      }
    },
    "v1ListWorkerDeploymentsResponse": {
      "type": "object",
      "properties": {
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        },
        "workerDeployments": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ListWorkerDeploymentsResponseWorkerDeploymentSummary"
          },
          "description": "The list of worker deployments."
        }
      }
    },
    "v1ListWorkersResponse": {
      "type": "object",
      "properties": {
        "workersInfo": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkerInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "title": "Next page token"
        }
      }
    },
    "v1ListWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1ListWorkflowRulesResponse": {
      "type": "object",
      "properties": {
        "rules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowRule"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      }
    },
    "v1MarkerRecordedEventAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string",
          "description": "Workers use this to identify the \"types\" of various markers. Ex: Local activity, side effect."
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          },
          "title": "Serialized information recorded in the marker"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Some uses of markers, like a local activity, could \"fail\". If they did that is recorded here."
        }
      }
    },
    "v1Memo": {
      "type": "object",
      "properties": {
        "fields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "A user-defined set of *unindexed* fields that are exposed when listing/searching workflows"
    },
    "v1Message": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "An ID for this specific message."
        },
        "protocolInstanceId": {
          "type": "string",
          "description": "Identifies the specific instance of a protocol to which this message\nbelongs."
        },
        "eventId": {
          "type": "string",
          "format": "int64"
        },
        "commandIndex": {
          "type": "string",
          "format": "int64"
        },
        "body": {
          "$ref": "#/definitions/protobufAny",
          "description": "The opaque data carried by this message. The protocol type can be\nextracted from the package name of the message carried inside the Any."
        }
      }
    },
    "v1Meta": {
      "type": "object",
      "properties": {
        "updateId": {
          "type": "string",
          "description": "An ID with workflow-scoped uniqueness for this Update."
        },
        "identity": {
          "type": "string",
          "description": "A string identifying the agent that requested this Update."
        }
      },
      "description": "Metadata about a Workflow Update."
    },
    "v1MeteringMetadata": {
      "type": "object",
      "properties": {
        "nonfirstLocalActivityExecutionAttempts": {
          "type": "integer",
          "format": "int64",
          "description": "Count of local activities which have begun an execution attempt during this workflow task,\nand whose first attempt occurred in some previous task. This is used for metering\npurposes, and does not affect workflow state.\n"
        }
      },
      "title": "Metadata relevant for metering purposes"
    },
    "v1ModifyWorkflowPropertiesCommandAttributes": {
      "type": "object",
      "properties": {
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1NamespaceConfig": {
      "type": "object",
      "properties": {
        "workflowExecutionRetentionTtl": {
          "type": "string"
        },
        "badBinaries": {
          "$ref": "#/definitions/v1BadBinaries"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        },
        "customSearchAttributeAliases": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Map from field name to alias."
        }
      }
    },
    "v1NamespaceFilter": {
      "type": "object",
      "properties": {
        "includeDeleted": {
          "type": "boolean",
          "description": "By default namespaces in NAMESPACE_STATE_DELETED state are not included.\nSetting include_deleted to true will include deleted namespaces.\nNote: Namespace is in NAMESPACE_STATE_DELETED state when it was deleted from the system but associated data is not deleted yet."
        }
      }
    },
    "v1NamespaceInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "id": {
          "type": "string"
        },
        "capabilities": {
          "$ref": "#/definitions/v1NamespaceInfoCapabilities",
          "description": "All capabilities the namespace supports."
        },
        "supportsSchedules": {
          "type": "boolean",
          "description": "Whether scheduled workflows are supported on this namespace. This is only needed\ntemporarily while the feature is experimental, so we can give it a high tag."
        }
      }
    },
    "v1NamespaceInfoCapabilities": {
      "type": "object",
      "properties": {
        "eagerWorkflowStart": {
          "type": "boolean",
          "description": "True if the namespace supports eager workflow start."
        },
        "syncUpdate": {
          "type": "boolean",
          "title": "True if the namespace supports sync update"
        },
        "asyncUpdate": {
          "type": "boolean",
          "title": "True if the namespace supports async update"
        }
      },
      "description": "Namespace capability details. Should contain what features are enabled in a namespace."
    },
    "v1NamespaceReplicationConfig": {
      "type": "object",
      "properties": {
        "activeClusterName": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "state": {
          "$ref": "#/definitions/v1ReplicationState"
        }
      }
    },
    "v1NamespaceState": {
      "type": "string",
      "enum": [
        "NAMESPACE_STATE_UNSPECIFIED",
        "NAMESPACE_STATE_REGISTERED",
        "NAMESPACE_STATE_DEPRECATED",
        "NAMESPACE_STATE_DELETED"
      ],
      "default": "NAMESPACE_STATE_UNSPECIFIED"
    },
    "v1NewWorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\nTo unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      },
      "description": "NewWorkflowExecutionInfo is a shared message that encapsulates all the\nrequired arguments to starting a workflow in different contexts."
    },
    "v1NexusHandlerErrorRetryBehavior": {
      "type": "string",
      "enum": [
        "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED",
        "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE",
        "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE"
      ],
      "default": "NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_UNSPECIFIED",
      "description": "NexusHandlerErrorRetryBehavior allows nexus handlers to explicity set the retry behavior of a HandlerError. If not\nspecified, retry behavior is determined from the error type. For example internal errors are not retryable by default\nunless specified otherwise.\n\n - NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_RETRYABLE: A handler error is explicitly marked as retryable.\n - NEXUS_HANDLER_ERROR_RETRY_BEHAVIOR_NON_RETRYABLE: A handler error is explicitly marked as non-retryable."
    },
    "v1NexusHandlerFailureInfo": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "description": "The Nexus error type as defined in the spec:\nhttps://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors."
        },
        "retryBehavior": {
          "$ref": "#/definitions/v1NexusHandlerErrorRetryBehavior",
          "description": "Retry behavior, defaults to the retry behavior of the error type as defined in the spec."
        }
      }
    },
    "v1NexusOperationCancelRequestCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "requestedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\nwith."
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to."
        }
      }
    },
    "v1NexusOperationCancelRequestFailedEventAttributes": {
      "type": "object",
      "properties": {
        "requestedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\nwith."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo."
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to."
        }
      }
    },
    "v1NexusOperationCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported\nwith."
        }
      }
    },
    "v1NexusOperationCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Cancellation details."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow."
    },
    "v1NexusOperationCancellationInfo": {
      "type": "object",
      "properties": {
        "requestedTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when cancellation was requested."
        },
        "state": {
          "$ref": "#/definitions/v1NexusOperationCancellationState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the cancel operation request.\nThis number represents a minimum bound since the attempt is incremented after the request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        },
        "blockedReason": {
          "type": "string",
          "description": "If the state is BLOCKED, blocked reason provides additional information."
        }
      },
      "description": "NexusOperationCancellationInfo contains the state of a nexus operation cancellation."
    },
    "v1NexusOperationCancellationState": {
      "type": "string",
      "enum": [
        "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
        "NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED",
        "NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF",
        "NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED",
        "NEXUS_OPERATION_CANCELLATION_STATE_FAILED",
        "NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT",
        "NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED"
      ],
      "default": "NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED",
      "description": "State of a Nexus operation cancellation.\n\n - NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED: Default value, unspecified state.\n - NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED: Cancellation request is in the queue waiting to be executed or is currently executing.\n - NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF: Cancellation request has failed with a retryable error and is backing off before the next attempt.\n - NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED: Cancellation request succeeded.\n - NEXUS_OPERATION_CANCELLATION_STATE_FAILED: Cancellation request failed with a non-retryable error.\n - NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT: The associated operation timed out - exceeded the user supplied schedule-to-close timeout.\n - NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED: Cancellation request is blocked (eg: by circuit breaker)."
    },
    "v1NexusOperationCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "result": {
          "$ref": "#/definitions/v1Payload",
          "description": "Serialized result of the Nexus operation. The response of the Nexus handler.\nDelivered either via a completion callback or as a response to a synchronous operation."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation completed successfully."
    },
    "v1NexusOperationFailedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation failed."
    },
    "v1NexusOperationFailureInfo": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The NexusOperationScheduled event ID."
        },
        "endpoint": {
          "type": "string",
          "description": "Endpoint name."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID - may be empty if the operation completed synchronously.\n\nDeprecated. Renamed to operation_token."
        },
        "operationToken": {
          "type": "string",
          "description": "Operation token - may be empty if the operation completed synchronously."
        }
      }
    },
    "v1NexusOperationScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name, must exist in the endpoint registry."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "input": {
          "$ref": "#/definitions/v1Payload",
          "description": "Input for the operation. The server converts this into Nexus request content and the appropriate content headers\ninternally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the\ncontent is transformed back to the original Payload stored in this event."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nIndicates how long the caller is willing to wait for operation completion.\nCalls are retried internally by the server."
        },
        "nexusHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal\nactivities and child workflows, these are transmitted to Nexus operations that may be external and are not\ntraditional payloads."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with."
        },
        "requestId": {
          "type": "string",
          "description": "A unique ID generated by the history service upon creation of this event.\nThe ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key."
        },
        "endpointId": {
          "type": "string",
          "description": "Endpoint ID as resolved in the endpoint registry at the time this event was generated.\nThis is stored on the event and used internally by the server in case the endpoint is renamed from the time the\nevent was originally scheduled."
        }
      },
      "description": "Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command."
    },
    "v1NexusOperationStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to."
        },
        "operationId": {
          "type": "string",
          "description": "The operation ID returned by the Nexus handler in the response to the StartOperation request.\nThis ID is used when canceling the operation.\n\nDeprecated: Renamed to operation_token."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        },
        "operationToken": {
          "type": "string",
          "description": "The operation token returned by the Nexus handler in the response to the StartOperation request.\nThis token is used when canceling the operation."
        }
      },
      "description": "Event marking an asynchronous operation was started by the responding Nexus handler.\nIf the operation completes synchronously, this event is not generated.\nIn rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate\nthis event upon receiving the operation completion via callback."
    },
    "v1NexusOperationTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo."
        },
        "requestId": {
          "type": "string",
          "description": "The request ID allocated at schedule time."
        }
      },
      "description": "Nexus operation timed out."
    },
    "v1OnConflictOptions": {
      "type": "object",
      "properties": {
        "attachRequestId": {
          "type": "boolean",
          "description": "Attaches the request ID to the running workflow."
        },
        "attachCompletionCallbacks": {
          "type": "boolean",
          "description": "Attaches the completion callbacks to the running workflow."
        },
        "attachLinks": {
          "type": "boolean",
          "description": "Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event."
        }
      },
      "description": "When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and\nthere is already an existing running workflow, OnConflictOptions defines actions to be taken on\nthe existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent\nhistory event in the running workflow with the changes requested in this object."
    },
    "v1Outcome": {
      "type": "object",
      "properties": {
        "success": {
          "$ref": "#/definitions/v1Payloads"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      },
      "description": "The outcome of a Workflow Update: success or failure."
    },
    "v1ParentClosePolicy": {
      "type": "string",
      "enum": [
        "PARENT_CLOSE_POLICY_UNSPECIFIED",
        "PARENT_CLOSE_POLICY_TERMINATE",
        "PARENT_CLOSE_POLICY_ABANDON",
        "PARENT_CLOSE_POLICY_REQUEST_CANCEL"
      ],
      "default": "PARENT_CLOSE_POLICY_UNSPECIFIED",
      "description": "- PARENT_CLOSE_POLICY_TERMINATE: The child workflow will also terminate\n - PARENT_CLOSE_POLICY_ABANDON: The child workflow will do nothing\n - PARENT_CLOSE_POLICY_REQUEST_CANCEL: Cancellation will be requested of the child workflow",
      "title": "Defines how child workflows will react to their parent completing"
    },
    "v1PatchScheduleResponse": {
      "type": "object"
    },
    "v1PauseActivityResponse": {
      "type": "object"
    },
    "v1Payload": {
      "description": "Arbitrary payload data in an unconstrained format.\nThis may be activity input parameters, a workflow result, a memo, etc.\n"
    },
    "v1Payloads": {
      "type": "object",
      "properties": {
        "payloads": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "title": "See `Payload`"
    },
    "v1PendingActivityInfo": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "state": {
          "$ref": "#/definitions/v1PendingActivityState"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        },
        "lastHeartbeatTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastStartedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "expirationTime": {
          "type": "string",
          "format": "date-time"
        },
        "lastFailure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "lastWorkerIdentity": {
          "type": "string"
        },
        "useWorkflowBuildId": {
          "type": "object",
          "properties": {},
          "description": "Deprecated. When present, it means this activity is assigned to the build ID of its workflow."
        },
        "lastIndependentlyAssignedBuildId": {
          "type": "string",
          "description": "Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.\nThe activity will use the build id in this field instead.\nIf the task fails and is scheduled again, the assigned build ID may change according to the latest versioning\nrules."
        },
        "lastWorkerVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Deprecated. The version stamp of the worker to whom this activity was most recently dispatched\nThis field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "currentRetryInterval": {
          "type": "string",
          "description": "The time activity will wait until the next retry.\nIf activity is currently running it will be next retry interval if activity failed.\nIf activity is currently waiting it will be current retry interval.\nIf there will be no retry it will be null."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last activity attempt was completed. If activity has not been completed yet then it will be null."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "Next time when activity will be scheduled.\nIf activity is currently scheduled or started it will be null."
        },
        "paused": {
          "type": "boolean",
          "description": "Indicates if activity is paused."
        },
        "lastDeployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "The deployment this activity was dispatched to most recently. Present only if the activity\nwas dispatched to a versioned worker.\nDeprecated. Use `last_deployment_version`."
        },
        "lastWorkerDeploymentVersion": {
          "type": "string",
          "description": "The Worker Deployment Version this activity was dispatched to most recently.\nDeprecated. Use `last_deployment_version`."
        },
        "lastDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The Worker Deployment Version this activity was dispatched to most recently.\nIf nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        },
        "pauseInfo": {
          "$ref": "#/definitions/PendingActivityInfoPauseInfo"
        },
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "description": "Current activity options. May be different from the one used to start the activity."
        }
      }
    },
    "v1PendingActivityState": {
      "type": "string",
      "enum": [
        "PENDING_ACTIVITY_STATE_UNSPECIFIED",
        "PENDING_ACTIVITY_STATE_SCHEDULED",
        "PENDING_ACTIVITY_STATE_STARTED",
        "PENDING_ACTIVITY_STATE_CANCEL_REQUESTED",
        "PENDING_ACTIVITY_STATE_PAUSED",
        "PENDING_ACTIVITY_STATE_PAUSE_REQUESTED"
      ],
      "default": "PENDING_ACTIVITY_STATE_UNSPECIFIED",
      "title": "- PENDING_ACTIVITY_STATE_PAUSED: PAUSED means activity is paused on the server, and is not running in the worker\n - PENDING_ACTIVITY_STATE_PAUSE_REQUESTED: PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server"
    },
    "v1PendingChildExecutionInfo": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "workflowTypeName": {
          "type": "string"
        },
        "initiatedId": {
          "type": "string",
          "format": "int64"
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        }
      }
    },
    "v1PendingNexusOperationInfo": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name.\nResolved to a URL via the cluster's endpoint registry."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "operationId": {
          "type": "string",
          "description": "Operation ID. Only set for asynchronous operations after a successful StartOperation call.\n\nDeprecated. Renamed to operation_token."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nThis is the only timeout settable by a workflow."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the operation was scheduled."
        },
        "state": {
          "$ref": "#/definitions/v1PendingNexusOperationState"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "The number of attempts made to deliver the start operation request.\nThis number represents a minimum bound since the attempt is incremented after the request completes."
        },
        "lastAttemptCompleteTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the last attempt completed."
        },
        "lastAttemptFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The last attempt's failure, if any."
        },
        "nextAttemptScheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "The time when the next attempt is scheduled."
        },
        "cancellationInfo": {
          "$ref": "#/definitions/v1NexusOperationCancellationInfo"
        },
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the\nDescribeWorkflowExecution response with workflow history."
        },
        "blockedReason": {
          "type": "string",
          "description": "If the state is BLOCKED, blocked reason provides additional information."
        },
        "operationToken": {
          "type": "string",
          "description": "Operation token. Only set for asynchronous operations after a successful StartOperation call."
        }
      },
      "description": "PendingNexusOperationInfo contains the state of a pending Nexus operation."
    },
    "v1PendingNexusOperationState": {
      "type": "string",
      "enum": [
        "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
        "PENDING_NEXUS_OPERATION_STATE_SCHEDULED",
        "PENDING_NEXUS_OPERATION_STATE_BACKING_OFF",
        "PENDING_NEXUS_OPERATION_STATE_STARTED",
        "PENDING_NEXUS_OPERATION_STATE_BLOCKED"
      ],
      "default": "PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED",
      "description": "State of a pending Nexus operation.\n\n - PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED: Default value, unspecified state.\n - PENDING_NEXUS_OPERATION_STATE_SCHEDULED: Operation is in the queue waiting to be executed or is currently executing.\n - PENDING_NEXUS_OPERATION_STATE_BACKING_OFF: Operation has failed with a retryable error and is backing off before the next attempt.\n - PENDING_NEXUS_OPERATION_STATE_STARTED: Operation was started and will complete asynchronously.\n - PENDING_NEXUS_OPERATION_STATE_BLOCKED: Operation is blocked (eg: by circuit breaker)."
    },
    "v1PendingWorkflowTaskInfo": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/v1PendingWorkflowTaskState"
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time"
        },
        "originalScheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.\nHeartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command\nIn this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds\nsome threshold, the workflow task will be forced timeout."
        },
        "startedTime": {
          "type": "string",
          "format": "date-time"
        },
        "attempt": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "v1PendingWorkflowTaskState": {
      "type": "string",
      "enum": [
        "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED",
        "PENDING_WORKFLOW_TASK_STATE_SCHEDULED",
        "PENDING_WORKFLOW_TASK_STATE_STARTED"
      ],
      "default": "PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED"
    },
    "v1PluginInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the plugin, required."
        },
        "version": {
          "type": "string",
          "description": "The version of the plugin, may be empty."
        }
      }
    },
    "v1PollActivityTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowNamespace": {
          "type": "string",
          "title": "The namespace the workflow which requested this activity lives in"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "Type of the requesting workflow"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "Execution info of the requesting workflow"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "activityId": {
          "type": "string",
          "description": "The autogenerated or user specified identifier of this activity. Can be used to complete the\nactivity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage\nhas resolved, but unique IDs for every activity invocation is a good idea."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers specified by the scheduling workflow. Commonly used to propagate contextual info\nfrom the workflow to its activities. For example, tracing contexts."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Arguments to the activity invocation"
        },
        "heartbeatDetails": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Details of the last heartbeat that was recorded for this activity as of the time this task\nwas delivered."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task first scheduled"
        },
        "currentAttemptScheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task attempt scheduled"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "title": "When was this task started (this attempt)"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of attempts to perform this activity"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "title": "First scheduled -> final result reported timeout"
        },
        "startToCloseTimeout": {
          "type": "string",
          "title": "Current attempt start -> final result reported timeout"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Window within which the activity must report a heartbeat, or be timed out."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "This is the retry policy the service uses which may be different from the one provided\n(or not) during activity scheduling. The service can override the provided one if some\nvalues are not specified or exceed configured system limits."
        },
        "pollerScalingDecision": {
          "$ref": "#/definitions/v1PollerScalingDecision",
          "description": "Server-advised information the SDK may use to adjust its poller count."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      }
    },
    "v1PollNexusTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "description": "An opaque unique identifier for this task for correlating a completion request the embedded request."
        },
        "request": {
          "$ref": "#/definitions/apinexusv1Request",
          "description": "Embedded request as translated from the incoming frontend request."
        },
        "pollerScalingDecision": {
          "$ref": "#/definitions/v1PollerScalingDecision",
          "description": "Server-advised information the SDK may use to adjust its poller count."
        }
      }
    },
    "v1PollWorkflowExecutionUpdateResponse": {
      "type": "object",
      "properties": {
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of the update if and only if the update has completed. If\nthis response is being returned before the update has completed (e.g. due\nto the specification of a wait policy that only waits on\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will\nnot be set."
        },
        "stage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "The most advanced lifecycle stage that the Update is known to have\nreached, where lifecycle stages are ordered\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.\nUNSPECIFIED will be returned if and only if the server's maximum wait\ntime was reached before the Update reached the stage specified in the\nrequest WaitPolicy, and before the context deadline expired; clients may\nmay then retry the call as needed."
        },
        "updateRef": {
          "$ref": "#/definitions/v1UpdateRef",
          "description": "Sufficient information to address this Update."
        }
      }
    },
    "v1PollWorkflowTaskQueueResponse": {
      "type": "object",
      "properties": {
        "taskToken": {
          "type": "string",
          "format": "byte",
          "title": "A unique identifier for this task"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "previousStartedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The last workflow task started event which was processed by some worker for this execution.\nWill be zero if no task has ever started."
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The id of the most recent workflow task started event, which will have been generated as a\nresult of this poll request being served. Will be zero if the task\ndoes not contain any events which would advance history (no new WFT started).\nCurrently this can happen for queries."
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "description": "Starting at 1, the number of attempts to complete this task by any worker."
        },
        "backlogCountHint": {
          "type": "string",
          "format": "int64",
          "description": "A hint that there are more tasks already present in this task queue\npartition. Can be used to prioritize draining a sticky queue.\n\nSpecifically, the returned number is the number of tasks remaining in\nthe in-memory buffer for this partition, which is currently capped at\n1000. Because sticky queues only have one partition, this number is\nmore useful when draining them. Normal queues, typically having more than one\npartition, will return a number representing only some portion of the\noverall backlog. Subsequent RPCs may not hit the same partition as\nthis call."
        },
        "history": {
          "$ref": "#/definitions/v1History",
          "description": "The history for this workflow, which will either be complete or partial. Partial histories\nare sent to workers who have signaled that they are using a sticky queue when completing\na workflow task."
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte",
          "description": "Will be set if there are more history events than were included in this response. Such events\nshould be fetched via `GetWorkflowExecutionHistory`."
        },
        "query": {
          "$ref": "#/definitions/v1WorkflowQuery",
          "description": "Legacy queries appear in this field. The query must be responded to via\n`RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on\nclosed workflows) then the `history` field will be populated with the entire history. It\nmay also be populated if this task originates on a non-sticky queue."
        },
        "workflowExecutionTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "description": "The task queue this task originated from, which will always be the original non-sticky name\nfor the queue, even if this response came from polling a sticky queue."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "title": "When this task was scheduled by the server"
        },
        "startedTime": {
          "type": "string",
          "format": "date-time",
          "description": "When the current workflow task started event was generated, meaning the current attempt."
        },
        "queries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1WorkflowQuery"
          },
          "title": "Queries that should be executed after applying the history in this task. Responses should be\nattached to `RespondWorkflowTaskCompletedRequest::query_results`"
        },
        "messages": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Message"
          },
          "title": "Protocol messages piggybacking on a WFT as a transport"
        },
        "pollerScalingDecision": {
          "$ref": "#/definitions/v1PollerScalingDecision",
          "description": "Server-advised information the SDK may use to adjust its poller count."
        }
      }
    },
    "v1PollerInfo": {
      "type": "object",
      "properties": {
        "lastAccessTime": {
          "type": "string",
          "format": "date-time"
        },
        "identity": {
          "type": "string"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "workerVersionCapabilities": {
          "$ref": "#/definitions/v1WorkerVersionCapabilities",
          "description": "If a worker has opted into the worker versioning feature while polling, its capabilities will\nappear here.\nDeprecated. Replaced by deployment_options."
        },
        "deploymentOptions": {
          "$ref": "#/definitions/v1WorkerDeploymentOptions",
          "description": "Worker deployment options that SDK sent to server."
        }
      }
    },
    "v1PollerScalingDecision": {
      "type": "object",
      "properties": {
        "pollRequestDeltaSuggestion": {
          "type": "integer",
          "format": "int32",
          "description": "How many poll requests to suggest should be added or removed, if any. As of now, server only\nscales up or down by 1. However, SDKs should allow for other values (while staying within\ndefined min/max).\n\nThe SDK is free to ignore this suggestion, EX: making more polls would not make sense because\nall slots are already occupied."
        }
      },
      "description": "Attached to task responses to give hints to the SDK about how it may adjust its number of\npollers."
    },
    "v1PostResetOperation": {
      "type": "object",
      "properties": {
        "signalWorkflow": {
          "$ref": "#/definitions/PostResetOperationSignalWorkflow"
        },
        "updateWorkflowOptions": {
          "$ref": "#/definitions/PostResetOperationUpdateWorkflowOptions"
        }
      },
      "description": "PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset."
    },
    "v1Priority": {
      "type": "object",
      "properties": {
        "priorityKey": {
          "type": "integer",
          "format": "int32",
          "description": "Priority key is a positive integer from 1 to n, where smaller integers\ncorrespond to higher priorities (tasks run sooner). In general, tasks in\na queue should be processed in close to priority order, although small\ndeviations are possible.\n\nThe maximum priority value (minimum priority) is determined by server\nconfiguration, and defaults to 5.\n\nIf priority is not present (or zero), then the effective priority will be\nthe default priority, which is is calculated by (min+max)/2. With the\ndefault max of 5, and min of 1, that comes out to 3."
        },
        "fairnessKey": {
          "type": "string",
          "description": "Fairness key is a short string that's used as a key for a fairness\nbalancing mechanism. It may correspond to a tenant id, or to a fixed\nstring like \"high\" or \"low\". The default is the empty string.\n\nThe fairness mechanism attempts to dispatch tasks for a given key in\nproportion to its weight. For example, using a thousand distinct tenant\nids, each with a weight of 1.0 (the default) will result in each tenant\ngetting a roughly equal share of task dispatch throughput.\n\n(Note: this does not imply equal share of worker capacity! Fairness\ndecisions are made based on queue statistics, not\ncurrent worker load.)\n\nAs another example, using keys \"high\" and \"low\" with weight 9.0 and 1.0\nrespectively will prefer dispatching \"high\" tasks over \"low\" tasks at a\n9:1 ratio, while allowing either key to use all worker capacity if the\nother is not present.\n\nAll fairness mechanisms, including rate limits, are best-effort and\nprobabilistic. The results may not match what a \"perfect\" algorithm with\ninfinite resources would produce. The more unique keys are used, the less\naccurate the results will be.\n\nFairness keys are limited to 64 bytes."
        },
        "fairnessWeight": {
          "type": "number",
          "format": "float",
          "description": "Fairness weight for a task can come from multiple sources for\nflexibility. From highest to lowest precedence:\n1. Weights for a small set of keys can be overridden in task queue\n   configuration with an API.\n2. It can be attached to the workflow/activity in this field.\n3. The default weight of 1.0 will be used.\n\nWeight values are clamped to the range [0.001, 1000]."
        }
      },
      "description": "Priority contains metadata that controls relative ordering of task processing\nwhen tasks are backed up in a queue. Initially, Priority will be used in\nmatching (workflow and activity) task queues. Later it may be used in history\ntask queues and in rate limiting decisions.\n\nPriority is attached to workflows and activities. By default, activities\ninherit Priority from the workflow that created them, but may override fields\nwhen an activity is started or modified.\n\nDespite being named \"Priority\", this message also contains fields that\ncontrol \"fairness\" mechanisms.\n\nFor all fields, the field not present or equal to zero/empty string means to\ninherit the value from the calling workflow, or if there is no calling\nworkflow, then use the default value.\n\nFor all fields other than fairness_key, the zero value isn't meaningful so\nthere's no confusion between inherit/default and a meaningful value. For\nfairness_key, the empty string will be interpreted as \"inherit\". This means\nthat if a workflow has a non-empty fairness key, you can't override the\nfairness key of its activity to the empty string.\n\nThe overall semantics of Priority are:\n1. First, consider \"priority\": higher priority (lower number) goes first.\n2. Then, consider fairness: try to dispatch tasks for different fairness keys\n   in proportion to their weight.\n\nApplications may use any subset of mechanisms that are useful to them and\nleave the other fields to use default values.\n\nNot all queues in the system may support the \"full\" semantics of all priority\nfields. (Currently only support in matching task queues is planned.)"
    },
    "v1ProtocolMessageCommandAttributes": {
      "type": "object",
      "properties": {
        "messageId": {
          "type": "string",
          "description": "The message ID of the message to which this command is a pointer."
        }
      }
    },
    "v1QueryRejectCondition": {
      "type": "string",
      "enum": [
        "QUERY_REJECT_CONDITION_UNSPECIFIED",
        "QUERY_REJECT_CONDITION_NONE",
        "QUERY_REJECT_CONDITION_NOT_OPEN",
        "QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY"
      ],
      "default": "QUERY_REJECT_CONDITION_UNSPECIFIED",
      "description": " - QUERY_REJECT_CONDITION_NONE: None indicates that query should not be rejected.\n - QUERY_REJECT_CONDITION_NOT_OPEN: NotOpen indicates that query should be rejected if workflow is not open.\n - QUERY_REJECT_CONDITION_NOT_COMPLETED_CLEANLY: NotCompletedCleanly indicates that query should be rejected if workflow did not complete cleanly."
    },
    "v1QueryRejected": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1QueryResultType": {
      "type": "string",
      "enum": [
        "QUERY_RESULT_TYPE_UNSPECIFIED",
        "QUERY_RESULT_TYPE_ANSWERED",
        "QUERY_RESULT_TYPE_FAILED"
      ],
      "default": "QUERY_RESULT_TYPE_UNSPECIFIED"
    },
    "v1QueryWorkflowResponse": {
      "type": "object",
      "properties": {
        "queryResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "queryRejected": {
          "$ref": "#/definitions/v1QueryRejected"
        }
      }
    },
    "v1RampByPercentage": {
      "type": "object",
      "properties": {
        "rampPercentage": {
          "type": "number",
          "format": "float",
          "description": "Acceptable range is [0,100)."
        }
      }
    },
    "v1Range": {
      "type": "object",
      "properties": {
        "start": {
          "type": "integer",
          "format": "int32",
          "description": "Start of range (inclusive)."
        },
        "end": {
          "type": "integer",
          "format": "int32",
          "description": "End of range (inclusive)."
        },
        "step": {
          "type": "integer",
          "format": "int32",
          "description": "Step (optional, default 1)."
        }
      },
      "description": "Range represents a set of integer values, used to match fields of a calendar\ntime in StructuredCalendarSpec. If end < start, then end is interpreted as\nequal to start. This means you can use a Range with start set to a value, and\nend and step unset (defaulting to 0) to represent a single value."
    },
    "v1RateLimit": {
      "type": "object",
      "properties": {
        "requestsPerSecond": {
          "type": "number",
          "format": "float",
          "description": "Zero is a valid rate limit."
        }
      }
    },
    "v1RateLimitConfig": {
      "type": "object",
      "properties": {
        "rateLimit": {
          "$ref": "#/definitions/v1RateLimit"
        },
        "metadata": {
          "$ref": "#/definitions/v1ConfigMetadata"
        }
      }
    },
    "v1RateLimitSource": {
      "type": "string",
      "enum": [
        "RATE_LIMIT_SOURCE_UNSPECIFIED",
        "RATE_LIMIT_SOURCE_API",
        "RATE_LIMIT_SOURCE_WORKER",
        "RATE_LIMIT_SOURCE_SYSTEM"
      ],
      "default": "RATE_LIMIT_SOURCE_UNSPECIFIED",
      "description": "Source for the effective rate limit.\n\n - RATE_LIMIT_SOURCE_API: The value was set by the API.\n - RATE_LIMIT_SOURCE_WORKER: The value was set by a worker.\n - RATE_LIMIT_SOURCE_SYSTEM: The value was set as the system default."
    },
    "v1RecordActivityTaskHeartbeatByIdResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        },
        "activityPaused": {
          "type": "boolean",
          "description": "Will be set to true if the activity is paused."
        },
        "activityReset": {
          "type": "boolean",
          "description": "Will be set to true if the activity was reset.\nApplies only to the current run."
        }
      }
    },
    "v1RecordActivityTaskHeartbeatResponse": {
      "type": "object",
      "properties": {
        "cancelRequested": {
          "type": "boolean",
          "description": "Will be set to true if the activity has been asked to cancel itself. The SDK should then\nnotify the activity of cancellation if it is still running."
        },
        "activityPaused": {
          "type": "boolean",
          "description": "Will be set to true if the activity is paused."
        },
        "activityReset": {
          "type": "boolean",
          "description": "Will be set to true if the activity was reset.\nApplies only to the current run."
        }
      }
    },
    "v1RecordMarkerCommandAttributes": {
      "type": "object",
      "properties": {
        "markerName": {
          "type": "string"
        },
        "details": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payloads"
          }
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure"
        }
      }
    },
    "v1RecordWorkerHeartbeatResponse": {
      "type": "object"
    },
    "v1RegisterNamespaceRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "workflowExecutionRetentionPeriod": {
          "type": "string"
        },
        "clusters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ClusterReplicationConfig"
          }
        },
        "activeClusterName": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose."
        },
        "securityToken": {
          "type": "string"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        },
        "historyArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "historyArchivalUri": {
          "type": "string"
        },
        "visibilityArchivalState": {
          "$ref": "#/definitions/v1ArchivalState",
          "description": "If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used."
        },
        "visibilityArchivalUri": {
          "type": "string"
        }
      }
    },
    "v1RegisterNamespaceResponse": {
      "type": "object"
    },
    "v1ReleaseInfo": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string"
        },
        "releaseTime": {
          "type": "string",
          "format": "date-time"
        },
        "notes": {
          "type": "string"
        }
      },
      "description": "ReleaseInfo contains information about specific version of temporal."
    },
    "v1RemoveRemoteClusterResponse": {
      "type": "object"
    },
    "v1RemoveSearchAttributesResponse": {
      "type": "object"
    },
    "v1ReplicationState": {
      "type": "string",
      "enum": [
        "REPLICATION_STATE_UNSPECIFIED",
        "REPLICATION_STATE_NORMAL",
        "REPLICATION_STATE_HANDOVER"
      ],
      "default": "REPLICATION_STATE_UNSPECIFIED"
    },
    "v1RequestCancelActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled."
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1CancelExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed to cancel.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure\ncorresponds to"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        }
      }
    },
    "v1RequestCancelExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "The namespace the workflow to be cancelled lives in.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "reason": {
          "type": "string",
          "title": "Reason for requesting the cancellation"
        }
      }
    },
    "v1RequestCancelNexusOperationCommandAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "description": "The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.\nThe operation may ignore cancellation and end up with any completion state."
        }
      }
    },
    "v1RequestCancelWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1RequestIdInfo": {
      "type": "object",
      "properties": {
        "eventType": {
          "$ref": "#/definitions/v1EventType",
          "description": "The event type of the history event generated by the request."
        },
        "eventId": {
          "type": "string",
          "format": "int64",
          "description": "The event id of the history event generated by the request. It's possible the event ID is not\nknown (unflushed buffered event). In this case, the value will be zero or a negative value,\nrepresenting an invalid ID."
        },
        "buffered": {
          "type": "boolean",
          "description": "Indicate if the request is still buffered. If so, the event ID is not known and its value\nwill be an invalid event ID."
        }
      },
      "description": "RequestIdInfo contains details of a request ID."
    },
    "v1ResetActivityResponse": {
      "type": "object"
    },
    "v1ResetOptions": {
      "type": "object",
      "properties": {
        "firstWorkflowTask": {
          "type": "object",
          "properties": {},
          "description": "Resets to the first workflow task completed or started event."
        },
        "lastWorkflowTask": {
          "type": "object",
          "properties": {},
          "description": "Resets to the last workflow task completed or started event."
        },
        "workflowTaskId": {
          "type": "string",
          "format": "int64",
          "description": "The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or\n`WORKFLOW_TASK_STARTED` event to reset to.\nNote that this option doesn't make sense when used as part of a batch request."
        },
        "buildId": {
          "type": "string",
          "description": "Resets to the first workflow task processed by this build id.\nIf the workflow was not processed by the build id, or the workflow task can't be\ndetermined, no reset will be performed.\nNote that by default, this reset is allowed to be to a prior run in a chain of\ncontinue-as-new."
        },
        "resetReapplyType": {
          "$ref": "#/definitions/v1ResetReapplyType",
          "title": "Deprecated. Use `options`.\nDefault: RESET_REAPPLY_TYPE_SIGNAL"
        },
        "currentRunOnly": {
          "type": "boolean",
          "title": "If true, limit the reset to only within the current run. (Applies to build_id targets and\npossibly others in the future.)"
        },
        "resetReapplyExcludeTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1ResetReapplyExcludeType"
          },
          "title": "Event types not to be reapplied"
        }
      },
      "description": "Describes where and how to reset a workflow, used for batch reset currently\nand may be used for single-workflow reset later."
    },
    "v1ResetPointInfo": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "Worker build id."
        },
        "binaryChecksum": {
          "type": "string",
          "description": "Deprecated. A worker binary version identifier."
        },
        "runId": {
          "type": "string",
          "description": "The first run ID in the execution chain that was touched by this worker build."
        },
        "firstWorkflowTaskCompletedId": {
          "type": "string",
          "format": "int64",
          "description": "Event ID of the first WorkflowTaskCompleted event processed by this worker build."
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "expireTime": {
          "type": "string",
          "format": "date-time",
          "description": "\nThe time that the run is deleted due to retention."
        },
        "resettable": {
          "type": "boolean",
          "description": "false if the reset point has pending childWFs/reqCancels/signalExternals."
        }
      },
      "description": "ResetPointInfo records the workflow event id that is the first one processed by a given\nbuild id or binary checksum. A new reset point will be created if either build id or binary\nchecksum changes (although in general only one or the other will be used at a time)."
    },
    "v1ResetPoints": {
      "type": "object",
      "properties": {
        "points": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ResetPointInfo"
          }
        }
      }
    },
    "v1ResetReapplyExcludeType": {
      "type": "string",
      "enum": [
        "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
        "RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL",
        "RESET_REAPPLY_EXCLUDE_TYPE_UPDATE",
        "RESET_REAPPLY_EXCLUDE_TYPE_NEXUS",
        "RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST"
      ],
      "default": "RESET_REAPPLY_EXCLUDE_TYPE_UNSPECIFIED",
      "description": "Event types to exclude when reapplying events beyond the reset point.\n\n - RESET_REAPPLY_EXCLUDE_TYPE_SIGNAL: Exclude signals when reapplying events beyond the reset point.\n - RESET_REAPPLY_EXCLUDE_TYPE_UPDATE: Exclude updates when reapplying events beyond the reset point.\n - RESET_REAPPLY_EXCLUDE_TYPE_NEXUS: Exclude nexus events when reapplying events beyond the reset point.\n - RESET_REAPPLY_EXCLUDE_TYPE_CANCEL_REQUEST: Deprecated, unimplemented option."
    },
    "v1ResetReapplyType": {
      "type": "string",
      "enum": [
        "RESET_REAPPLY_TYPE_UNSPECIFIED",
        "RESET_REAPPLY_TYPE_SIGNAL",
        "RESET_REAPPLY_TYPE_NONE",
        "RESET_REAPPLY_TYPE_ALL_ELIGIBLE"
      ],
      "default": "RESET_REAPPLY_TYPE_UNSPECIFIED",
      "description": "Deprecated: applications should use ResetReapplyExcludeType to specify\nexclusions from this set, and new event types should be added to ResetReapplyExcludeType\ninstead of here.\n\n - RESET_REAPPLY_TYPE_SIGNAL: Signals are reapplied when workflow is reset.\n - RESET_REAPPLY_TYPE_NONE: No events are reapplied when workflow is reset.\n - RESET_REAPPLY_TYPE_ALL_ELIGIBLE: All eligible events are reapplied when workflow is reset."
    },
    "v1ResetStickyTaskQueueResponse": {
      "type": "object"
    },
    "v1ResetType": {
      "type": "string",
      "enum": [
        "RESET_TYPE_UNSPECIFIED",
        "RESET_TYPE_FIRST_WORKFLOW_TASK",
        "RESET_TYPE_LAST_WORKFLOW_TASK"
      ],
      "default": "RESET_TYPE_UNSPECIFIED",
      "description": "Deprecated, see temporal.api.common.v1.ResetOptions.\n\n - RESET_TYPE_FIRST_WORKFLOW_TASK: Resets to event of the first workflow task completed, or if it does not exist, the event after task scheduled.\n - RESET_TYPE_LAST_WORKFLOW_TASK: Resets to event of the last workflow task completed, or if it does not exist, the event after task scheduled."
    },
    "v1ResetWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string"
        }
      }
    },
    "v1ResetWorkflowFailureInfo": {
      "type": "object",
      "properties": {
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1RespondActivityTaskCanceledByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCanceledResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedByIdResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondActivityTaskFailedByIdResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apifailurev1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondActivityTaskFailedResponse": {
      "type": "object",
      "properties": {
        "failures": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apifailurev1Failure"
          },
          "title": "Server validation failures could include\nlast_heartbeat_details payload is too large, request failure is too large"
        }
      }
    },
    "v1RespondNexusTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondNexusTaskFailedResponse": {
      "type": "object"
    },
    "v1RespondQueryTaskCompletedResponse": {
      "type": "object"
    },
    "v1RespondWorkflowTaskCompletedRequestCapabilities": {
      "type": "object",
      "properties": {
        "discardSpeculativeWorkflowTaskWithEvents": {
          "type": "boolean",
          "description": "True if the SDK can handle speculative workflow task with command events. If true, the\nserver may choose, at its discretion, to discard a speculative workflow task even if that\nspeculative task included command events the SDK had not previously processed.\n"
        }
      },
      "description": "SDK capability details."
    },
    "v1RespondWorkflowTaskCompletedResponse": {
      "type": "object",
      "properties": {
        "workflowTask": {
          "$ref": "#/definitions/v1PollWorkflowTaskQueueResponse",
          "title": "See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`"
        },
        "activityTasks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollActivityTaskQueueResponse"
          },
          "title": "See `ScheduleActivityTaskCommandAttributes::request_eager_execution`"
        },
        "resetHistoryEventId": {
          "type": "string",
          "format": "int64",
          "description": "If non zero, indicates the server has discarded the workflow task that was being responded to.\nWill be the event ID of the last workflow task started event in the history before the new workflow task.\nServer is only expected to discard a workflow task if it could not have modified the workflow state."
        }
      }
    },
    "v1RespondWorkflowTaskFailedResponse": {
      "type": "object"
    },
    "v1RetryPolicy": {
      "type": "object",
      "properties": {
        "initialInterval": {
          "type": "string",
          "description": "Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries."
        },
        "backoffCoefficient": {
          "type": "number",
          "format": "double",
          "description": "Coefficient used to calculate the next retry interval.\nThe next retry interval is previous interval multiplied by the coefficient.\nMust be 1 or larger."
        },
        "maximumInterval": {
          "type": "string",
          "description": "Maximum interval between retries. Exponential backoff leads to interval increase.\nThis value is the cap of the increase. Default is 100x of the initial interval."
        },
        "maximumAttempts": {
          "type": "integer",
          "format": "int32",
          "title": "Maximum number of attempts. When exceeded the retries stop even if not expired yet.\n1 disables retries. 0 means unlimited (up to the timeouts)"
        },
        "nonRetryableErrorTypes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that\nthis is not a substring match, the error *type* (not message) must match exactly."
        }
      },
      "title": "How retries ought to be handled, usable by both workflows and activities"
    },
    "v1RetryState": {
      "type": "string",
      "enum": [
        "RETRY_STATE_UNSPECIFIED",
        "RETRY_STATE_IN_PROGRESS",
        "RETRY_STATE_NON_RETRYABLE_FAILURE",
        "RETRY_STATE_TIMEOUT",
        "RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED",
        "RETRY_STATE_RETRY_POLICY_NOT_SET",
        "RETRY_STATE_INTERNAL_SERVER_ERROR",
        "RETRY_STATE_CANCEL_REQUESTED"
      ],
      "default": "RETRY_STATE_UNSPECIFIED"
    },
    "v1RoutingConfig": {
      "type": "object",
      "properties": {
        "currentDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "Specifies which Deployment Version should receive new workflow executions and tasks of\nexisting unversioned or AutoUpgrade workflows.\nNil value means no Version in this Deployment (except Ramping Version, if present) receives traffic other than tasks of previously Pinned workflows. In absence of a Current Version, remaining traffic after any ramp (if set)  goes to unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.). \nNote: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage\nis non-zero (see `ramping_deployment_version` and `ramping_version_percentage`)."
        },
        "currentVersion": {
          "type": "string",
          "description": "Deprecated. Use `current_deployment_version`."
        },
        "rampingDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.\nMust always be different from `current_deployment_version` unless both are nil.\nNil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\nNote that it is possible to ramp from one Version to another Version, or from unversioned\nworkers to a particular Version, or from a particular Version to unversioned workers."
        },
        "rampingVersion": {
          "type": "string",
          "description": "Deprecated. Use `ramping_deployment_version`."
        },
        "rampingVersionPercentage": {
          "type": "number",
          "format": "float",
          "description": "Percentage of tasks that are routed to the Ramping Version instead of the Current Version.\nValid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but\nnot yet \"promoted\" to be the Current Version, likely due to pending validations.\nA 0% value means the Ramping Version is receiving no traffic."
        },
        "currentVersionChangedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time current version was changed."
        },
        "rampingVersionChangedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time ramping version was changed. Not updated if only the ramp percentage changes."
        },
        "rampingVersionPercentageChangedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time ramping version percentage was changed.\nIf ramping version is changed, this is also updated, even if the percentage stays the same."
        }
      }
    },
    "v1ScanWorkflowExecutionsResponse": {
      "type": "object",
      "properties": {
        "executions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecutionInfo"
          }
        },
        "nextPageToken": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "Deprecated: Use with `ListWorkflowExecutions`."
    },
    "v1Schedule": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec"
        },
        "action": {
          "$ref": "#/definitions/v1ScheduleAction"
        },
        "policies": {
          "$ref": "#/definitions/v1SchedulePolicies"
        },
        "state": {
          "$ref": "#/definitions/v1ScheduleState"
        }
      }
    },
    "v1ScheduleAction": {
      "type": "object",
      "properties": {
        "startWorkflow": {
          "$ref": "#/definitions/v1NewWorkflowExecutionInfo",
          "description": "All fields of NewWorkflowExecutionInfo are valid except for:\n- workflow_id_reuse_policy\n- cron_schedule\nThe workflow id of the started workflow may not match this exactly,\nit may have a timestamp appended for uniqueness."
        }
      }
    },
    "v1ScheduleActionResult": {
      "type": "object",
      "properties": {
        "scheduleTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (according to the schedule, including jitter)."
        },
        "actualTime": {
          "type": "string",
          "format": "date-time",
          "description": "Time that the action was taken (real time)."
        },
        "startWorkflowResult": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "title": "If action was start_workflow:"
        },
        "startWorkflowStatus": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus",
          "description": "If the action was start_workflow, this field will reflect an\neventually-consistent view of the started workflow's status."
        }
      }
    },
    "v1ScheduleActivityTaskCommandAttributes": {
      "type": "object",
      "properties": {
        "activityId": {
          "type": "string"
        },
        "activityType": {
          "$ref": "#/definitions/v1ActivityType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Indicates how long the caller is willing to wait for activity completion. The \"schedule\" time\nis when the activity is initially scheduled, not when the most recent retry is scheduled.\nLimits how long retries will be attempted. Either this or `start_to_close_timeout` must be\nspecified. When not specified, defaults to the workflow execution timeout.\n"
        },
        "scheduleToStartTimeout": {
          "type": "string",
          "title": "Limits the time an activity task can stay in a task queue before a worker picks it up. The\n\"schedule\" time is when the most recent retry is scheduled. This timeout should usually not\nbe set: it's useful in specific scenarios like worker-specific task queues. This timeout is\nalways non retryable, as all a retry would achieve is to put it back into the same queue.\nDefaults to `schedule_to_close_timeout` or workflow execution timeout if that is not\nspecified. More info:\nhttps://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/"
        },
        "startToCloseTimeout": {
          "type": "string",
          "description": "Maximum time an activity is allowed to execute after being picked up by a worker. This\ntimeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.\n"
        },
        "heartbeatTimeout": {
          "type": "string",
          "description": "Maximum permitted time between successful worker heartbeats."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "Activities are provided by a default retry policy which is controlled through the service's\ndynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has\nelapsed. To disable retries set retry_policy.maximum_attempts to 1."
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to start the activity directly bypassing matching service and worker polling\nThe slot for executing the activity should be reserved when setting this field to true."
        },
        "useWorkflowBuildId": {
          "type": "boolean",
          "description": "If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,\nAssignment rules of the activity's Task Queue will be used to determine the Build ID."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "description": "Priority metadata. If this message is not present, or any fields are not\npresent, they inherit the values from the workflow."
        }
      }
    },
    "v1ScheduleInfo": {
      "type": "object",
      "properties": {
        "actionCount": {
          "type": "string",
          "format": "int64",
          "description": "Number of actions taken so far."
        },
        "missedCatchupWindow": {
          "type": "string",
          "format": "int64",
          "description": "Number of times a scheduled action was skipped due to missing the catchup window."
        },
        "overlapSkipped": {
          "type": "string",
          "format": "int64",
          "description": "Number of skipped actions due to overlap."
        },
        "bufferDropped": {
          "type": "string",
          "format": "int64",
          "description": "Number of dropped actions due to buffer limit."
        },
        "bufferSize": {
          "type": "string",
          "format": "int64",
          "description": "Number of actions in the buffer. The buffer holds the actions that cannot\nbe immediately triggered (due to the overlap policy). These actions can be a result of\nthe normal schedule or a backfill."
        },
        "runningWorkflows": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowExecution"
          },
          "description": "Currently-running workflows started by this schedule. (There might be\nmore than one if the overlap policy allows overlaps.)\nNote that the run_ids in here are the original execution run ids as\nstarted by the schedule. If the workflows retried, did continue-as-new,\nor were reset, they might still be running but with a different run_id."
        },
        "recentActions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "description": "Most recent ten actual action times (including manual triggers)."
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          },
          "description": "Next ten scheduled action times."
        },
        "createTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamps of schedule creation and last update."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time"
        },
        "invalidScheduleError": {
          "type": "string",
          "description": "Deprecated."
        }
      }
    },
    "v1ScheduleListEntry": {
      "type": "object",
      "properties": {
        "scheduleId": {
          "type": "string"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "info": {
          "$ref": "#/definitions/v1ScheduleListInfo"
        }
      },
      "description": "ScheduleListEntry is returned by ListSchedules."
    },
    "v1ScheduleListInfo": {
      "type": "object",
      "properties": {
        "spec": {
          "$ref": "#/definitions/v1ScheduleSpec",
          "title": "From spec:\nSome fields are dropped from this copy of spec: timezone_data"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType",
          "title": "From action:\nAction is a oneof field, but we need to encode this in JSON and oneof fields don't work\nwell with JSON. If action is start_workflow, this is set:"
        },
        "notes": {
          "type": "string",
          "title": "From state:"
        },
        "paused": {
          "type": "boolean"
        },
        "recentActions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1ScheduleActionResult"
          },
          "title": "From info (maybe fewer entries):"
        },
        "futureActionTimes": {
          "type": "array",
          "items": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "description": "ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo\nthat's returned in ListSchedules."
    },
    "v1ScheduleNexusOperationCommandAttributes": {
      "type": "object",
      "properties": {
        "endpoint": {
          "type": "string",
          "description": "Endpoint name, must exist in the endpoint registry or this command will fail."
        },
        "service": {
          "type": "string",
          "description": "Service name."
        },
        "operation": {
          "type": "string",
          "description": "Operation name."
        },
        "input": {
          "$ref": "#/definitions/v1Payload",
          "description": "Input for the operation. The server converts this into Nexus request content and the appropriate content headers\ninternally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the\ncontent is transformed back to the original Payload sent in this command."
        },
        "scheduleToCloseTimeout": {
          "type": "string",
          "description": "Schedule-to-close timeout for this operation.\nIndicates how long the caller is willing to wait for operation completion.\nCalls are retried internally by the server."
        },
        "nexusHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header to attach to the Nexus request.\nUsers are responsible for encrypting sensitive data in this header as it is stored in workflow history and\ntransmitted to external services as-is.\nThis is useful for propagating tracing information.\nNote these headers are not the same as Temporal headers on internal activities and child workflows, these are\ntransmitted to Nexus operations that may be external and are not traditional payloads."
        }
      }
    },
    "v1ScheduleOverlapPolicy": {
      "type": "string",
      "enum": [
        "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
        "SCHEDULE_OVERLAP_POLICY_SKIP",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ONE",
        "SCHEDULE_OVERLAP_POLICY_BUFFER_ALL",
        "SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER",
        "SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER",
        "SCHEDULE_OVERLAP_POLICY_ALLOW_ALL"
      ],
      "default": "SCHEDULE_OVERLAP_POLICY_UNSPECIFIED",
      "description": "ScheduleOverlapPolicy controls what happens when a workflow would be started\nby a schedule, and is already running.\n\n - SCHEDULE_OVERLAP_POLICY_SKIP: SCHEDULE_OVERLAP_POLICY_SKIP (default) means don't start anything. When the\nworkflow completes, the next scheduled event after that time will be considered.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ONE: SCHEDULE_OVERLAP_POLICY_BUFFER_ONE means start the workflow again soon as the\ncurrent one completes, but only buffer one start in this way. If another start is\nsupposed to happen when the workflow is running, and one is already buffered, then\nonly the first one will be started after the running workflow finishes.\n - SCHEDULE_OVERLAP_POLICY_BUFFER_ALL: SCHEDULE_OVERLAP_POLICY_BUFFER_ALL means buffer up any number of starts to all\nhappen sequentially, immediately after the running workflow completes.\n - SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER: SCHEDULE_OVERLAP_POLICY_CANCEL_OTHER means that if there is another workflow\nrunning, cancel it, and start the new one after the old one completes cancellation.\n - SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER: SCHEDULE_OVERLAP_POLICY_TERMINATE_OTHER means that if there is another workflow\nrunning, terminate it and start the new one immediately.\n - SCHEDULE_OVERLAP_POLICY_ALLOW_ALL: SCHEDULE_OVERLAP_POLICY_ALLOW_ALL means start any number of concurrent workflows.\nNote that with this policy, last completion result and last failure will not be\navailable since workflows are not sequential."
    },
    "v1SchedulePatch": {
      "type": "object",
      "properties": {
        "triggerImmediately": {
          "$ref": "#/definitions/v1TriggerImmediatelyRequest",
          "description": "If set, trigger one action immediately."
        },
        "backfillRequest": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1BackfillRequest"
          },
          "description": "If set, runs though the specified time period(s) and takes actions as if that time\npassed by right now, all at once. The overlap policy can be overridden for the\nscope of the backfill."
        },
        "pause": {
          "type": "string",
          "description": "If set, change the state to paused or unpaused (respectively) and set the\nnotes field to the value of the string."
        },
        "unpause": {
          "type": "string"
        }
      }
    },
    "v1SchedulePolicies": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "Policy for overlaps.\nNote that this can be changed after a schedule has taken some actions,\nand some changes might produce unintuitive results. In general, the later\npolicy overrides the earlier policy."
        },
        "catchupWindow": {
          "type": "string",
          "description": "Policy for catchups:\nIf the Temporal server misses an action due to one or more components\nbeing down, and comes back up, the action will be run if the scheduled\ntime is within this window from the current time.\nThis value defaults to one year, and can't be less than 10 seconds."
        },
        "pauseOnFailure": {
          "type": "boolean",
          "description": "If true, and a workflow run fails or times out, turn on \"paused\".\nThis applies after retry policies: the full chain of retries must fail to\ntrigger a pause here."
        },
        "keepOriginalWorkflowId": {
          "type": "boolean",
          "description": "If true, and the action would start a workflow, a timestamp will not be\nappended to the scheduled workflow id."
        }
      }
    },
    "v1ScheduleSpec": {
      "type": "object",
      "properties": {
        "structuredCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "cronString": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "cron_string holds a traditional cron specification as a string. It\naccepts 5, 6, or 7 fields, separated by spaces, and interprets them the\nsame way as CalendarSpec.\n5 fields:         minute, hour, day_of_month, month, day_of_week\n6 fields:         minute, hour, day_of_month, month, day_of_week, year\n7 fields: second, minute, hour, day_of_month, month, day_of_week, year\nIf year is not given, it defaults to *. If second is not given, it\ndefaults to 0.\nShorthands @yearly, @monthly, @weekly, @daily, and @hourly are also\naccepted instead of the 5-7 time fields.\nOptionally, the string can be preceded by CRON_TZ=<timezone name> or\nTZ=<timezone name>, which will get copied to timezone_name. (There must\nnot also be a timezone_name present.)\nOptionally \"#\" followed by a comment can appear at the end of the string.\nNote that the special case that some cron implementations have for\ntreating day_of_month and day_of_week as \"or\" instead of \"and\" when both\nare set is not implemented.\n@every <interval>[/<phase>] is accepted and gets compiled into an\nIntervalSpec instead. <interval> and <phase> should be a decimal integer\nwith a unit suffix s, m, h, or d."
        },
        "calendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Calendar-based specifications of times."
        },
        "interval": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1IntervalSpec"
          },
          "description": "Interval-based specifications of times."
        },
        "excludeCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1CalendarSpec"
          },
          "description": "Any timestamps matching any of exclude_* will be skipped.\nDeprecated. Use exclude_structured_calendar."
        },
        "excludeStructuredCalendar": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1StructuredCalendarSpec"
          }
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "If start_time is set, any timestamps before start_time will be skipped.\n(Together, start_time and end_time make an inclusive interval.)"
        },
        "endTime": {
          "type": "string",
          "format": "date-time",
          "description": "If end_time is set, any timestamps after end_time will be skipped."
        },
        "jitter": {
          "type": "string",
          "title": "All timestamps will be incremented by a random value from 0 to this\namount of jitter. Default: 0"
        },
        "timezoneName": {
          "type": "string",
          "description": "Time zone to interpret all calendar-based specs in.\n\nIf unset, defaults to UTC. We recommend using UTC for your application if\nat all possible, to avoid various surprising properties of time zones.\n\nTime zones may be provided by name, corresponding to names in the IANA\ntime zone database (see https://www.iana.org/time-zones). The definition\nwill be loaded by the Temporal server from the environment it runs in.\n\nIf your application requires more control over the time zone definition\nused, it may pass in a complete definition in the form of a TZif file\nfrom the time zone database. If present, this will be used instead of\nloading anything from the environment. You are then responsible for\nupdating timezone_data when the definition changes.\n\nCalendar spec matching is based on literal matching of the clock time\nwith no special handling of DST: if you write a calendar spec that fires\nat 2:30am and specify a time zone that follows DST, that action will not\nbe triggered on the day that has no 2:30am. Similarly, an action that\nfires at 1:30am will be triggered twice on the day that has two 1:30s.\n\nAlso note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC)."
        },
        "timezoneData": {
          "type": "string",
          "format": "byte"
        }
      },
      "description": "ScheduleSpec is a complete description of a set of absolute timestamps\n(possibly infinite) that an action should occur at. The meaning of a\nScheduleSpec depends only on its contents and never changes, except that the\ndefinition of a time zone can change over time (most commonly, when daylight\nsaving time policy changes for an area). To create a totally self-contained\nScheduleSpec, use UTC or include timezone_data.\n\nFor input, you can provide zero or more of: structured_calendar, calendar,\ncron_string, interval, and exclude_structured_calendar, and all of them will\nbe used (the schedule will take action at the union of all of their times,\nminus the ones that match exclude_structured_calendar).\n\nOn input, calendar and cron_string fields will be compiled into\nstructured_calendar (and maybe interval and timezone_name), so if you\nDescribe a schedule, you'll see only structured_calendar, interval, etc.\n\nIf a spec has no matching times after the current time, then the schedule\nwill be subject to automatic deletion (after several days)."
    },
    "v1ScheduleState": {
      "type": "object",
      "properties": {
        "notes": {
          "type": "string",
          "description": "Informative human-readable message with contextual notes, e.g. the reason\na schedule is paused. The system may overwrite this message on certain\nconditions, e.g. when pause-on-failure happens."
        },
        "paused": {
          "type": "boolean",
          "description": "If true, do not take any actions based on the schedule spec."
        },
        "limitedActions": {
          "type": "boolean",
          "description": "If limited_actions is true, decrement remaining_actions after each\naction, and do not take any more scheduled actions if remaining_actions\nis zero. Actions may still be taken by explicit request (i.e. trigger\nimmediately or backfill). Skipped actions (due to overlap policy) do not\ncount against remaining actions.\nIf a schedule has no more remaining actions, then the schedule will be\nsubject to automatic deletion (after several days)."
        },
        "remainingActions": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1SearchAttributes": {
      "type": "object",
      "properties": {
        "indexedFields": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        }
      },
      "description": "A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.\nThe payload is not serialized in a user-defined way."
    },
    "v1ServerFailureInfo": {
      "type": "object",
      "properties": {
        "nonRetryable": {
          "type": "boolean"
        }
      }
    },
    "v1SetCurrentDeploymentResponse": {
      "type": "object",
      "properties": {
        "currentDeploymentInfo": {
          "$ref": "#/definitions/v1DeploymentInfo"
        },
        "previousDeploymentInfo": {
          "$ref": "#/definitions/v1DeploymentInfo",
          "description": "Info of the deployment that was current before executing this operation."
        }
      },
      "title": "[cleanup-wv-pre-release] Pre-release deployment APIs, clean up later"
    },
    "v1SetWorkerDeploymentCurrentVersionResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value is returned so that it can be optionally passed to APIs\nthat write to the Worker Deployment state to ensure that the state\ndid not change between this API call and a future write."
        },
        "previousVersion": {
          "type": "string",
          "description": "Deprecated. Use `previous_deployment_version`."
        },
        "previousDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The version that was current before executing this operation."
        }
      }
    },
    "v1SetWorkerDeploymentRampingVersionResponse": {
      "type": "object",
      "properties": {
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value is returned so that it can be optionally passed to APIs\nthat write to the Worker Deployment state to ensure that the state\ndid not change between this API call and a future write."
        },
        "previousVersion": {
          "type": "string",
          "description": "Deprecated. Use `previous_deployment_version`."
        },
        "previousDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The version that was ramping before executing this operation."
        },
        "previousPercentage": {
          "type": "number",
          "format": "float",
          "description": "The ramping version percentage before executing this operation."
        }
      }
    },
    "v1Severity": {
      "type": "string",
      "enum": [
        "SEVERITY_UNSPECIFIED",
        "SEVERITY_HIGH",
        "SEVERITY_MEDIUM",
        "SEVERITY_LOW"
      ],
      "default": "SEVERITY_UNSPECIFIED"
    },
    "v1ShutdownWorkerResponse": {
      "type": "object"
    },
    "v1SignalExternalWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "description": "The workflow author-defined name of the signal to send to the workflow."
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized value(s) to provide with the signal."
        },
        "control": {
          "type": "string",
          "title": "Deprecated"
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "description": "Set this to true if the workflow being cancelled is a child of the workflow originating this\ncommand. The request will be rejected if it is set to true and the target workflow is *not*\na child of the requesting workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that are passed by the workflow that is sending a signal to the external \nworkflow that is receiving this signal."
        }
      }
    },
    "v1SignalExternalWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND",
        "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED"
      ],
      "default": "SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
      "title": "- SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED: Signal count limit is per workflow and controlled by server dynamic config \"history.maximumSignalsPerExecution\""
    },
    "v1SignalExternalWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "$ref": "#/definitions/v1SignalExternalWorkflowExecutionFailedCause"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the workflow which failed the signal.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        }
      }
    },
    "v1SignalExternalWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "namespace": {
          "type": "string",
          "description": "Namespace of the to-be-signalled workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "signalName": {
          "type": "string",
          "title": "name/type of the signal to fire in the external workflow"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized arguments to provide to the signal handler"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "childWorkflowOnly": {
          "type": "boolean",
          "title": "Workers are expected to set this to true if the workflow they are requesting to cancel is\na child of the workflow which issued the request"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        }
      }
    },
    "v1SignalWithStartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string",
          "description": "The run id of the workflow that was started - or just signaled, if it was already running."
        },
        "started": {
          "type": "boolean",
          "description": "If true, a new workflow was started."
        }
      }
    },
    "v1SignalWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1StartBatchOperationResponse": {
      "type": "object"
    },
    "v1StartChildWorkflowExecutionCommandAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "description": "Establish a cron schedule for the child workflow."
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment\nrules of the child's Task Queue will be used to independently assign a Build ID to it.\nDeprecated. Only considered for versioning v0.2."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "description": "Priority metadata. If this message is not present, or any fields are not\npresent, they inherit the values from the workflow."
        }
      }
    },
    "v1StartChildWorkflowExecutionFailedCause": {
      "type": "string",
      "enum": [
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS",
        "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND"
      ],
      "default": "START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED"
    },
    "v1StartChildWorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "cause": {
          "$ref": "#/definitions/v1StartChildWorkflowExecutionFailedCause"
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "initiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1StartChildWorkflowExecutionInitiatedEventAttributes": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace of the child workflow.\nSDKs and UI tools should use `namespace` field but server must use `namespace_id` only."
        },
        "namespaceId": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "parentClosePolicy": {
          "$ref": "#/definitions/v1ParentClosePolicy",
          "description": "Default: PARENT_CLOSE_POLICY_TERMINATE."
        },
        "control": {
          "type": "string",
          "description": "Deprecated."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this child runs on a cron schedule, it will appear here"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment\nrules of the child's Task Queue will be used to independently assign a Build ID to it.\nDeprecated. Only considered for versioning v0.2."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      }
    },
    "v1StartOperationRequest": {
      "type": "object",
      "properties": {
        "service": {
          "type": "string",
          "description": "Name of service to start the operation in."
        },
        "operation": {
          "type": "string",
          "description": "Type of operation to start."
        },
        "requestId": {
          "type": "string",
          "description": "A request ID that can be used as an idempotentency key."
        },
        "callback": {
          "type": "string",
          "description": "Callback URL to call upon completion if the started operation is async."
        },
        "payload": {
          "$ref": "#/definitions/v1Payload",
          "description": "Full request body from the incoming HTTP request."
        },
        "callbackHeader": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Header that is expected to be attached to the callback request when the operation completes."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apinexusv1Link"
          },
          "description": "Links contain caller information and can be attached to the operations started by the handler."
        }
      },
      "description": "A request to start an operation."
    },
    "v1StartOperationResponse": {
      "type": "object",
      "properties": {
        "syncSuccess": {
          "$ref": "#/definitions/StartOperationResponseSync"
        },
        "asyncSuccess": {
          "$ref": "#/definitions/StartOperationResponseAsync"
        },
        "operationError": {
          "$ref": "#/definitions/v1UnsuccessfulOperationError",
          "description": "The operation completed unsuccessfully (failed or canceled)."
        }
      },
      "description": "Response variant for StartOperationRequest."
    },
    "v1StartTimeFilter": {
      "type": "object",
      "properties": {
        "earliestTime": {
          "type": "string",
          "format": "date-time"
        },
        "latestTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1StartTimerCommandAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "description": "An id for the timer, currently live timers must have different ids. Typically autogenerated\nby the SDK."
        },
        "startToFireTimeout": {
          "type": "string",
          "description": "How long until the timer fires, producing a `TIMER_FIRED` event.\n"
        }
      }
    },
    "v1StartWorkflowExecutionRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string"
        },
        "workflowId": {
          "type": "string"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments to the workflow. These are passed as arguments to the workflow function."
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "identity": {
          "type": "string",
          "title": "The identity of the client who initiated this request"
        },
        "requestId": {
          "type": "string",
          "description": "A unique identifier for this start request. Typically UUIDv4."
        },
        "workflowIdReusePolicy": {
          "$ref": "#/definitions/v1WorkflowIdReusePolicy",
          "description": "Defines whether to allow re-using the workflow id from a previously *closed* workflow.\nThe default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.\n\nSee `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow."
        },
        "workflowIdConflictPolicy": {
          "$ref": "#/definitions/v1WorkflowIdConflictPolicy",
          "description": "Defines how to resolve a workflow id conflict with a *running* workflow.\nThe default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.\n\nSee `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy",
          "description": "The retry policy for the workflow. Will never exceed `workflow_execution_timeout`."
        },
        "cronSchedule": {
          "type": "string",
          "title": "See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "requestEagerExecution": {
          "type": "boolean",
          "description": "Request to get the first workflow task inline in the response bypassing matching service and worker polling.\nIf set to `true` the caller is expected to have a worker available and capable of processing the task.\nThe returned task will be marked as started and is expected to be completed by the specified\n`workflow_task_timeout`."
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "These values will be available as ContinuedFailure and LastCompletionResult in the\nWorkflowExecutionStarted event and through SDKs. The are currently only used by the\nserver itself (for the schedules feature) and are not intended to be exposed in\nStartWorkflowExecution."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowStartDelay": {
          "type": "string",
          "description": "Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.\nIf the workflow gets a signal before the delay, a workflow task will be dispatched and the rest\nof the delay will be ignored."
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Callbacks to be called by the server when this workflow reaches a terminal state.\nIf the workflow continues-as-new, these callbacks will be carried over to the new execution.\nCallback addresses must be whitelisted in the server's dynamic configuration."
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo\nfor use by user interfaces to display the fixed as-of-start summary and details of the\nworkflow."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/apicommonv1Link"
          },
          "description": "Links to be associated with the workflow."
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.\nTo unset the override after the workflow is running, use UpdateWorkflowExecutionOptions."
        },
        "onConflictOptions": {
          "$ref": "#/definitions/v1OnConflictOptions",
          "description": "Defines actions to be done to the existing running workflow when the conflict policy\nWORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a\nempty object (ie., all options with default value), it won't do anything to the existing\nrunning workflow. If set, it will add a history event to the running workflow."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      }
    },
    "v1StartWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "runId": {
          "type": "string",
          "description": "The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING)."
        },
        "started": {
          "type": "boolean",
          "description": "If true, a new workflow was started."
        },
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus",
          "description": "Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING\nunless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs)."
        },
        "eagerWorkflowTask": {
          "$ref": "#/definitions/v1PollWorkflowTaskQueueResponse",
          "description": "When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will\nreturn the first workflow task to be eagerly executed.\nThe caller is expected to have a worker available to process the task."
        },
        "link": {
          "$ref": "#/definitions/apicommonv1Link",
          "description": "Link to the workflow event."
        }
      }
    },
    "v1StatusFilter": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        }
      }
    },
    "v1StickyExecutionAttributes": {
      "type": "object",
      "properties": {
        "workerTaskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "scheduleToStartTimeout": {
          "type": "string"
        }
      }
    },
    "v1StopBatchOperationResponse": {
      "type": "object"
    },
    "v1StructuredCalendarSpec": {
      "type": "object",
      "properties": {
        "second": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match seconds (0-59)"
        },
        "minute": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match minutes (0-59)"
        },
        "hour": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match hours (0-23)"
        },
        "dayOfMonth": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match days of the month (1-31)"
        },
        "month": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "title": "Match months (1-12)"
        },
        "year": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match years."
        },
        "dayOfWeek": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Range"
          },
          "description": "Match days of the week (0-6; 0 is Sunday)."
        },
        "comment": {
          "type": "string",
          "description": "Free-form comment describing the intention of this spec."
        }
      },
      "title": "StructuredCalendarSpec describes an event specification relative to the\ncalendar, in a form that's easy to work with programmatically. Each field can\nbe one or more ranges.\nA timestamp matches if at least one range of each field matches the\ncorresponding fields of the timestamp, except for year: if year is missing,\nthat means all years match. For all fields besides year, at least one Range\nmust be present to match anything.\nTODO: add relative-to-end-of-month\nTODO: add nth day-of-week in month"
    },
    "v1TaskIdBlock": {
      "type": "object",
      "properties": {
        "startId": {
          "type": "string",
          "format": "int64"
        },
        "endId": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "v1TaskQueue": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "kind": {
          "$ref": "#/definitions/v1TaskQueueKind",
          "description": "Default: TASK_QUEUE_KIND_NORMAL."
        },
        "normalName": {
          "type": "string",
          "description": "Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of\nthe normal task queue that the sticky worker is running on."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/task-queues/"
    },
    "v1TaskQueueConfig": {
      "type": "object",
      "properties": {
        "queueRateLimit": {
          "$ref": "#/definitions/v1RateLimitConfig",
          "description": "Unless modified, this is the system-defined rate limit."
        },
        "fairnessKeysRateLimitDefault": {
          "$ref": "#/definitions/v1RateLimitConfig",
          "description": "If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key."
        }
      }
    },
    "v1TaskQueueKind": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_KIND_UNSPECIFIED",
        "TASK_QUEUE_KIND_NORMAL",
        "TASK_QUEUE_KIND_STICKY"
      ],
      "default": "TASK_QUEUE_KIND_UNSPECIFIED",
      "description": "The task queue specified by the user is always a normal task queue. There can be as many\nworkers as desired for a single normal task queue. All those workers may pick up tasks from\nthat queue.\n - TASK_QUEUE_KIND_STICKY: A sticky queue only includes new history since the last workflow task, and they are\nper-worker.\n\nSticky queues are created dynamically by each worker during their start up. They only exist\nfor the lifetime of the worker process. Tasks in a sticky task queue are only available to\nthe worker that created the sticky queue.\n\nSticky queues are only for workflow tasks. There are no sticky task queues for activities.",
      "title": "- TASK_QUEUE_KIND_NORMAL: Tasks from a normal workflow task queue always include complete workflow history"
    },
    "v1TaskQueueMetadata": {
      "type": "object",
      "properties": {
        "maxTasksPerSecond": {
          "type": "number",
          "format": "double",
          "title": "Allows throttling dispatch of tasks from this queue"
        }
      },
      "title": "Only applies to activity task queues"
    },
    "v1TaskQueuePartitionMetadata": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string"
        },
        "ownerHostName": {
          "type": "string"
        }
      }
    },
    "v1TaskQueueReachability": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "type": "string"
        },
        "reachability": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/v1TaskReachability"
          },
          "description": "Task reachability for a worker in a single task queue.\nSee the TaskReachability docstring for information about each enum variant.\nIf reachability is empty, this worker is considered unreachable in this task queue."
        }
      },
      "description": "Reachability of tasks for a worker on a single task queue."
    },
    "v1TaskQueueStats": {
      "type": "object",
      "properties": {
        "approximateBacklogCount": {
          "type": "string",
          "format": "int64",
          "description": "The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually\nconverges to the right value. Can be relied upon for scaling decisions.\n\nSpecial note for workflow task queue type: this metric does not count sticky queue tasks. However, because\nthose tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size\ngrows."
        },
        "approximateBacklogAge": {
          "type": "string",
          "description": "Approximate age of the oldest task in the backlog based on the creation time of the task at the head of\nthe queue. Can be relied upon for scaling decisions.\n\nSpecial note for workflow task queue type: this metric does not count sticky queue tasks. However, because\nthose tasks only remain valid for a few seconds, they should not affect the result when backlog is older than\nfew seconds."
        },
        "tasksAddRate": {
          "type": "number",
          "format": "float",
          "description": "The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks\nwhether or not they were added to/dispatched from the backlog or they were dispatched immediately without going\nto the backlog (sync-matched).\n\nThe difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\nbacklog grows/shrinks.\n\nNote: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\ntasks_add_rate, because:\n- Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n  enable for activities by default in the latest SDKs.\n- Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n  workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n  worker instance."
        },
        "tasksDispatchRate": {
          "type": "number",
          "format": "float",
          "description": "The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes\ntasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without\ngoing to the backlog (sync-matched).\n\nThe difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which\nbacklog grows/shrinks.\n\nNote: the actual tasks delivered to the workers may significantly be higher than the numbers reported by\ntasks_dispatch_rate, because:\n- Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is\n  enable for activities by default in the latest SDKs.\n- Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each\n  workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific\n  worker instance."
        }
      },
      "description": "TaskQueueStats contains statistics about task queue backlog and activity.\n\nFor workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read\ncomments above each metric to understand the impact of sticky queue exclusion on that metric accuracy."
    },
    "v1TaskQueueStatus": {
      "type": "object",
      "properties": {
        "backlogCountHint": {
          "type": "string",
          "format": "int64"
        },
        "readLevel": {
          "type": "string",
          "format": "int64"
        },
        "ackLevel": {
          "type": "string",
          "format": "int64"
        },
        "ratePerSecond": {
          "type": "number",
          "format": "double"
        },
        "taskIdBlock": {
          "$ref": "#/definitions/v1TaskIdBlock"
        }
      },
      "description": "Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior."
    },
    "v1TaskQueueType": {
      "type": "string",
      "enum": [
        "TASK_QUEUE_TYPE_UNSPECIFIED",
        "TASK_QUEUE_TYPE_WORKFLOW",
        "TASK_QUEUE_TYPE_ACTIVITY",
        "TASK_QUEUE_TYPE_NEXUS"
      ],
      "default": "TASK_QUEUE_TYPE_UNSPECIFIED",
      "description": " - TASK_QUEUE_TYPE_WORKFLOW: Workflow type of task queue.\n - TASK_QUEUE_TYPE_ACTIVITY: Activity type of task queue.\n - TASK_QUEUE_TYPE_NEXUS: Task queue type for dispatching Nexus requests."
    },
    "v1TaskQueueTypeInfo": {
      "type": "object",
      "properties": {
        "pollers": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PollerInfo"
          },
          "description": "Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID."
        },
        "stats": {
          "$ref": "#/definitions/v1TaskQueueStats"
        }
      }
    },
    "v1TaskQueueVersionInfo": {
      "type": "object",
      "properties": {
        "typesInfo": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1TaskQueueTypeInfo"
          },
          "description": "Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum."
        },
        "taskReachability": {
          "$ref": "#/definitions/v1BuildIdTaskReachability",
          "description": "Task Reachability is eventually consistent; there may be a delay until it converges to the most\naccurate value but it is designed in a way to take the more conservative side until it converges.\nFor example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.\n\nNote: future activities who inherit their workflow's Build ID but not its Task Queue will not be\naccounted for reachability as server cannot know if they'll happen as they do not use\nassignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows\nwho inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make\nsure to query reachability for the parent/previous workflow's Task Queue as well."
        }
      }
    },
    "v1TaskQueueVersionSelection": {
      "type": "object",
      "properties": {
        "buildIds": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Include specific Build IDs."
        },
        "unversioned": {
          "type": "boolean",
          "description": "Include the unversioned queue."
        },
        "allActive": {
          "type": "boolean",
          "description": "Include all active versions. A version is considered active if, in the last few minutes,\nit has had new tasks or polls, or it has been the subject of certain task queue API calls."
        }
      },
      "description": "Used for specifying versions the caller is interested in."
    },
    "v1TaskQueueVersioningInfo": {
      "type": "object",
      "properties": {
        "currentDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "Specifies which Deployment Version should receive new workflow executions and tasks of\nexisting unversioned or AutoUpgrade workflows.\nNil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\nNote: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage\nis non-zero (see `ramping_deployment_version` and `ramping_version_percentage`)."
        },
        "currentVersion": {
          "type": "string",
          "description": "Deprecated. Use `current_deployment_version`."
        },
        "rampingDeploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.\nMust always be different from `current_deployment_version` unless both are nil.\nNil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)\nNote that it is possible to ramp from one Version to another Version, or from unversioned\nworkers to a particular Version, or from a particular Version to unversioned workers."
        },
        "rampingVersion": {
          "type": "string",
          "description": "Deprecated. Use `ramping_deployment_version`."
        },
        "rampingVersionPercentage": {
          "type": "number",
          "format": "float",
          "description": "Percentage of tasks that are routed to the Ramping Version instead of the Current Version.\nValid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but\nnot yet \"promoted\" to be the Current Version, likely due to pending validations.\nA 0% value means the Ramping Version is receiving no traffic."
        },
        "updateTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time versioning information of this Task Queue changed."
        }
      },
      "description": "Experimental. Worker Deployments are experimental and might significantly change in the future."
    },
    "v1TaskReachability": {
      "type": "string",
      "enum": [
        "TASK_REACHABILITY_UNSPECIFIED",
        "TASK_REACHABILITY_NEW_WORKFLOWS",
        "TASK_REACHABILITY_EXISTING_WORKFLOWS",
        "TASK_REACHABILITY_OPEN_WORKFLOWS",
        "TASK_REACHABILITY_CLOSED_WORKFLOWS"
      ],
      "default": "TASK_REACHABILITY_UNSPECIFIED",
      "description": "Specifies which category of tasks may reach a worker on a versioned task queue.\nUsed both in a reachability query and its response.\nDeprecated.\n\n - TASK_REACHABILITY_NEW_WORKFLOWS: There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.\n - TASK_REACHABILITY_EXISTING_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers\nshould *not* be retired.\nThis enum value does not distinguish between open and closed workflows.\n - TASK_REACHABILITY_OPEN_WORKFLOWS: There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers\nshould *not* be retired.\n - TASK_REACHABILITY_CLOSED_WORKFLOWS: There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be\nretired dependending on application requirements. For example, if there's no need to query closed workflows."
    },
    "v1TerminateWorkflowExecutionResponse": {
      "type": "object"
    },
    "v1TerminatedFailureInfo": {
      "type": "object"
    },
    "v1TimeoutFailureInfo": {
      "type": "object",
      "properties": {
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        },
        "lastHeartbeatDetails": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1TimeoutType": {
      "type": "string",
      "enum": [
        "TIMEOUT_TYPE_UNSPECIFIED",
        "TIMEOUT_TYPE_START_TO_CLOSE",
        "TIMEOUT_TYPE_SCHEDULE_TO_START",
        "TIMEOUT_TYPE_SCHEDULE_TO_CLOSE",
        "TIMEOUT_TYPE_HEARTBEAT"
      ],
      "default": "TIMEOUT_TYPE_UNSPECIFIED"
    },
    "v1TimerCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "identity": {
          "type": "string",
          "title": "The id of the worker who requested this cancel"
        }
      }
    },
    "v1TimerFiredEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "Will match the `timer_id` from `TIMER_STARTED` event for this timer"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `TIMER_STARTED` event itself"
        }
      }
    },
    "v1TimerStartedEventAttributes": {
      "type": "object",
      "properties": {
        "timerId": {
          "type": "string",
          "title": "The worker/user assigned id for this timer"
        },
        "startToFireTimeout": {
          "type": "string",
          "title": "How long until this timer fires"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        }
      }
    },
    "v1TimestampedBuildIdAssignmentRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1BuildIdAssignmentRule"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1TimestampedCompatibleBuildIdRedirectRule": {
      "type": "object",
      "properties": {
        "rule": {
          "$ref": "#/definitions/v1CompatibleBuildIdRedirectRule"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        }
      }
    },
    "v1TriggerImmediatelyRequest": {
      "type": "object",
      "properties": {
        "overlapPolicy": {
          "$ref": "#/definitions/v1ScheduleOverlapPolicy",
          "description": "If set, override overlap policy for this one request."
        },
        "scheduledTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp used for the identity of the target workflow.\nIf not set the default value is the current time."
        }
      }
    },
    "v1TriggerWorkflowRuleResponse": {
      "type": "object",
      "properties": {
        "applied": {
          "type": "boolean",
          "description": "True is the rule was applied, based on the rule conditions (predicate/visibility_query)."
        }
      }
    },
    "v1UnpauseActivityResponse": {
      "type": "object"
    },
    "v1UnsuccessfulOperationError": {
      "type": "object",
      "properties": {
        "operationState": {
          "type": "string",
          "description": "See https://github.com/nexus-rpc/api/blob/main/SPEC.md#operationinfo."
        },
        "failure": {
          "$ref": "#/definitions/apinexusv1Failure"
        }
      }
    },
    "v1UpdateActivityOptionsResponse": {
      "type": "object",
      "properties": {
        "activityOptions": {
          "$ref": "#/definitions/v1ActivityOptions",
          "title": "Activity options after an update"
        }
      }
    },
    "v1UpdateAdmittedEventOrigin": {
      "type": "string",
      "enum": [
        "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
        "UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY"
      ],
      "default": "UPDATE_ADMITTED_EVENT_ORIGIN_UNSPECIFIED",
      "description": "Records why a WorkflowExecutionUpdateAdmittedEvent was written to history.\nNote that not all admitted Updates result in this event.\n\n - UPDATE_ADMITTED_EVENT_ORIGIN_REAPPLY: The UpdateAdmitted event was created when reapplying events during reset\nor replication. I.e. an accepted Update on one branch of Workflow history\nwas converted into an admitted Update on a different branch."
    },
    "v1UpdateDeploymentMetadata": {
      "type": "object",
      "properties": {
        "upsertEntries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          }
        },
        "removeEntries": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "List of keys to remove from the metadata."
        }
      },
      "description": "Used as part of Deployment write APIs to update metadata attached to a deployment.\nDeprecated."
    },
    "v1UpdateNamespaceInfo": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string"
        },
        "ownerEmail": {
          "type": "string"
        },
        "data": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "A key-value map for any customized purpose.\nIf data already exists on the namespace, \nthis will merge with the existing key values."
        },
        "state": {
          "$ref": "#/definitions/v1NamespaceState",
          "description": "New namespace state, server will reject if transition is not allowed.\nAllowed transitions are:\n Registered -> [ Deleted | Deprecated | Handover ]\n Handover -> [ Registered ]\nDefault is NAMESPACE_STATE_UNSPECIFIED which is do not change state."
        }
      }
    },
    "v1UpdateNamespaceResponse": {
      "type": "object",
      "properties": {
        "namespaceInfo": {
          "$ref": "#/definitions/v1NamespaceInfo"
        },
        "config": {
          "$ref": "#/definitions/v1NamespaceConfig"
        },
        "replicationConfig": {
          "$ref": "#/definitions/v1NamespaceReplicationConfig"
        },
        "failoverVersion": {
          "type": "string",
          "format": "int64"
        },
        "isGlobalNamespace": {
          "type": "boolean"
        }
      }
    },
    "v1UpdateNexusEndpointResponse": {
      "type": "object",
      "properties": {
        "endpoint": {
          "$ref": "#/definitions/v1Endpoint",
          "description": "Data post acceptance. Can be used to issue additional updates to this record."
        }
      }
    },
    "v1UpdateRef": {
      "type": "object",
      "properties": {
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "updateId": {
          "type": "string"
        }
      },
      "description": "The data needed by a client to refer to a previously invoked Workflow Update."
    },
    "v1UpdateScheduleResponse": {
      "type": "object"
    },
    "v1UpdateTaskQueueConfigResponse": {
      "type": "object",
      "properties": {
        "config": {
          "$ref": "#/definitions/v1TaskQueueConfig"
        }
      }
    },
    "v1UpdateWorkerBuildIdCompatibilityResponse": {
      "type": "object",
      "title": "[cleanup-wv-pre-release]"
    },
    "v1UpdateWorkerConfigResponse": {
      "type": "object",
      "properties": {
        "workerConfig": {
          "$ref": "#/definitions/v1WorkerConfig",
          "description": "The worker configuration. Will be returned if the command was sent to a single worker."
        }
      }
    },
    "v1UpdateWorkerDeploymentVersionMetadataResponse": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/v1VersionMetadata",
          "description": "Full metadata after performing the update."
        }
      }
    },
    "v1UpdateWorkerVersioningRulesResponse": {
      "type": "object",
      "properties": {
        "assignmentRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedBuildIdAssignmentRule"
          }
        },
        "compatibleRedirectRules": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1TimestampedCompatibleBuildIdRedirectRule"
          }
        },
        "conflictToken": {
          "type": "string",
          "format": "byte",
          "description": "This value can be passed back to UpdateWorkerVersioningRulesRequest to\nensure that the rules were not modified between the two updates, which\ncould lead to lost updates and other confusion."
        }
      },
      "title": "[cleanup-wv-pre-release]"
    },
    "v1UpdateWorkflowExecutionLifecycleStage": {
      "type": "string",
      "enum": [
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED",
        "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED"
      ],
      "default": "UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED",
      "description": "UpdateWorkflowExecutionLifecycleStage is specified by clients invoking\nWorkflow Updates and used to indicate to the server how long the\nclient wishes to wait for a return value from the API. If any value other\nthan UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED is sent by the\nclient then the API will complete before the Update is finished and will\nreturn a handle to the running Update so that it can later be polled for\ncompletion.\nIf specified stage wasn't reached before server timeout, server returns\nactual stage reached.\n\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED: An unspecified value for this enum.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED: The API call will not return until the Update request has been admitted\nby the server - it may be the case that due to a considerations like load\nor resource limits that an Update is made to wait before the server will\nindicate that it has been received and will be processed. This value\ndoes not wait for any sort of acknowledgement from a worker.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED: The API call will not return until the Update has passed validation on a worker.\n - UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED: The API call will not return until the Update has executed to completion\non a worker and has either been rejected or returned a value or an error."
    },
    "v1UpdateWorkflowExecutionOptionsResponse": {
      "type": "object",
      "properties": {
        "workflowExecutionOptions": {
          "$ref": "#/definitions/v1WorkflowExecutionOptions",
          "description": "Workflow Execution options after update."
        }
      }
    },
    "v1UpdateWorkflowExecutionRequest": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "The namespace name of the target Workflow."
        },
        "workflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "The target Workflow Id and (optionally) a specific Run Id thereof."
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "If set, this call will error if the most recent (if no Run Id is set on\n`workflow_execution`), or specified (if it is) Workflow Execution is not\npart of the same execution chain as this Id."
        },
        "waitPolicy": {
          "$ref": "#/definitions/v1WaitPolicy",
          "description": "Specifies client's intent to wait for Update results.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached.\nActual reached stage will be included in the response."
        },
        "request": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The request information that will be delivered all the way down to the\nWorkflow Execution."
        }
      }
    },
    "v1UpdateWorkflowExecutionResponse": {
      "type": "object",
      "properties": {
        "updateRef": {
          "$ref": "#/definitions/v1UpdateRef",
          "description": "Enough information for subsequent poll calls if needed. Never null."
        },
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of the Update if and only if the Workflow Update\nhas completed. If this response is being returned before the Update has\ncompleted then this field will not be set."
        },
        "stage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "The most advanced lifecycle stage that the Update is known to have\nreached, where lifecycle stages are ordered\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <\nUPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.\nUNSPECIFIED will be returned if and only if the server's maximum wait\ntime was reached before the Update reached the stage specified in the\nrequest WaitPolicy, and before the context deadline expired; clients may\nmay then retry the call as needed."
        }
      }
    },
    "v1UpsertWorkflowSearchAttributesCommandAttributes": {
      "type": "object",
      "properties": {
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1UpsertWorkflowSearchAttributesEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        }
      }
    },
    "v1UserMetadata": {
      "type": "object",
      "properties": {
        "summary": {
          "$ref": "#/definitions/v1Payload",
          "description": "Short-form text that provides a summary. This payload should be a \"json/plain\"-encoded payload\nthat is a single JSON string for use in user interfaces. User interface formatting may not\napply to this text when used in \"title\" situations. The payload data section is limited to 400\nbytes by default."
        },
        "details": {
          "$ref": "#/definitions/v1Payload",
          "description": "Long-form text that provides details. This payload should be a \"json/plain\"-encoded payload\nthat is a single JSON string for use in user interfaces. User interface formatting may apply to\nthis text in common use. The payload data section is limited to 20000 bytes by default."
        }
      },
      "description": "Information a user can set, often for use by user interfaces."
    },
    "v1VersionDrainageInfo": {
      "type": "object",
      "properties": {
        "status": {
          "$ref": "#/definitions/v1VersionDrainageStatus",
          "description": "Set to DRAINING when the version first stops accepting new executions (is no longer current or ramping).\nSet to DRAINED when no more open pinned workflows exist on this version."
        },
        "lastChangedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time the drainage status changed."
        },
        "lastCheckedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time the system checked for drainage of this version."
        }
      },
      "description": "Information about workflow drainage to help the user determine when it is safe\nto decommission a Version. Not present while version is current or ramping.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
    },
    "v1VersionDrainageStatus": {
      "type": "string",
      "enum": [
        "VERSION_DRAINAGE_STATUS_UNSPECIFIED",
        "VERSION_DRAINAGE_STATUS_DRAINING",
        "VERSION_DRAINAGE_STATUS_DRAINED"
      ],
      "default": "VERSION_DRAINAGE_STATUS_UNSPECIFIED",
      "description": "Specify the drainage status for a Worker Deployment Version so users can decide whether they\ncan safely decommission the version.\nExperimental. Worker Deployments are experimental and might significantly change in the future.\n\n - VERSION_DRAINAGE_STATUS_UNSPECIFIED: Drainage Status is not specified.\n - VERSION_DRAINAGE_STATUS_DRAINING: The Worker Deployment Version is not used by new workflows but is still used by\nopen pinned workflows. The version cannot be decommissioned safely.\n - VERSION_DRAINAGE_STATUS_DRAINED: The Worker Deployment Version is not used by new or open workflows, but might be still needed by\nQueries sent to closed workflows. The version can be decommissioned safely if user does\nnot query closed workflows. If the user does query closed workflows for some time x after\nworkflows are closed, they should decommission the version after it has been drained for that duration."
    },
    "v1VersionInfo": {
      "type": "object",
      "properties": {
        "current": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "recommended": {
          "$ref": "#/definitions/v1ReleaseInfo"
        },
        "instructions": {
          "type": "string"
        },
        "alerts": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Alert"
          }
        },
        "lastUpdateTime": {
          "type": "string",
          "format": "date-time"
        }
      },
      "description": "VersionInfo contains details about current and recommended release versions as well as alerts and upgrade instructions."
    },
    "v1VersionMetadata": {
      "type": "object",
      "properties": {
        "entries": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1Payload"
          },
          "description": "Arbitrary key-values."
        }
      }
    },
    "v1VersioningBehavior": {
      "type": "string",
      "enum": [
        "VERSIONING_BEHAVIOR_UNSPECIFIED",
        "VERSIONING_BEHAVIOR_PINNED",
        "VERSIONING_BEHAVIOR_AUTO_UPGRADE"
      ],
      "default": "VERSIONING_BEHAVIOR_UNSPECIFIED",
      "description": "Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment\nVersions. The Versioning Behavior of a workflow execution is typically specified by the worker\nwho completes the first task of the execution, but is also overridable manually for new and\nexisting workflows (see VersioningOverride).\nExperimental. Worker Deployments are experimental and might significantly change in the future.\n\n - VERSIONING_BEHAVIOR_UNSPECIFIED: Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the\nlegacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see\n`WorkerVersioningMode`.)\nUser needs to use Patching to keep the new code compatible with prior versions when dealing\nwith Unversioned workflows.\n - VERSIONING_BEHAVIOR_PINNED: Workflow will start on the Current Deployment Version of its Task Queue, and then\nwill be pinned to that same Deployment Version until completion (the Version that\nthis Workflow is pinned to is specified in `versioning_info.version`).\nThis behavior eliminates most of compatibility concerns users face when changing their code.\nPatching is not needed when pinned workflows code change.\nCan be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the\nexecution to another Deployment Version.\nActivities of `PINNED` workflows are sent to the same Deployment Version. Exception to this\nwould be when the activity Task Queue workers are not present in the workflow's Deployment\nVersion, in which case the activity will be sent to the Current Deployment Version of its own\ntask queue.\n - VERSIONING_BEHAVIOR_AUTO_UPGRADE: Workflow will automatically move to the Current Deployment Version of its Task Queue when the\nnext workflow task is dispatched.\nAutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the\nlatest Deployment Version, but the user still needs to use Patching to keep the new code\ncompatible with prior versions for changed workflow types.\nActivities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow\nexecution (as specified in versioning_info.version based on the last completed\nworkflow task). Exception to this would be when the activity Task Queue workers are not\npresent in the workflow's Deployment Version, in which case, the activity will be sent to a\ndifferent Deployment Version according to the Current Deployment Version of its own task\nqueue.\nWorkflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment\nVersion of their Task Queue changes, without having to wait for the backlogged activity to\ncomplete on the old Version."
    },
    "v1VersioningOverride": {
      "type": "object",
      "properties": {
        "pinned": {
          "$ref": "#/definitions/VersioningOverridePinnedOverride",
          "description": "Send the next workflow task to the Version specified in the override."
        },
        "autoUpgrade": {
          "type": "boolean",
          "description": "Send the next workflow task to the Current Deployment Version\nof its Task Queue when the next workflow task is dispatched."
        },
        "behavior": {
          "$ref": "#/definitions/v1VersioningBehavior",
          "description": "Required.\nDeprecated. Use `override`."
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.\nIdentifies the worker deployment to pin the workflow to.\nDeprecated. Use `override.pinned.version`."
        },
        "pinnedVersion": {
          "type": "string",
          "description": "Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.\nIdentifies the worker deployment version to pin the workflow to, in the format\n\"<deployment_name>.<build_id>\".\nDeprecated. Use `override.pinned.version`."
        }
      },
      "description": "Used to override the versioning behavior (and pinned deployment version, if applicable) of a\nspecific workflow execution. If set, takes precedence over the worker-sent values. See\n`WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call\n`UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`\nto indicate that it should be mutated.\nPinned overrides are automatically inherited by child workflows, continue-as-new workflows,\nworkflow retries, and cron workflows."
    },
    "v1WaitPolicy": {
      "type": "object",
      "properties": {
        "lifecycleStage": {
          "$ref": "#/definitions/v1UpdateWorkflowExecutionLifecycleStage",
          "description": "Indicates the Update lifecycle stage that the Update must reach before\nAPI call is returned.\nNOTE: This field works together with API call timeout which is limited by\nserver timeout (maximum wait time). If server timeout is expired before\nuser specified timeout, API call returns even if specified stage is not reached."
        }
      },
      "description": "Specifies client's intent to wait for Update results."
    },
    "v1WorkerConfig": {
      "type": "object",
      "properties": {
        "workflowCacheSize": {
          "type": "integer",
          "format": "int32"
        },
        "simplePollerBehavior": {
          "$ref": "#/definitions/WorkerConfigSimplePollerBehavior"
        },
        "autoscalingPollerBehavior": {
          "$ref": "#/definitions/WorkerConfigAutoscalingPollerBehavior"
        }
      }
    },
    "v1WorkerDeploymentInfo": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Identifies a Worker Deployment. Must be unique within the namespace."
        },
        "versionSummaries": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/WorkerDeploymentInfoWorkerDeploymentVersionSummary"
          },
          "title": "Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be\ncleaned up automatically if all the following conditions meet:\n- It does not receive new executions (is not current or ramping)\n- It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status) \n- It is drained (see WorkerDeploymentVersionInfo.drainage_status)"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "routingConfig": {
          "$ref": "#/definitions/v1RoutingConfig"
        },
        "lastModifierIdentity": {
          "type": "string",
          "description": "Identity of the last client who modified the configuration of this Deployment. Set to the\n`identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and\n`SetWorkerDeploymentRampingVersion`."
        }
      },
      "description": "A Worker Deployment (Deployment, for short) represents all workers serving \na shared set of Task Queues. Typically, a Deployment represents one service or \napplication.\nA Deployment contains multiple Deployment Versions, each representing a different \nversion of workers. (see documentation of WorkerDeploymentVersionInfo)\nDeployment records are created in Temporal server automatically when their\nfirst poller arrives to the server.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
    },
    "v1WorkerDeploymentOptions": {
      "type": "object",
      "properties": {
        "deploymentName": {
          "type": "string",
          "description": "Required. Worker Deployment name."
        },
        "buildId": {
          "type": "string",
          "description": "The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,\nthe worker will be part of a Deployment Version."
        },
        "workerVersioningMode": {
          "$ref": "#/definitions/v1WorkerVersioningMode",
          "description": "Required. Versioning Mode for this worker. Must be the same for all workers with the\nsame `deployment_name` and `build_id` combination, across all Task Queues.\nWhen `worker_versioning_mode==VERSIONED`, the worker will be part of a Deployment Version."
        }
      },
      "description": "Worker Deployment options set in SDK that need to be sent to server in every poll.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
    },
    "v1WorkerDeploymentVersion": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "A unique identifier for this Version within the Deployment it is a part of.\nNot necessarily unique within the namespace.\nThe combination of `deployment_name` and `build_id` uniquely identifies this\nVersion within the namespace, because Deployment names are unique within a namespace."
        },
        "deploymentName": {
          "type": "string",
          "description": "Identifies the Worker Deployment this Version is part of."
        }
      },
      "description": "A Worker Deployment Version (Version, for short) represents a\nversion of workers within a Worker Deployment. (see documentation of WorkerDeploymentVersionInfo)\nVersion records are created in Temporal server automatically when their\nfirst poller arrives to the server.\nExperimental. Worker Deployment Versions are experimental and might significantly change in the future."
    },
    "v1WorkerDeploymentVersionInfo": {
      "type": "object",
      "properties": {
        "version": {
          "type": "string",
          "description": "Deprecated. Use `deployment_version`."
        },
        "status": {
          "$ref": "#/definitions/v1WorkerDeploymentVersionStatus",
          "description": "The status of the Worker Deployment Version."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "Required."
        },
        "deploymentName": {
          "type": "string"
        },
        "createTime": {
          "type": "string",
          "format": "date-time"
        },
        "routingChangedTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed."
        },
        "currentSinceTime": {
          "type": "string",
          "format": "date-time",
          "description": "\nUnset if not current."
        },
        "rampingSinceTime": {
          "type": "string",
          "format": "date-time",
          "description": "\nUnset if not ramping. Updated when the version first starts ramping, not on each ramp change."
        },
        "firstActivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this version first became current or ramping."
        },
        "lastDeactivationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when this version last stopped being current or ramping."
        },
        "rampPercentage": {
          "type": "number",
          "format": "float",
          "description": "Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).\nCan be in the range [0, 100] if the version is ramping."
        },
        "taskQueueInfos": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/WorkerDeploymentVersionInfoVersionTaskQueueInfo"
          },
          "description": "All the Task Queues that have ever polled from this Deployment version.\nDeprecated. Use `version_task_queues` in DescribeWorkerDeploymentVersionResponse instead."
        },
        "drainageInfo": {
          "$ref": "#/definitions/v1VersionDrainageInfo",
          "description": "Helps user determine when it is safe to decommission the workers of this\nVersion. Not present when version is current or ramping.\nCurrent limitations:\n- Not supported for Unversioned mode.\n- Periodically refreshed, may have delays up to few minutes (consult the\n  last_checked_time value).\n- Refreshed only when version is not current or ramping AND the status is not\n  \"drained\" yet.\n- Once the status is changed to \"drained\", it is not changed until the Version\n  becomes Current or Ramping again, at which time the drainage info is cleared.\n  This means if the Version is \"drained\" but new workflows are sent to it via\n  Pinned Versioning Override, the status does not account for those Pinned-override\n  executions and remains \"drained\"."
        },
        "metadata": {
          "$ref": "#/definitions/v1VersionMetadata",
          "description": "Arbitrary user-provided metadata attached to this version."
        }
      },
      "description": "A Worker Deployment Version (Version, for short) represents all workers of the same \ncode and config within a Deployment. Workers of the same Version are expected to \nbehave exactly the same so when executions move between them there are no \nnon-determinism issues.\nWorker Deployment Versions are created in Temporal server automatically when \ntheir first poller arrives to the server.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
    },
    "v1WorkerDeploymentVersionStatus": {
      "type": "string",
      "enum": [
        "WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED",
        "WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE",
        "WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT",
        "WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING",
        "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING",
        "WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED"
      ],
      "default": "WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED",
      "description": "Specify the status of a Worker Deployment Version.\nExperimental. Worker Deployments are experimental and might significantly change in the future.\n\n - WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE: The Worker Deployment Version has been created inside the Worker Deployment but is not used by any\nworkflow executions. These Versions can still have workflows if they have an explicit Versioning Override targeting\nthis Version. Such Versioning Override could be set at workflow start time, or at a later time via `UpdateWorkflowExecutionOptions`.\n - WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT: The Worker Deployment Version is the current version of the Worker Deployment. All new workflow executions \nand tasks of existing unversioned or AutoUpgrade workflows are routed to this version.\n - WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING: The Worker Deployment Version is the ramping version of the Worker Deployment. A subset of new Pinned workflow executions are \nrouted to this version. Moreover, a portion of existing unversioned or AutoUpgrade workflow executions are also routed to this version.\n - WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING: The Worker Deployment Version is not used by new workflows but is still used by\nopen pinned workflows. The version cannot be decommissioned safely.\n - WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED: The Worker Deployment Version is not used by new or open workflows, but might be still needed by\nQueries sent to closed workflows. The version can be decommissioned safely if user does\nnot query closed workflows. If the user does query closed workflows for some time x after\nworkflows are closed, they should decommission the version after it has been drained for that duration."
    },
    "v1WorkerHeartbeat": {
      "type": "object",
      "properties": {
        "workerInstanceKey": {
          "type": "string",
          "description": "Worker identifier, should be unique for the namespace.\nIt is distinct from worker identity, which is not necessarily namespace-unique."
        },
        "workerIdentity": {
          "type": "string",
          "description": "Worker identity, set by the client, may not be unique.\nUsually host_name+(user group name)+process_id, but can be overwritten by the user."
        },
        "hostInfo": {
          "$ref": "#/definitions/v1WorkerHostInfo",
          "description": "Worker host information."
        },
        "taskQueue": {
          "type": "string",
          "description": "Task queue this worker is polling for tasks."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion"
        },
        "sdkName": {
          "type": "string"
        },
        "sdkVersion": {
          "type": "string"
        },
        "status": {
          "$ref": "#/definitions/v1WorkerStatus",
          "description": "Worker status. Defined by SDK."
        },
        "startTime": {
          "type": "string",
          "format": "date-time",
          "title": "Worker start time.\nIt can be used to determine worker uptime. (current time - start time)"
        },
        "heartbeatTime": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of this heartbeat, coming from the worker. Worker should set it to \"now\".\nNote that this timestamp comes directly from the worker and is subject to workers' clock skew."
        },
        "elapsedSinceLastHeartbeat": {
          "type": "string",
          "description": "Elapsed time since the last heartbeat from the worker."
        },
        "workflowTaskSlotsInfo": {
          "$ref": "#/definitions/v1WorkerSlotsInfo"
        },
        "activityTaskSlotsInfo": {
          "$ref": "#/definitions/v1WorkerSlotsInfo"
        },
        "nexusTaskSlotsInfo": {
          "$ref": "#/definitions/v1WorkerSlotsInfo"
        },
        "localActivitySlotsInfo": {
          "$ref": "#/definitions/v1WorkerSlotsInfo"
        },
        "workflowPollerInfo": {
          "$ref": "#/definitions/v1WorkerPollerInfo"
        },
        "workflowStickyPollerInfo": {
          "$ref": "#/definitions/v1WorkerPollerInfo"
        },
        "activityPollerInfo": {
          "$ref": "#/definitions/v1WorkerPollerInfo"
        },
        "nexusPollerInfo": {
          "$ref": "#/definitions/v1WorkerPollerInfo"
        },
        "totalStickyCacheHit": {
          "type": "integer",
          "format": "int32",
          "description": "A Workflow Task found a cached Workflow Execution to run against."
        },
        "totalStickyCacheMiss": {
          "type": "integer",
          "format": "int32",
          "description": "A Workflow Task did not find a cached Workflow execution to run against."
        },
        "currentStickyCacheSize": {
          "type": "integer",
          "format": "int32",
          "description": "Current cache size, expressed in number of Workflow Executions."
        },
        "plugins": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1PluginInfo"
          },
          "description": "Plugins currently in use by this SDK."
        }
      },
      "description": "Worker info message, contains information about the worker and its current state.\nAll information is provided by the worker itself."
    },
    "v1WorkerHostInfo": {
      "type": "object",
      "properties": {
        "hostName": {
          "type": "string",
          "description": "Worker host identifier."
        },
        "processKey": {
          "type": "string",
          "title": "Worker process identifier. This id should be unique for all _processes_\nrunning workers in the namespace, and should be shared by all workers\nin the same process.\nThis will be used to build the worker command nexus task queue name:\n\"temporal-sys/worker-commands/{process_key}\""
        },
        "processId": {
          "type": "string",
          "description": "Worker process identifier. Unlike process_key, this id only needs to be unique\nwithin one host (so using e.g. a unix pid would be appropriate)."
        },
        "currentHostCpuUsage": {
          "type": "number",
          "format": "float",
          "description": "System used CPU as a float in the range [0.0, 1.0] where 1.0 is defined as all\ncores on the host pegged."
        },
        "currentHostMemUsage": {
          "type": "number",
          "format": "float",
          "description": "System used memory as a float in the range [0.0, 1.0] where 1.0 is defined as\nall available memory on the host is used."
        }
      },
      "title": "Holds everything needed to identify the worker host/process context"
    },
    "v1WorkerInfo": {
      "type": "object",
      "properties": {
        "workerHeartbeat": {
          "$ref": "#/definitions/v1WorkerHeartbeat"
        }
      }
    },
    "v1WorkerPollerInfo": {
      "type": "object",
      "properties": {
        "currentPollers": {
          "type": "integer",
          "format": "int32",
          "description": "Number of polling RPCs that are currently in flight."
        },
        "lastSuccessfulPollTime": {
          "type": "string",
          "format": "date-time"
        },
        "isAutoscaling": {
          "type": "boolean",
          "title": "Set true if the number of concurrent pollers is auto-scaled"
        }
      }
    },
    "v1WorkerSelector": {
      "type": "object",
      "properties": {
        "workerInstanceKey": {
          "type": "string",
          "description": "Worker instance key to which the command should be sent."
        }
      },
      "description": "This is used to send commands to a specific worker or a group of workers.\nRight now, it is used to send commands to a specific worker instance.\nWill be extended to be able to send command to multiple workers."
    },
    "v1WorkerSlotsInfo": {
      "type": "object",
      "properties": {
        "currentAvailableSlots": {
          "type": "integer",
          "format": "int32",
          "description": "Number of slots available for the worker to specific tasks.\nMay be -1 if the upper bound is not known."
        },
        "currentUsedSlots": {
          "type": "integer",
          "format": "int32",
          "description": "Number of slots used by the worker for specific tasks."
        },
        "slotSupplierKind": {
          "type": "string",
          "title": "Kind of the slot supplier, which is used to determine how the slots are allocated.\nPossible values: \"Fixed | ResourceBased | Custom String\""
        },
        "totalProcessedTasks": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of tasks processed (completed both successfully and unsuccesfully, or any other way)\nby the worker since the worker started. This is a cumulative counter."
        },
        "totalFailedTasks": {
          "type": "integer",
          "format": "int32",
          "description": "Total number of failed tasks processed by the worker so far."
        },
        "lastIntervalProcessedTasks": {
          "type": "integer",
          "format": "int32",
          "description": "Number of tasks processed in since the last heartbeat from the worker.\nThis is a cumulative counter, and it is reset to 0 each time the worker sends a heartbeat.\nContains both successful and failed tasks."
        },
        "lastIntervalFailureTasks": {
          "type": "integer",
          "format": "int32",
          "description": "Number of failed tasks processed since the last heartbeat from the worker."
        }
      }
    },
    "v1WorkerStatus": {
      "type": "string",
      "enum": [
        "WORKER_STATUS_UNSPECIFIED",
        "WORKER_STATUS_RUNNING",
        "WORKER_STATUS_SHUTTING_DOWN",
        "WORKER_STATUS_SHUTDOWN"
      ],
      "default": "WORKER_STATUS_UNSPECIFIED"
    },
    "v1WorkerVersionCapabilities": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "title": "An opaque whole-worker identifier"
        },
        "useVersioning": {
          "type": "boolean",
          "description": "If set, the worker is opting in to worker versioning, and wishes to only receive appropriate\ntasks."
        },
        "deploymentSeriesName": {
          "type": "string",
          "description": "Must be sent if user has set a deployment series name (versioning-3)."
        }
      },
      "description": "Identifies the version that a worker is compatible with when polling or identifying itself,\nand whether or not this worker is opting into the build-id based versioning feature. This is\nused by matching to determine which workers ought to receive what tasks.\nDeprecated. Use WorkerDeploymentOptions instead."
    },
    "v1WorkerVersionStamp": {
      "type": "object",
      "properties": {
        "buildId": {
          "type": "string",
          "description": "An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this\nmessage is included in requests which previously used that."
        },
        "useVersioning": {
          "type": "boolean",
          "description": "If set, the worker is opting in to worker versioning. Otherwise, this is used only as a\nmarker for workflow reset points and the BuildIDs search attribute."
        }
      },
      "title": "Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.\nIdentifies the version(s) of a worker that processed a task"
    },
    "v1WorkerVersioningMode": {
      "type": "string",
      "enum": [
        "WORKER_VERSIONING_MODE_UNSPECIFIED",
        "WORKER_VERSIONING_MODE_UNVERSIONED",
        "WORKER_VERSIONING_MODE_VERSIONED"
      ],
      "default": "WORKER_VERSIONING_MODE_UNSPECIFIED",
      "description": "Versioning Mode of a worker is set by the app developer in the worker code, and specifies the\nbehavior of the system in the following related aspects:\n- Whether or not Temporal Server considers this worker's version (Build ID) when dispatching\n  tasks to it.\n- Whether or not the workflows processed by this worker are versioned using the worker's version.\nExperimental. Worker Deployments are experimental and might significantly change in the future.\n\n - WORKER_VERSIONING_MODE_UNVERSIONED: Workers with this mode are not distinguished from each other for task routing, even if they\nhave different Build IDs.\nWorkflows processed by this worker will be unversioned and user needs to use Patching to keep\nthe new code compatible with prior versions.\nThis mode is recommended to be used along with Rolling Upgrade deployment strategies.\nWorkers with this mode are represented by the special string `__unversioned__` in the APIs.\n - WORKER_VERSIONING_MODE_VERSIONED: Workers with this mode are part of a Worker Deployment Version which is identified as\n\"<deployment_name>.<build_id>\". Such workers are called \"versioned\" as opposed to\n\"unversioned\".\nEach Deployment Version is distinguished from other Versions for task routing and users can\nconfigure Temporal Server to send tasks to a particular Version (see\n`WorkerDeploymentInfo.routing_config`). This mode is the best option for Blue/Green and\nRainbow strategies (but typically not suitable for Rolling upgrades.)\nWorkflow Versioning Behaviors are enabled in this mode: each workflow type must choose\nbetween the Pinned and AutoUpgrade behaviors. Depending on the chosen behavior, the user may\nor may not need to use Patching to keep the new code compatible with prior versions. (see\nVersioningBehavior enum.)"
    },
    "v1WorkflowExecution": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      },
      "description": "Identifies a specific workflow within a namespace. Practically speaking, because run_id is a\nuuid, a workflow execution is globally unique. Note that many commands allow specifying an empty\nrun id as a way of saying \"target the latest run of the workflow\"."
    },
    "v1WorkflowExecutionCancelRequestedEventAttributes": {
      "type": "object",
      "properties": {
        "cause": {
          "type": "string",
          "title": "User provided reason for requesting cancellation\nTODO: shall we create a new field with name \"reason\" and deprecate this one?"
        },
        "externalInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?"
        },
        "externalWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker or client who requested this cancel"
        }
      }
    },
    "v1WorkflowExecutionCanceledEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        }
      }
    },
    "v1WorkflowExecutionCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "result": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Serialized result of workflow completion (ie: The return value of the workflow function)"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionConfig": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "workflowExecutionTimeout": {
          "type": "string"
        },
        "workflowRunTimeout": {
          "type": "string"
        },
        "defaultWorkflowTaskTimeout": {
          "type": "string"
        },
        "userMetadata": {
          "$ref": "#/definitions/v1UserMetadata",
          "description": "User metadata provided on start workflow."
        }
      }
    },
    "v1WorkflowExecutionContinuedAsNewEventAttributes": {
      "type": "object",
      "properties": {
        "newExecutionRunId": {
          "type": "string",
          "title": "The run ID of the new workflow started by this continue-as-new"
        },
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads"
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "backoffStartInterval": {
          "type": "string",
          "title": "TODO: How and is this used?"
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "TODO: David are these right?\nDeprecated. If a workflow's retry policy would cause a new run to start when the current one\nhas failed, this field would be populated with that failure. Now (when supported by server\nand sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set."
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads",
          "title": "TODO: Is this the result of *this* workflow as it continued-as-new?"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "inheritBuildId": {
          "type": "boolean",
          "description": "If this is set, the new execution inherits the Build ID of the current execution. Otherwise,\nthe assignment rules will be used to independently assign a Build ID to the new execution.\nDeprecated. Only considered for versioning v0.2."
        }
      }
    },
    "v1WorkflowExecutionExtendedInfo": {
      "type": "object",
      "properties": {
        "executionExpirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Workflow execution expiration time is defined as workflow start time plus expiration timeout.\nWorkflow start time may change after workflow reset."
        },
        "runExpirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Workflow run expiration time is defined as current workflow run start time plus workflow run timeout."
        },
        "cancelRequested": {
          "type": "boolean",
          "title": "indicates if the workflow received a cancel request"
        },
        "lastResetTime": {
          "type": "string",
          "format": "date-time",
          "description": "Last workflow reset time. Nil if the workflow was never reset."
        },
        "originalStartTime": {
          "type": "string",
          "format": "date-time",
          "description": "Original workflow start time."
        },
        "resetRunId": {
          "type": "string",
          "description": "Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run."
        },
        "requestIdInfos": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/v1RequestIdInfo"
          },
          "description": "Request ID information (eg: history event information associated with the request ID).\nNote: It only contains request IDs from StartWorkflowExecution requests, including indirect\ncalls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is\nused in the StartWorkflowExecution request)."
        }
      },
      "description": "Holds all the extra information about workflow execution that is not part of Visibility."
    },
    "v1WorkflowExecutionFailedEventAttributes": {
      "type": "object",
      "properties": {
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "Serialized result of workflow failure (ex: An exception thrown, or error returned)"
        },
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionFilter": {
      "type": "object",
      "properties": {
        "workflowId": {
          "type": "string"
        },
        "runId": {
          "type": "string"
        }
      }
    },
    "v1WorkflowExecutionInfo": {
      "type": "object",
      "properties": {
        "execution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "type": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "startTime": {
          "type": "string",
          "format": "date-time"
        },
        "closeTime": {
          "type": "string",
          "format": "date-time"
        },
        "status": {
          "$ref": "#/definitions/v1WorkflowExecutionStatus"
        },
        "historyLength": {
          "type": "string",
          "format": "int64"
        },
        "parentNamespaceId": {
          "type": "string"
        },
        "parentExecution": {
          "$ref": "#/definitions/v1WorkflowExecution"
        },
        "executionTime": {
          "type": "string",
          "format": "date-time"
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "autoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "taskQueue": {
          "type": "string"
        },
        "stateTransitionCount": {
          "type": "string",
          "format": "int64"
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64"
        },
        "mostRecentWorkerVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "If set, the most recent worker version stamp that appeared in a workflow task completion\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "executionDuration": {
          "type": "string",
          "description": "Workflow execution duration is defined as difference between close time and execution time.\nThis field is only populated if the workflow is closed."
        },
        "rootExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about the root workflow execution.\nThe root workflow execution is defined as follows:\n1. A workflow without parent workflow is its own root workflow.\n2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\nNote: workflows continued as new or reseted may or may not have parents, check examples below.\n\nExamples:\n  Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n    - The root workflow of all three workflows is W1.\n  Scenario 3: Workflow W1 continued as new W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n  Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n    - The root workflow of all three workflows is W1.\n  Scenario 5: Workflow W1 is reseted, creating W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2."
        },
        "assignedBuildId": {
          "type": "string",
          "title": "The currently assigned build ID for this execution. Presence of this value means worker versioning is used\nfor this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules\nwhen the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled\nagain, the assigned build ID may change according to the latest versioning rules.\nAssigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to\nthis execution.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "inheritedBuildId": {
          "type": "string",
          "title": "Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead\nof using the assignment rules.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "firstRunId": {
          "type": "string",
          "title": "The first run ID in the execution chain.\nExecutions created via the following operations are considered to be in the same chain\n- ContinueAsNew\n- Workflow Retry\n- Workflow Reset\n- Cron Schedule"
        },
        "versioningInfo": {
          "$ref": "#/definitions/v1WorkflowExecutionVersioningInfo",
          "description": "Absent value means the workflow execution is not versioned. When present, the execution might\nbe versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.\nExperimental. Versioning info is experimental and might change in the future."
        },
        "workerDeploymentName": {
          "type": "string",
          "description": "The name of Worker Deployment that completed the most recent workflow task.\nExperimental. Worker Deployments are experimental and might change in the future."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        }
      },
      "description": "Hold basic information about a workflow execution.\nThis structure is a part of visibility, and thus contain a limited subset of information."
    },
    "v1WorkflowExecutionOptions": {
      "type": "object",
      "properties": {
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion."
        }
      }
    },
    "v1WorkflowExecutionOptionsUpdatedEventAttributes": {
      "type": "object",
      "properties": {
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "Versioning override upserted in this event.\nIgnored if nil or if unset_versioning_override is true."
        },
        "unsetVersioningOverride": {
          "type": "boolean",
          "description": "Versioning override removed in this event."
        },
        "attachedRequestId": {
          "type": "string",
          "description": "Request ID attachedto the running workflow execution so that subsequent requests with same\nrequest ID will be deduped."
        },
        "attachedCompletionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Completion callbacks attached to the running workflow execution."
        }
      }
    },
    "v1WorkflowExecutionSignaledEventAttributes": {
      "type": "object",
      "properties": {
        "signalName": {
          "type": "string",
          "title": "The name/type of the signal to fire"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "Will be deserialized and provided as argument(s) to the signal handler"
        },
        "identity": {
          "type": "string",
          "title": "id of the worker/client who sent this signal"
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the sender of the signal and copied by temporal\nserver into the workflow task."
        },
        "skipGenerateWorkflowTask": {
          "type": "boolean",
          "description": "Deprecated. This field is never respected and should always be set to false."
        },
        "externalWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "When signal origin is a workflow execution, this field is set."
        }
      }
    },
    "v1WorkflowExecutionStartedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowType": {
          "$ref": "#/definitions/v1WorkflowType"
        },
        "parentWorkflowNamespace": {
          "type": "string",
          "description": "If this workflow is a child, the namespace our parent lives in.\nSDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only."
        },
        "parentWorkflowNamespaceId": {
          "type": "string"
        },
        "parentWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about parent workflow execution that initiated the child workflow these attributes belong to.\nIf the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated."
        },
        "parentInitiatedEventId": {
          "type": "string",
          "format": "int64",
          "title": "EventID of the child execution initiated event in parent workflow"
        },
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue"
        },
        "input": {
          "$ref": "#/definitions/v1Payloads",
          "title": "SDK will deserialize this and provide it as arguments to the workflow function"
        },
        "workflowExecutionTimeout": {
          "type": "string",
          "description": "Total workflow execution timeout including retries and continue as new."
        },
        "workflowRunTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow run."
        },
        "workflowTaskTimeout": {
          "type": "string",
          "description": "Timeout of a single workflow task."
        },
        "continuedExecutionRunId": {
          "type": "string",
          "description": "Run id of the previous workflow which continued-as-new or retried or cron executed into this\nworkflow."
        },
        "initiator": {
          "$ref": "#/definitions/v1ContinueAsNewInitiator"
        },
        "continuedFailure": {
          "$ref": "#/definitions/apifailurev1Failure"
        },
        "lastCompletionResult": {
          "$ref": "#/definitions/v1Payloads"
        },
        "originalExecutionRunId": {
          "type": "string",
          "description": "This is the run id when the WorkflowExecutionStarted event was written.\nA workflow reset changes the execution run_id, but preserves this field."
        },
        "identity": {
          "type": "string",
          "title": "Identity of the client who requested this execution"
        },
        "firstExecutionRunId": {
          "type": "string",
          "description": "This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.\nUsed to identify a chain."
        },
        "retryPolicy": {
          "$ref": "#/definitions/v1RetryPolicy"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, the number of times we have tried to execute this workflow"
        },
        "workflowExecutionExpirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "The absolute time at which the workflow will be timed out.\nThis is passed without change to the next run/retry of a workflow."
        },
        "cronSchedule": {
          "type": "string",
          "title": "If this workflow runs on a cron schedule, it will appear here"
        },
        "firstWorkflowTaskBackoff": {
          "type": "string",
          "description": "For a cron workflow, this contains the amount of time between when this iteration of\nthe cron workflow was scheduled and when it should run next per its cron_schedule."
        },
        "memo": {
          "$ref": "#/definitions/v1Memo"
        },
        "searchAttributes": {
          "$ref": "#/definitions/v1SearchAttributes"
        },
        "prevAutoResetPoints": {
          "$ref": "#/definitions/v1ResetPoints"
        },
        "header": {
          "$ref": "#/definitions/v1Header"
        },
        "parentInitiatedEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "Version of the child execution initiated event in parent workflow\nIt should be used together with parent_initiated_event_id to identify\na child initiated event for global namespace"
        },
        "workflowId": {
          "type": "string",
          "description": "This field is new in 1.21."
        },
        "sourceVersionStamp": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "If this workflow intends to use anything other than the current overall default version for\nthe queue, then we include it here.\nDeprecated. [cleanup-experimental-wv]"
        },
        "completionCallbacks": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1Callback"
          },
          "description": "Completion callbacks attached when this workflow was started."
        },
        "rootWorkflowExecution": {
          "$ref": "#/definitions/v1WorkflowExecution",
          "description": "Contains information about the root workflow execution.\nThe root workflow execution is defined as follows:\n  1. A workflow without parent workflow is its own root workflow.\n  2. A workflow that has a parent workflow has the same root workflow as its parent workflow.\nWhen the workflow is its own root workflow, then root_workflow_execution is nil.\nNote: workflows continued as new or reseted may or may not have parents, check examples below.\n\nExamples:\n  Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.\n    - The root workflow of all three workflows is W1.\n    - W1 has root_workflow_execution set to nil.\n    - W2 and W3 have root_workflow_execution set to W1.\n  Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.\n    - The root workflow of all three workflows is W1.\n    - W1 has root_workflow_execution set to nil.\n    - W2 and W3 have root_workflow_execution set to W1.\n  Scenario 3: Workflow W1 continued as new W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n    - W1 and W2 have root_workflow_execution set to nil.\n  Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3\n    - The root workflow of all three workflows is W1.\n    - W1 has root_workflow_execution set to nil.\n    - W2 and W3 have root_workflow_execution set to W1.\n  Scenario 5: Workflow W1 is reseted, creating W2.\n    - The root workflow of W1 is W1 and the root workflow of W2 is W2.\n    - W1 and W2 have root_workflow_execution set to nil."
        },
        "inheritedBuildId": {
          "type": "string",
          "title": "When present, this execution is assigned to the build ID of its parent or previous execution.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "Versioning override applied to this workflow when it was started.\nChildren, crons, retries, and continue-as-new will inherit source run's override if pinned\nand if the new workflow's Task Queue belongs to the override version."
        },
        "parentPinnedWorkerDeploymentVersion": {
          "type": "string",
          "description": "When present, it means this is a child workflow of a parent that is Pinned to this Worker\nDeployment Version. In this case, child workflow will start as Pinned to this Version instead\nof starting on the Current Version of its Task Queue.\nThis is set only if the child workflow is starting on a Task Queue belonging to the same\nWorker Deployment Version.\nDeprecated. Use `parent_versioning_info`."
        },
        "priority": {
          "$ref": "#/definitions/v1Priority",
          "title": "Priority metadata"
        },
        "inheritedPinnedVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "If present, the new workflow should start on this version with pinned base behavior.\nChild of pinned parent will inherit the parent's version if the Child's Task Queue belongs to that version.\n\nNew run initiated by workflow ContinueAsNew of pinned run, will inherit the previous run's version if the\nnew run's Task Queue belongs to that version.\n\nNew run initiated by workflow Cron will never inherit.\n\nNew run initiated by workflow Retry will only inherit if the retried run is effectively pinned at the time\nof retry, and the retried run inherited a pinned version when it started (ie. it is a child of a pinned\nparent, or a CaN of a pinned run, and is running on a Task Queue in the inherited version).\n\nPinned override is inherited if Task Queue of new run is compatible with the override version.\nOverride is inherited separately and takes precedence over inherited base version."
        },
        "eagerExecutionAccepted": {
          "type": "boolean",
          "description": "A boolean indicating whether the SDK has asked to eagerly execute the first workflow task for this workflow and\neager execution was accepted by the server.\nOnly populated by server with version >= 1.29.0."
        }
      },
      "title": "Always the first event in workflow history"
    },
    "v1WorkflowExecutionStatus": {
      "type": "string",
      "enum": [
        "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
        "WORKFLOW_EXECUTION_STATUS_RUNNING",
        "WORKFLOW_EXECUTION_STATUS_COMPLETED",
        "WORKFLOW_EXECUTION_STATUS_FAILED",
        "WORKFLOW_EXECUTION_STATUS_CANCELED",
        "WORKFLOW_EXECUTION_STATUS_TERMINATED",
        "WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW",
        "WORKFLOW_EXECUTION_STATUS_TIMED_OUT"
      ],
      "default": "WORKFLOW_EXECUTION_STATUS_UNSPECIFIED",
      "description": " - WORKFLOW_EXECUTION_STATUS_RUNNING: Value 1 is hardcoded in SQL persistence."
    },
    "v1WorkflowExecutionTerminatedEventAttributes": {
      "type": "object",
      "properties": {
        "reason": {
          "type": "string",
          "title": "User/client provided reason for termination"
        },
        "details": {
          "$ref": "#/definitions/v1Payloads"
        },
        "identity": {
          "type": "string",
          "title": "id of the client who requested termination"
        }
      }
    },
    "v1WorkflowExecutionTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "retryState": {
          "$ref": "#/definitions/v1RetryState"
        },
        "newExecutionRunId": {
          "type": "string",
          "description": "If another run is started by cron or retry, this contains the new run id."
        }
      }
    },
    "v1WorkflowExecutionUpdateAcceptedEventAttributes": {
      "type": "object",
      "properties": {
        "protocolInstanceId": {
          "type": "string",
          "description": "The instance ID of the update protocol that generated this event."
        },
        "acceptedRequestMessageId": {
          "type": "string",
          "description": "The message ID of the original request message that initiated this\nupdate. Needed so that the worker can recreate and deliver that same\nmessage as part of replay."
        },
        "acceptedRequestSequencingEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID used to sequence the original request message."
        },
        "acceptedRequest": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The message payload of the original request message that initiated this\nupdate."
        }
      }
    },
    "v1WorkflowExecutionUpdateAdmittedEventAttributes": {
      "type": "object",
      "properties": {
        "request": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The update request associated with this event."
        },
        "origin": {
          "$ref": "#/definitions/v1UpdateAdmittedEventOrigin",
          "description": "An explanation of why this event was written to history."
        }
      }
    },
    "v1WorkflowExecutionUpdateCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "meta": {
          "$ref": "#/definitions/v1Meta",
          "description": "The metadata about this update."
        },
        "acceptedEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID indicating the acceptance of this update."
        },
        "outcome": {
          "$ref": "#/definitions/v1Outcome",
          "description": "The outcome of executing the workflow update function."
        }
      }
    },
    "v1WorkflowExecutionUpdateRejectedEventAttributes": {
      "type": "object",
      "properties": {
        "protocolInstanceId": {
          "type": "string",
          "description": "The instance ID of the update protocol that generated this event."
        },
        "rejectedRequestMessageId": {
          "type": "string",
          "description": "The message ID of the original request message that initiated this\nupdate. Needed so that the worker can recreate and deliver that same\nmessage as part of replay."
        },
        "rejectedRequestSequencingEventId": {
          "type": "string",
          "format": "int64",
          "description": "The event ID used to sequence the original request message."
        },
        "rejectedRequest": {
          "$ref": "#/definitions/apiupdatev1Request",
          "description": "The message payload of the original request message that initiated this\nupdate."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The cause of rejection."
        }
      }
    },
    "v1WorkflowExecutionVersioningInfo": {
      "type": "object",
      "properties": {
        "behavior": {
          "$ref": "#/definitions/v1VersioningBehavior",
          "description": "Versioning behavior determines how the server should treat this execution when workers are\nupgraded. When present it means this workflow execution is versioned; UNSPECIFIED means\nunversioned. See the comments in `VersioningBehavior` enum for more info about different\nbehaviors.\nThis field is first set after an execution completes its first workflow task on a versioned\nworker, and set again on completion of every subsequent workflow task.\nFor child workflows of Pinned parents, this will be set to Pinned (along with `deployment_version`) when\nthe the child starts so that child's first workflow task goes to the same Version as the\nparent. After the first workflow task, it depends on the child workflow itself if it wants\nto stay pinned or become unpinned (according to Versioning Behavior set in the worker).\nNote that `behavior` is overridden by `versioning_override` if the latter is present."
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "The worker deployment that completed the last workflow task of this workflow execution. Must\nbe present if `behavior` is set. Absent value means no workflow task is completed, or the\nlast workflow task was completed by an unversioned worker. Unversioned workers may still send\na deployment value which will be stored here, so the right way to check if an execution is\nversioned if an execution is versioned or not is via the `behavior` field.\nNote that `deployment` is overridden by `versioning_override` if the latter is present.\nDeprecated. Use `deployment_version`."
        },
        "version": {
          "type": "string",
          "description": "Deprecated. Use `deployment_version`."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The Worker Deployment Version that completed the last workflow task of this workflow execution.\nAn absent value means no workflow task is completed, or the workflow is unversioned.\nIf present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed\nby a worker that is not using versioning but _is_ passing Deployment Name and Build ID.\n\nFor child workflows of Pinned parents, this will be set to the parent's Pinned Version when\nthe child starts, so that the child's first workflow task goes to the same Version as the parent.\nNote that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`\nwill override this value."
        },
        "versioningOverride": {
          "$ref": "#/definitions/v1VersioningOverride",
          "description": "Present if user has set an execution-specific versioning override. This override takes\nprecedence over SDK-sent `behavior` (and `version` when override is PINNED). An\noverride can be set when starting a new execution, as well as afterwards by calling the\n`UpdateWorkflowExecutionOptions` API.\nPinned overrides are automatically inherited by child workflows, continue-as-new workflows,\nworkflow retries, and cron workflows."
        },
        "deploymentTransition": {
          "$ref": "#/definitions/v1DeploymentTransition",
          "description": "When present, indicates the workflow is transitioning to a different deployment. Can\nindicate one of the following transitions: unversioned -> versioned, versioned -> versioned\non a different deployment, or versioned -> unversioned.\nNot applicable to workflows with PINNED behavior.\nWhen a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically\nstart a transition to the task queue's current deployment if the task queue's current\ndeployment is different from the workflow's deployment.\nIf the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those\ntasks will be redirected to the task queue's current deployment. As soon as a poller from\nthat deployment is available to receive the task, the workflow will automatically start a\ntransition to that deployment and continue execution there.\nA deployment transition can only exist while there is a pending or started workflow task.\nOnce the pending workflow task completes on the transition's target deployment, the\ntransition completes and the workflow's `deployment` and `behavior` fields are updated per\nthe worker's task completion response.\nPending activities will not start new attempts during a transition. Once the transition is\ncompleted, pending activities will start their next attempt on the new deployment.\nDeprecated. Use version_transition."
        },
        "versionTransition": {
          "$ref": "#/definitions/v1DeploymentVersionTransition",
          "description": "When present, indicates the workflow is transitioning to a different deployment version\n(which may belong to the same deployment name or another). Can indicate one of the following\ntransitions: unversioned -> versioned, versioned -> versioned\non a different deployment version, or versioned -> unversioned.\nNot applicable to workflows with PINNED behavior.\nWhen a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically\nstart a transition to the task queue's current version if the task queue's current version is\ndifferent from the workflow's current deployment version.\nIf the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those\ntasks will be redirected to the task queue's current version. As soon as a poller from\nthat deployment version is available to receive the task, the workflow will automatically\nstart a transition to that version and continue execution there.\nA version transition can only exist while there is a pending or started workflow task.\nOnce the pending workflow task completes on the transition's target version, the\ntransition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the\nworker's task completion response.\nPending activities will not start new attempts during a transition. Once the transition is\ncompleted, pending activities will start their next attempt on the new version."
        }
      },
      "description": "Holds all the information about worker versioning for a particular workflow execution.\nExperimental. Versioning info is experimental and might change in the future."
    },
    "v1WorkflowIdConflictPolicy": {
      "type": "string",
      "enum": [
        "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
        "WORKFLOW_ID_CONFLICT_POLICY_FAIL",
        "WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING",
        "WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING"
      ],
      "default": "WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED",
      "description": "Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.\nNote that it is *never* valid to have two actively running instances of the same workflow id.\n\nSee `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.\n\n - WORKFLOW_ID_CONFLICT_POLICY_FAIL: Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.\n - WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING: Don't start a new workflow; instead return a workflow handle for the running workflow.\n - WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING: Terminate the running workflow before starting a new one."
    },
    "v1WorkflowIdReusePolicy": {
      "type": "string",
      "enum": [
        "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY",
        "WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE",
        "WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING"
      ],
      "default": "WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED",
      "description": "Defines whether to allow re-using a workflow id from a previously *closed* workflow.\nIf the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.\n\nSee `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.\n\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE: Allow starting a workflow execution using the same workflow id.\n - WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY: Allow starting a workflow execution using the same workflow id, only when the last\nexecution's final state is one of [terminated, cancelled, timed out, failed].\n - WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE: Do not permit re-use of the workflow id for this workflow. Future start workflow requests\ncould potentially change the policy, allowing re-use of the workflow id.\n - WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING: This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.\nIf specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on\nthe request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.\nIf no running workflow, then the behavior is the same as ALLOW_DUPLICATE."
    },
    "v1WorkflowPropertiesModifiedEventAttributes": {
      "type": "object",
      "properties": {
        "workflowTaskCompletedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The `WORKFLOW_TASK_COMPLETED` event which this command was reported with"
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "If set, update the workflow memo with the provided values. The values will be merged with\nthe existing memo. If the user wants to delete values, a default/empty Payload should be\nused as the value for the key being deleted."
        }
      }
    },
    "v1WorkflowPropertiesModifiedExternallyEventAttributes": {
      "type": "object",
      "properties": {
        "newTaskQueue": {
          "type": "string",
          "description": "Not used."
        },
        "newWorkflowTaskTimeout": {
          "type": "string",
          "description": "Not used."
        },
        "newWorkflowRunTimeout": {
          "type": "string",
          "description": "Not used."
        },
        "newWorkflowExecutionTimeout": {
          "type": "string",
          "description": "Not used."
        },
        "upsertedMemo": {
          "$ref": "#/definitions/v1Memo",
          "description": "Not used."
        }
      },
      "title": "Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes"
    },
    "v1WorkflowQuery": {
      "type": "object",
      "properties": {
        "queryType": {
          "type": "string",
          "description": "The workflow-author-defined identifier of the query. Typically a function name."
        },
        "queryArgs": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Serialized arguments that will be provided to the query handler."
        },
        "header": {
          "$ref": "#/definitions/v1Header",
          "description": "Headers that were passed by the caller of the query and copied by temporal\nserver into the workflow task."
        }
      },
      "title": "See https://docs.temporal.io/docs/concepts/queries/"
    },
    "v1WorkflowQueryResult": {
      "type": "object",
      "properties": {
        "resultType": {
          "$ref": "#/definitions/v1QueryResultType",
          "title": "Did the query succeed or fail?"
        },
        "answer": {
          "$ref": "#/definitions/v1Payloads",
          "description": "Set when the query succeeds with the results.\nMutually exclusive with `error_message` and `failure`."
        },
        "errorMessage": {
          "type": "string",
          "description": "Mutually exclusive with `answer`. Set when the query fails.\nSee also the newer `failure` field."
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "description": "The full reason for this query failure. This field is newer than `error_message` and can be encoded by the SDK's\nfailure converter to support E2E encryption of messages and stack traces.\nMutually exclusive with `answer`. Set when the query fails."
        }
      },
      "title": "Answer to a `WorkflowQuery`"
    },
    "v1WorkflowRule": {
      "type": "object",
      "properties": {
        "createTime": {
          "type": "string",
          "format": "date-time",
          "description": "Rule creation time."
        },
        "spec": {
          "$ref": "#/definitions/v1WorkflowRuleSpec",
          "title": "Rule specification"
        },
        "createdByIdentity": {
          "type": "string",
          "title": "Identity of the actor that created the rule"
        },
        "description": {
          "type": "string",
          "description": "Rule description."
        }
      },
      "description": "WorkflowRule describes a rule that can be applied to any workflow in this namespace."
    },
    "v1WorkflowRuleAction": {
      "type": "object",
      "properties": {
        "activityPause": {
          "$ref": "#/definitions/WorkflowRuleActionActionActivityPause"
        }
      }
    },
    "v1WorkflowRuleSpec": {
      "type": "object",
      "properties": {
        "id": {
          "type": "string",
          "description": "The id of the new workflow rule. Must be unique within the namespace.\nCan be set by the user, and can have business meaning."
        },
        "activityStart": {
          "$ref": "#/definitions/WorkflowRuleSpecActivityStartingTrigger"
        },
        "visibilityQuery": {
          "type": "string",
          "title": "Restricted Visibility query.\nThis query is used to filter workflows in this namespace to which this rule should apply.\nIt is applied to any running workflow each time a triggering event occurs, before the trigger predicate is evaluated.\nThe following workflow attributes are supported:\n- WorkflowType\n- WorkflowId\n- StartTime\n- ExecutionStatus"
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/v1WorkflowRuleAction"
          },
          "description": "WorkflowRuleAction to be taken when the rule is triggered and predicate is matched."
        },
        "expirationTime": {
          "type": "string",
          "format": "date-time",
          "description": "Expiration time of the rule. After this time, the rule will be deleted.\nCan be empty if the rule should never expire."
        }
      }
    },
    "v1WorkflowTaskCompletedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who completed this task"
        },
        "binaryChecksum": {
          "type": "string",
          "description": "Binary ID of the worker who completed this task\nDeprecated. Replaced with `deployment_version`."
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "description": "Version info of the worker who processed this workflow task. If present, the `build_id` field\nwithin is also used as `binary_checksum`, which may be omitted in that case (it may also be\npopulated to preserve compatibility).\nDeprecated. Use `deployment_version` and `versioning_behavior` instead."
        },
        "sdkMetadata": {
          "$ref": "#/definitions/v1WorkflowTaskCompletedMetadata",
          "description": "Data the SDK wishes to record for itself, but server need not interpret, and does not\ndirectly impact workflow state."
        },
        "meteringMetadata": {
          "$ref": "#/definitions/v1MeteringMetadata",
          "title": "Local usage data sent during workflow task completion and recorded here for posterity"
        },
        "deployment": {
          "$ref": "#/definitions/v1Deployment",
          "description": "The deployment that completed this task. May or may not be set for unversioned workers,\ndepending on whether a value is sent by the SDK. This value updates workflow execution's\n`versioning_info.deployment`.\nDeprecated. Replaced with `deployment_version`."
        },
        "versioningBehavior": {
          "$ref": "#/definitions/v1VersioningBehavior",
          "description": "Versioning behavior sent by the worker that completed this task for this particular workflow\nexecution. UNSPECIFIED means the task was completed by an unversioned worker. This value\nupdates workflow execution's `versioning_info.behavior`."
        },
        "workerDeploymentVersion": {
          "type": "string",
          "description": "The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`\nis set. This value updates workflow execution's `versioning_info.version`.\nExperimental. Worker Deployments are experimental and might significantly change in the future.\nDeprecated. Replaced with `deployment_version`."
        },
        "workerDeploymentName": {
          "type": "string",
          "description": "The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`\nis set. This value updates workflow execution's `worker_deployment_name`.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
        },
        "deploymentVersion": {
          "$ref": "#/definitions/v1WorkerDeploymentVersion",
          "description": "The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`\nis set. This value updates workflow execution's `versioning_info.deployment_version`.\nExperimental. Worker Deployments are experimental and might significantly change in the future."
        }
      }
    },
    "v1WorkflowTaskCompletedMetadata": {
      "type": "object",
      "properties": {
        "coreUsedFlags": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "During replay:\n* If a flag is not recognized (value is too high or not defined), it must fail the workflow\n  task.\n* If a flag is recognized, it is stored in a set of used flags for the run. Code checks for\n  that flag during and after this WFT are allowed to assume that the flag is present.\n* If a code check for a flag does not find the flag in the set of used flags, it must take\n  the branch corresponding to the absence of that flag.\n\nDuring non-replay execution of new WFTs:\n* The SDK is free to use all flags it knows about. It must record any newly-used (IE: not\n  previously recorded) flags when completing the WFT.\n\nSDKs which are too old to even know about this field at all are considered to produce\nundefined behavior if they replay workflows which used this mechanism.",
          "title": "Internal flags used by the core SDK. SDKs using flags must comply with the following behavior:"
        },
        "langUsedFlags": {
          "type": "array",
          "items": {
            "type": "integer",
            "format": "int64"
          },
          "description": "Flags used by the SDK lang. No attempt is made to distinguish between different SDK languages\nhere as processing a workflow with a different language than the one which authored it is\nalready undefined behavior. See `core_used_patches` for more.\n"
        },
        "sdkName": {
          "type": "string",
          "description": "Name of the SDK that processed the task. This is usually something like \"temporal-go\" and is\nusually the same as client-name gRPC header. This should only be set if its value changed\nsince the last time recorded on the workflow (or be set on the first task).\n"
        },
        "sdkVersion": {
          "type": "string",
          "description": "Version of the SDK that processed the task. This is usually something like \"1.20.0\" and is\nusually the same as client-version gRPC header. This should only be set if its value changed\nsince the last time recorded on the workflow (or be set on the first task)."
        }
      }
    },
    "v1WorkflowTaskFailedCause": {
      "type": "string",
      "enum": [
        "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
        "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE",
        "WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE",
        "WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY",
        "WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE",
        "WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED",
        "WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES",
        "WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED",
        "WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE"
      ],
      "default": "WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED",
      "description": "Workflow tasks can fail for various reasons. Note that some of these reasons can only originate\nfrom the server, and some of them can only originate from the SDK/worker.\n\n - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND: Between starting and completing the workflow task (with a workflow completion command), some\nnew command (like a signal) was processed into workflow history. The outstanding task will be\nfailed with this reason, and a worker must pick up a new task.\n - WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE: The worker wishes to fail the task and have the next one be generated on a normal, not sticky\nqueue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.\n - WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR: The worker encountered a mismatch while replaying history between what was expected, and\nwhat the workflow code actually did.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED: We send the below error codes to users when their requests would violate a size constraint\nof their workflow. We do this to ensure that the state of their workflow does not become too\nlarge because that can cause severe performance degradation. You can modify the thresholds for\neach of these errors within your dynamic config.\n\nSpawning a new child workflow would cause this workflow to exceed its limit of pending child\nworkflows.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED: Starting a new activity would cause this workflow to exceed its limit of pending activities\nthat we track.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED: A workflow has a buffer of signals that have not yet reached their destination. We return this\nerror when sending a new signal would exceed the capacity of this buffer.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED: Similarly, we have a buffer of pending requests to cancel other workflows. We return this error\nwhen our capacity for pending cancel requests is already reached.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE: Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)\nhas wrong format, or missing required fields.\n - WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE: Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid ScheduleNexusOperation command.\n - WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED: A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.\n - WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES: A workflow task completed with an invalid RequestCancelNexusOperation command.\n - WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED: A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -\nfor the workflow's namespace).\nCheck the workflow task failure message for more information.\n - WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE: A workflow task failed because a grpc message was too large."
    },
    "v1WorkflowTaskFailedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "cause": {
          "$ref": "#/definitions/v1WorkflowTaskFailedCause"
        },
        "failure": {
          "$ref": "#/definitions/apifailurev1Failure",
          "title": "The failure details"
        },
        "identity": {
          "type": "string",
          "title": "If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?"
        },
        "baseRunId": {
          "type": "string",
          "description": "The original run id of the workflow. For reset workflow."
        },
        "newRunId": {
          "type": "string",
          "description": "If the workflow is being reset, the new run id."
        },
        "forkEventVersion": {
          "type": "string",
          "format": "int64",
          "title": "TODO: ?"
        },
        "binaryChecksum": {
          "type": "string",
          "title": "Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]\nIf a worker explicitly failed this task, its binary id"
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker who processed this workflow task. If present, the `build_id` field\nwithin is also used as `binary_checksum`, which may be omitted in that case (it may also be\npopulated to preserve compatibility).\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1WorkflowTaskScheduledEventAttributes": {
      "type": "object",
      "properties": {
        "taskQueue": {
          "$ref": "#/definitions/v1TaskQueue",
          "title": "The task queue this workflow task was enqueued in, which could be a normal or sticky queue"
        },
        "startToCloseTimeout": {
          "type": "string",
          "title": "How long the worker has to process this task once receiving it before it times out"
        },
        "attempt": {
          "type": "integer",
          "format": "int32",
          "title": "Starting at 1, how many attempts there have been to complete this task"
        }
      }
    },
    "v1WorkflowTaskStartedEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "identity": {
          "type": "string",
          "title": "Identity of the worker who picked up this task"
        },
        "requestId": {
          "type": "string",
          "title": "TODO: ? Appears unused?"
        },
        "suggestContinueAsNew": {
          "type": "boolean",
          "description": "True if this workflow should continue-as-new soon because its history size (in\neither event count or bytes) is getting large."
        },
        "historySizeBytes": {
          "type": "string",
          "format": "int64",
          "description": "Total history size in bytes, which the workflow might use to decide when to\ncontinue-as-new regardless of the suggestion. Note that history event count is\njust the event id of this event, so we don't include it explicitly here."
        },
        "workerVersion": {
          "$ref": "#/definitions/v1WorkerVersionStamp",
          "title": "Version info of the worker to whom this task was dispatched.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        },
        "buildIdRedirectCounter": {
          "type": "string",
          "format": "int64",
          "title": "Used by server internally to properly reapply build ID redirects to an execution\nwhen rebuilding it from events.\nDeprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]"
        }
      }
    },
    "v1WorkflowTaskTimedOutEventAttributes": {
      "type": "object",
      "properties": {
        "scheduledEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to"
        },
        "startedEventId": {
          "type": "string",
          "format": "int64",
          "title": "The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to"
        },
        "timeoutType": {
          "$ref": "#/definitions/v1TimeoutType"
        }
      }
    },
    "v1WorkflowType": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      },
      "title": "Represents the identifier used by a workflow author to define the workflow. Typically, the\nname of a function. This is sometimes referred to as the workflow's \"name\""
    },
    "v1WorkflowTypeFilter": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      }
    }
  }
}
