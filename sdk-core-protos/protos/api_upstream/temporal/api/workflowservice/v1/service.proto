// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.api.workflowservice.v1;

option go_package = "go.temporal.io/api/workflowservice/v1;workflowservice";
option java_package = "io.temporal.api.workflowservice.v1";
option java_multiple_files = true;
option java_outer_classname = "ServiceProto";
option ruby_package = "Temporalio::Api::WorkflowService::V1";
option csharp_namespace = "Temporalio.Api.WorkflowService.V1";


import "temporal/api/workflowservice/v1/request_response.proto";
import "google/api/annotations.proto";

// WorkflowService API defines how Temporal SDKs and other clients interact with the Temporal server
// to create and interact with workflows and activities.
//
// Users are expected to call `StartWorkflowExecution` to create a new workflow execution.
//
// To drive workflows, a worker using a Temporal SDK must exist which regularly polls for workflow
// and activity tasks from the service. For each workflow task, the sdk must process the
// (incremental or complete) event history and respond back with any newly generated commands.
//
// For each activity task, the worker is expected to execute the user's code which implements that
// activity, responding with completion or failure.
service WorkflowService {

    // RegisterNamespace creates a new namespace which can be used as a container for all resources.
    //
    // A Namespace is a top level entity within Temporal, and is used as a container for resources
    // like workflow executions, task queues, etc. A Namespace acts as a sandbox and provides
    // isolation for all resources within the namespace. All resources belongs to exactly one
    // namespace.
    rpc RegisterNamespace (RegisterNamespaceRequest) returns (RegisterNamespaceResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces"
            body: "*"
        };
    }

    // DescribeNamespace returns the information and configuration for a registered namespace.
    rpc DescribeNamespace (DescribeNamespaceRequest) returns (DescribeNamespaceResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}"
        };
    }

    // ListNamespaces returns the information and configuration for all namespaces.
    rpc ListNamespaces (ListNamespacesRequest) returns (ListNamespacesResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces"
        };
    }

    // UpdateNamespace is used to update the information and configuration of a registered
    // namespace.
    rpc UpdateNamespace (UpdateNamespaceRequest) returns (UpdateNamespaceResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/update"
            body: "*"
        };
    }

    // DeprecateNamespace is used to update the state of a registered namespace to DEPRECATED.
    //
    // Once the namespace is deprecated it cannot be used to start new workflow executions. Existing
    // workflow executions will continue to run on deprecated namespaces.
    // Deprecated.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: Deprecated --)
    rpc DeprecateNamespace (DeprecateNamespaceRequest) returns (DeprecateNamespaceResponse) {
    }

    // StartWorkflowExecution starts a new workflow execution.
    //
    // It will create the execution with a `WORKFLOW_EXECUTION_STARTED` event in its history and
    // also schedule the first workflow task. Returns `WorkflowExecutionAlreadyStarted`, if an
    // instance already exists with same workflow id.
    rpc StartWorkflowExecution (StartWorkflowExecutionRequest) returns (StartWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_id}"
            body: "*"
        };
    }

    // GetWorkflowExecutionHistory returns the history of specified workflow execution. Fails with
    // `NotFound` if the specified workflow execution is unknown to the service.
    rpc GetWorkflowExecutionHistory (GetWorkflowExecutionHistoryRequest) returns (GetWorkflowExecutionHistoryResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history"
        };
    }
    
    // GetWorkflowExecutionHistoryReverse returns the history of specified workflow execution in reverse 
    // order (starting from last event). Fails with`NotFound` if the specified workflow execution is 
    // unknown to the service.
    rpc GetWorkflowExecutionHistoryReverse (GetWorkflowExecutionHistoryReverseRequest) returns (GetWorkflowExecutionHistoryReverseResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/history-reverse"
        };
    }

    // PollWorkflowTaskQueue is called by workers to make progress on workflows.
    //
    // A WorkflowTask is dispatched to callers for active workflow executions with pending workflow
    // tasks. The worker is expected to call `RespondWorkflowTaskCompleted` when it is done
    // processing the task. The service will create a `WorkflowTaskStarted` event in the history for
    // this task before handing it to the worker.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc PollWorkflowTaskQueue (PollWorkflowTaskQueueRequest) returns (PollWorkflowTaskQueueResponse) {
    }

    // RespondWorkflowTaskCompleted is called by workers to successfully complete workflow tasks
    // they received from `PollWorkflowTaskQueue`.
    //
    // Completing a WorkflowTask will write a `WORKFLOW_TASK_COMPLETED` event to the workflow's
    // history, along with events corresponding to whatever commands the SDK generated while
    // executing the task (ex timer started, activity task scheduled, etc).
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc RespondWorkflowTaskCompleted (RespondWorkflowTaskCompletedRequest) returns (RespondWorkflowTaskCompletedResponse) {
    }

    // RespondWorkflowTaskFailed is called by workers to indicate the processing of a workflow task
    // failed.
    //
    // This results in a `WORKFLOW_TASK_FAILED` event written to the history, and a new workflow
    // task will be scheduled. This API can be used to report unhandled failures resulting from
    // applying the workflow task.
    //
    // Temporal will only append first WorkflowTaskFailed event to the history of workflow execution
    // for consecutive failures.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc RespondWorkflowTaskFailed (RespondWorkflowTaskFailedRequest) returns (RespondWorkflowTaskFailedResponse) {
    }

    // PollActivityTaskQueue is called by workers to process activity tasks from a specific task
    // queue.
    //
    // The worker is expected to call one of the `RespondActivityTaskXXX` methods when it is done
    // processing the task.
    //
    // An activity task is dispatched whenever a `SCHEDULE_ACTIVITY_TASK` command is produced during
    // workflow execution. An in memory `ACTIVITY_TASK_STARTED` event is written to mutable state
    // before the task is dispatched to the worker. The started event, and the final event
    // (`ACTIVITY_TASK_COMPLETED` / `ACTIVITY_TASK_FAILED` / `ACTIVITY_TASK_TIMED_OUT`) will both be
    // written permanently to Workflow execution history when Activity is finished. This is done to
    // avoid writing many events in the case of a failure/retry loop.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc PollActivityTaskQueue (PollActivityTaskQueueRequest) returns (PollActivityTaskQueueResponse) {
    }

    // RecordActivityTaskHeartbeat is optionally called by workers while they execute activities.
    //
    // If worker fails to heartbeat within the `heartbeat_timeout` interval for the activity task,
    // then it will be marked as timed out and an `ACTIVITY_TASK_TIMED_OUT` event will be written to
    // the workflow history. Calling `RecordActivityTaskHeartbeat` will fail with `NotFound` in
    // such situations, in that event, the SDK should request cancellation of the activity.
    rpc RecordActivityTaskHeartbeat (RecordActivityTaskHeartbeatRequest) returns (RecordActivityTaskHeartbeatResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/heartbeat"
            body: "*"
        };
    }

    // See `RecordActivityTaskHeartbeat`. This version allows clients to record heartbeats by
    // namespace/workflow id/activity id instead of task token.
    //
    // (-- api-linter: core::0136::prepositions=disabled
    //     aip.dev/not-precedent: "By" is used to indicate request type. --)
    rpc RecordActivityTaskHeartbeatById (RecordActivityTaskHeartbeatByIdRequest) returns (RecordActivityTaskHeartbeatByIdResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/heartbeat-by-id"
            body: "*"
        };
    }

    // RespondActivityTaskCompleted is called by workers when they successfully complete an activity
    // task.
    //
    // This results in a new `ACTIVITY_TASK_COMPLETED` event being written to the workflow history
    // and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
    // no longer valid due to activity timeout, already being completed, or never having existed.
    rpc RespondActivityTaskCompleted (RespondActivityTaskCompletedRequest) returns (RespondActivityTaskCompletedResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/complete"
            body: "*"
        };
    }

    // See `RecordActivityTaskCompleted`. This version allows clients to record completions by
    // namespace/workflow id/activity id instead of task token.
    //
    // (-- api-linter: core::0136::prepositions=disabled
    //     aip.dev/not-precedent: "By" is used to indicate request type. --)
    rpc RespondActivityTaskCompletedById (RespondActivityTaskCompletedByIdRequest) returns (RespondActivityTaskCompletedByIdResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/complete-by-id"
            body: "*"
        };
    }

    // RespondActivityTaskFailed is called by workers when processing an activity task fails.
    //
    // This results in a new `ACTIVITY_TASK_FAILED` event being written to the workflow history and
    // a new workflow task created for the workflow. Fails with `NotFound` if the task token is no
    // longer valid due to activity timeout, already being completed, or never having existed.
    rpc RespondActivityTaskFailed (RespondActivityTaskFailedRequest) returns (RespondActivityTaskFailedResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/fail"
            body: "*"
        };
    }

    // See `RecordActivityTaskFailed`. This version allows clients to record failures by
    // namespace/workflow id/activity id instead of task token.
    //
    // (-- api-linter: core::0136::prepositions=disabled
    //     aip.dev/not-precedent: "By" is used to indicate request type. --)
    rpc RespondActivityTaskFailedById (RespondActivityTaskFailedByIdRequest) returns (RespondActivityTaskFailedByIdResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/fail-by-id"
            body: "*"
        };
    }

    // RespondActivityTaskFailed is called by workers when processing an activity task fails.
    //
    // This results in a new `ACTIVITY_TASK_CANCELED` event being written to the workflow history
    // and a new workflow task created for the workflow. Fails with `NotFound` if the task token is
    // no longer valid due to activity timeout, already being completed, or never having existed.
    rpc RespondActivityTaskCanceled (RespondActivityTaskCanceledRequest) returns (RespondActivityTaskCanceledResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/cancel"
            body: "*"
        };
    }

    // See `RecordActivityTaskCanceled`. This version allows clients to record failures by
    // namespace/workflow id/activity id instead of task token.
    //
    // (-- api-linter: core::0136::prepositions=disabled
    //     aip.dev/not-precedent: "By" is used to indicate request type. --)
    rpc RespondActivityTaskCanceledById (RespondActivityTaskCanceledByIdRequest) returns (RespondActivityTaskCanceledByIdResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/activities/cancel-by-id"
            body: "*"
        };
    }

    // RequestCancelWorkflowExecution is called by workers when they want to request cancellation of
    // a workflow execution.
    //
    // This results in a new `WORKFLOW_EXECUTION_CANCEL_REQUESTED` event being written to the
    // workflow history and a new workflow task created for the workflow. It returns success if the requested
    // workflow is already closed. It fails with 'NotFound' if the requested workflow doesn't exist.
    rpc RequestCancelWorkflowExecution (RequestCancelWorkflowExecutionRequest) returns (RequestCancelWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/cancel"
            body: "*"
        };
    }

    // SignalWorkflowExecution is used to send a signal to a running workflow execution.
    //
    // This results in a `WORKFLOW_EXECUTION_SIGNALED` event recorded in the history and a workflow
    // task being created for the execution.
    rpc SignalWorkflowExecution (SignalWorkflowExecutionRequest) returns (SignalWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/signal/{signal_name}"
            body: "*"
        };
    }

    // SignalWithStartWorkflowExecution is used to ensure a signal is sent to a workflow, even if
    // it isn't yet started.
    //
    // If the workflow is running, a `WORKFLOW_EXECUTION_SIGNALED` event is recorded in the history
    // and a workflow task is generated.
    //
    // If the workflow is not running or not found, then the workflow is created with
    // `WORKFLOW_EXECUTION_STARTED` and `WORKFLOW_EXECUTION_SIGNALED` events in its history, and a
    // workflow task is generated.
    //
    // (-- api-linter: core::0136::prepositions=disabled
    //     aip.dev/not-precedent: "With" is used to indicate combined operation. --)
    rpc SignalWithStartWorkflowExecution (SignalWithStartWorkflowExecutionRequest) returns (SignalWithStartWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_id}/signal-with-start/{signal_name}"
            body: "*"
        };
    }

    // ResetWorkflowExecution will reset an existing workflow execution to a specified
    // `WORKFLOW_TASK_COMPLETED` event (exclusive). It will immediately terminate the current
    // execution instance.
    // TODO: Does exclusive here mean *just* the completed event, or also WFT started? Otherwise the task is doomed to time out?
    rpc ResetWorkflowExecution (ResetWorkflowExecutionRequest) returns (ResetWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/reset"
            body: "*"
        };
    }

    // TerminateWorkflowExecution terminates an existing workflow execution by recording a
    // `WORKFLOW_EXECUTION_TERMINATED` event in the history and immediately terminating the
    // execution instance.
    rpc TerminateWorkflowExecution (TerminateWorkflowExecutionRequest) returns (TerminateWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/terminate"
            body: "*"
        };
    }

    // DeleteWorkflowExecution asynchronously deletes a specific Workflow Execution (when
    // WorkflowExecution.run_id is provided) or the latest Workflow Execution (when
    // WorkflowExecution.run_id is not provided). If the Workflow Execution is Running, it will be
    // terminated before deletion.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: Workflow deletion not exposed to HTTP, users should use cancel or terminate. --)
    rpc DeleteWorkflowExecution (DeleteWorkflowExecutionRequest) returns (DeleteWorkflowExecutionResponse) {}

    // ListOpenWorkflowExecutions is a visibility API to list the open executions in a specific namespace.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    rpc ListOpenWorkflowExecutions (ListOpenWorkflowExecutionsRequest) returns (ListOpenWorkflowExecutionsResponse) {}

    // ListClosedWorkflowExecutions is a visibility API to list the closed executions in a specific namespace.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    rpc ListClosedWorkflowExecutions (ListClosedWorkflowExecutionsRequest) returns (ListClosedWorkflowExecutionsResponse) {}

    // ListWorkflowExecutions is a visibility API to list workflow executions in a specific namespace.
    rpc ListWorkflowExecutions (ListWorkflowExecutionsRequest) returns (ListWorkflowExecutionsResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/workflows"
        };
    }

    // ListArchivedWorkflowExecutions is a visibility API to list archived workflow executions in a specific namespace.
    rpc ListArchivedWorkflowExecutions (ListArchivedWorkflowExecutionsRequest) returns (ListArchivedWorkflowExecutionsResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/archived-workflows"
        };
    }

    // ScanWorkflowExecutions is a visibility API to list large amount of workflow executions in a specific namespace without order.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: HTTP users should use ListWorkflowExecutions instead. --)
    rpc ScanWorkflowExecutions (ScanWorkflowExecutionsRequest) returns (ScanWorkflowExecutionsResponse) {
    }

    // CountWorkflowExecutions is a visibility API to count of workflow executions in a specific namespace.
    rpc CountWorkflowExecutions (CountWorkflowExecutionsRequest) returns (CountWorkflowExecutionsResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/workflow-count"
        };
    }

    // GetSearchAttributes is a visibility API to get all legal keys that could be used in list APIs
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose this search attribute API to HTTP (but may expose on OperatorService). --)
    rpc GetSearchAttributes (GetSearchAttributesRequest) returns (GetSearchAttributesResponse) {}

    // RespondQueryTaskCompleted is called by workers to complete queries which were delivered on
    // the `query` (not `queries`) field of a `PollWorkflowTaskQueueResponse`.
    //
    // Completing the query will unblock the corresponding client call to `QueryWorkflow` and return
    // the query result a response.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc RespondQueryTaskCompleted (RespondQueryTaskCompletedRequest) returns (RespondQueryTaskCompletedResponse) {}

    // ResetStickyTaskQueue resets the sticky task queue related information in the mutable state of
    // a given workflow. This is prudent for workers to perform if a workflow has been paged out of
    // their cache.
    //
    // Things cleared are:
    // 1. StickyTaskQueue
    // 2. StickyScheduleToStartTimeout
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose worker API to HTTP. --)
    rpc ResetStickyTaskQueue (ResetStickyTaskQueueRequest) returns (ResetStickyTaskQueueResponse) {
    }

    // QueryWorkflow requests a query be executed for a specified workflow execution.
    rpc QueryWorkflow (QueryWorkflowRequest) returns (QueryWorkflowResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}/query/{query.query_type}"
            body: "*"
        };
    }

    // DescribeWorkflowExecution returns information about the specified workflow execution.
    rpc DescribeWorkflowExecution (DescribeWorkflowExecutionRequest) returns (DescribeWorkflowExecutionResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/workflows/{execution.workflow_id}"
        };
    }

    // DescribeTaskQueue returns information about the target task queue.
    rpc DescribeTaskQueue (DescribeTaskQueueRequest) returns (DescribeTaskQueueResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/task-queues/{task_queue.name}"
        };
    }

    // GetClusterInfo returns information about temporal cluster
    rpc GetClusterInfo(GetClusterInfoRequest) returns (GetClusterInfoResponse) {
        option (google.api.http) = {
            get: "/api/v1/cluster-info"
        };
    }

    // GetSystemInfo returns information about the system.
    rpc GetSystemInfo(GetSystemInfoRequest) returns (GetSystemInfoResponse) {
        option (google.api.http) = {
            get: "/api/v1/system-info"
        };
    }

    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do not expose this low-level API to HTTP. --)
    rpc ListTaskQueuePartitions(ListTaskQueuePartitionsRequest) returns (ListTaskQueuePartitionsResponse) {
    }

    // Creates a new schedule.
    rpc CreateSchedule (CreateScheduleRequest) returns (CreateScheduleResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}"
            body: "*"
        };
    }

    // Returns the schedule description and current state of an existing schedule.
    rpc DescribeSchedule (DescribeScheduleRequest) returns (DescribeScheduleResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}"
        };
    }

    // Changes the configuration or state of an existing schedule.
    rpc UpdateSchedule (UpdateScheduleRequest) returns (UpdateScheduleResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}/update"
            body: "*"
        };
    }

    // Makes a specific change to a schedule or triggers an immediate action.
    rpc PatchSchedule (PatchScheduleRequest) returns (PatchScheduleResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}/patch"
            body: "*"
        };
    }

    // Lists matching times within a range.
    rpc ListScheduleMatchingTimes (ListScheduleMatchingTimesRequest) returns (ListScheduleMatchingTimesResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}/matching-times"
        };
    }

    // Deletes a schedule, removing it from the system.
    rpc DeleteSchedule (DeleteScheduleRequest) returns (DeleteScheduleResponse) {
        option (google.api.http) = {
            delete: "/api/v1/namespaces/{namespace}/schedules/{schedule_id}"
        };
    }

    // List all schedules in a namespace.
    rpc ListSchedules (ListSchedulesRequest) returns (ListSchedulesResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/schedules"
        };
    }

    // Allows users to specify sets of worker build id versions on a per task queue basis. Versions
    // are ordered, and may be either compatible with some extant version, or a new incompatible
    // version, forming sets of ids which are incompatible with each other, but whose contained
    // members are compatible with one another.
    //
    // A single build id may be mapped to multiple task queues using this API for cases where a single process hosts
    // multiple workers. 
    // 
    // To query which workers can be retired, use the `GetWorkerTaskReachability` API.
    //
    // NOTE: The number of task queues mapped to a single build id is limited by the `limit.taskQueuesPerBuildId`
    // (default is 20), if this limit is exceeded this API will error with a FailedPrecondition.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We do yet expose versioning API to HTTP. --)
    rpc UpdateWorkerBuildIdCompatibility (UpdateWorkerBuildIdCompatibilityRequest) returns (UpdateWorkerBuildIdCompatibilityResponse) {}

    // Fetches the worker build id versioning sets for a task queue.
    rpc GetWorkerBuildIdCompatibility (GetWorkerBuildIdCompatibilityRequest) returns (GetWorkerBuildIdCompatibilityResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/task-queues/{task_queue}/worker-build-id-compatibility"
        };
    }

    // Fetches task reachability to determine whether a worker may be retired.
    // The request may specify task queues to query for or let the server fetch all task queues mapped to the given
    // build IDs.
    //
    // When requesting a large number of task queues or all task queues associated with the given build ids in a
    // namespace, all task queues will be listed in the response but some of them may not contain reachability
    // information due to a server enforced limit. When reaching the limit, task queues that reachability information
    // could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
    // another call to get the reachability for those task queues.
    //
    // Open source users can adjust this limit by setting the server's dynamic config value for
    // `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
    rpc GetWorkerTaskReachability (GetWorkerTaskReachabilityRequest) returns (GetWorkerTaskReachabilityResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/worker-task-reachability"
        };
    }

    // Invokes the specified update function on user workflow code.
    rpc UpdateWorkflowExecution(UpdateWorkflowExecutionRequest) returns (UpdateWorkflowExecutionResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/workflows/{workflow_execution.workflow_id}/update/{request.input.name}"
            body: "*"
        };
    }

    // Polls a workflow execution for the outcome of a workflow execution update
    // previously issued through the UpdateWorkflowExecution RPC. The effective
    // timeout on this call will be shorter of the the caller-supplied gRPC
    // timeout and the server's configured long-poll timeout.
    //
    // (-- api-linter: core::0127::http-annotation=disabled
    //     aip.dev/not-precedent: We don't expose update polling API to HTTP in favor of a potential future non-blocking form. --)
    rpc PollWorkflowExecutionUpdate(PollWorkflowExecutionUpdateRequest) returns (PollWorkflowExecutionUpdateResponse) {
    }

    // StartBatchOperation starts a new batch operation
    rpc StartBatchOperation(StartBatchOperationRequest) returns (StartBatchOperationResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/batch-operations/{job_id}"
            body: "*"
        };
    }

    // StopBatchOperation stops a batch operation
    rpc StopBatchOperation(StopBatchOperationRequest) returns (StopBatchOperationResponse) {
        option (google.api.http) = {
            post: "/api/v1/namespaces/{namespace}/batch-operations/{job_id}/stop"
            body: "*"
        };
    }

    // DescribeBatchOperation returns the information about a batch operation
    rpc DescribeBatchOperation(DescribeBatchOperationRequest) returns (DescribeBatchOperationResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/batch-operations/{job_id}"
        };
    }

    // ListBatchOperations returns a list of batch operations
    rpc ListBatchOperations(ListBatchOperationsRequest) returns (ListBatchOperationsResponse) {
        option (google.api.http) = {
            get: "/api/v1/namespaces/{namespace}/batch-operations"
        };
    }
}
