// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.api.workflowservice.v1;

option go_package = "go.temporal.io/api/workflowservice/v1;workflowservice";
option java_package = "io.temporal.api.workflowservice.v1";
option java_multiple_files = true;
option java_outer_classname = "RequestResponseProto";
option ruby_package = "Temporalio::Api::WorkflowService::V1";
option csharp_namespace = "Temporalio.Api.WorkflowService.V1";

import "temporal/api/enums/v1/batch_operation.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/enums/v1/namespace.proto";
import "temporal/api/enums/v1/failed_cause.proto";
import "temporal/api/enums/v1/common.proto";
import "temporal/api/enums/v1/query.proto";
import "temporal/api/enums/v1/reset.proto";
import "temporal/api/enums/v1/task_queue.proto";
import "temporal/api/enums/v1/update.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/history/v1/message.proto";
import "temporal/api/workflow/v1/message.proto";
import "temporal/api/command/v1/message.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/filter/v1/message.proto";
import "temporal/api/protocol/v1/message.proto";
import "temporal/api/namespace/v1/message.proto";
import "temporal/api/query/v1/message.proto";
import "temporal/api/replication/v1/message.proto";
import "temporal/api/schedule/v1/message.proto";
import "temporal/api/taskqueue/v1/message.proto";
import "temporal/api/update/v1/message.proto";
import "temporal/api/version/v1/message.proto";
import "temporal/api/batch/v1/message.proto";
import "temporal/api/sdk/v1/task_complete_metadata.proto";
import "temporal/api/nexus/v1/message.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

message RegisterNamespaceRequest {
    string namespace = 1;
    string description = 2;
    string owner_email = 3;
    google.protobuf.Duration workflow_execution_retention_period = 4;
    repeated temporal.api.replication.v1.ClusterReplicationConfig clusters = 5;
    string active_cluster_name = 6;
    // A key-value map for any customized purpose.
    map<string, string> data = 7;
    string security_token = 8;
    bool is_global_namespace = 9;
    // If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    temporal.api.enums.v1.ArchivalState history_archival_state = 10;
    string history_archival_uri = 11;
    // If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    temporal.api.enums.v1.ArchivalState visibility_archival_state = 12;
    string visibility_archival_uri = 13;
}

message RegisterNamespaceResponse {
}

message ListNamespacesRequest {
    int32 page_size = 1;
    bytes next_page_token = 2;
    temporal.api.namespace.v1.NamespaceFilter namespace_filter = 3;
}

message ListNamespacesResponse {
    repeated DescribeNamespaceResponse namespaces = 1;
    bytes next_page_token = 2;
}

message DescribeNamespaceRequest {
    string namespace = 1;
    string id = 2;
}

message DescribeNamespaceResponse {
    temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
    temporal.api.namespace.v1.NamespaceConfig config = 2;
    temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
    int64 failover_version = 4;
    bool is_global_namespace = 5;
    // Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
    // states to ensure that the list does not grow unbounded.
    repeated temporal.api.replication.v1.FailoverStatus failover_history = 6;
}

message UpdateNamespaceRequest {
    string namespace = 1;
    temporal.api.namespace.v1.UpdateNamespaceInfo update_info = 2;
    temporal.api.namespace.v1.NamespaceConfig config = 3;
    temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 4;
    string security_token = 5;
    string delete_bad_binary = 6;
    // promote local namespace to global namespace. Ignored if namespace is already global namespace.
    bool promote_namespace = 7;
}

message UpdateNamespaceResponse {
    temporal.api.namespace.v1.NamespaceInfo namespace_info = 1;
    temporal.api.namespace.v1.NamespaceConfig config = 2;
    temporal.api.replication.v1.NamespaceReplicationConfig replication_config = 3;
    int64 failover_version = 4;
    bool is_global_namespace = 5;
}

// Deprecated.
message DeprecateNamespaceRequest {
    string namespace = 1;
    string security_token = 2;
}

// Deprecated.
message DeprecateNamespaceResponse {
}

message StartWorkflowExecutionRequest {
    string namespace = 1;
    string workflow_id = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
    // Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    temporal.api.common.v1.Payloads input = 5;
    // Total workflow execution timeout including retries and continue as new.
    google.protobuf.Duration workflow_execution_timeout = 6;
    // Timeout of a single workflow run.
    google.protobuf.Duration workflow_run_timeout = 7;
    // Timeout of a single workflow task.
    google.protobuf.Duration workflow_task_timeout = 8;
    // The identity of the client who initiated this request
    string identity = 9;
    // A unique identifier for this start request. Typically UUIDv4.
    string request_id = 10;
    // Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    // The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    //
    // See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
    temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
    // Defines how to resolve a workflow id conflict with a *running* workflow.
    // The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
    //
    // See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
    // The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
    temporal.api.common.v1.RetryPolicy retry_policy = 12;
    // See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    string cron_schedule = 13;
    temporal.api.common.v1.Memo memo = 14;
    temporal.api.common.v1.SearchAttributes search_attributes = 15;
    temporal.api.common.v1.Header header = 16;
    // Request to get the first workflow task inline in the response bypassing matching service and worker polling.
    // If set to `true` the caller is expected to have a worker available and capable of processing the task.
    // The returned task will be marked as started and is expected to be completed by the specified
    // `workflow_task_timeout`.
    bool request_eager_execution = 17;
    // These values will be available as ContinuedFailure and LastCompletionResult in the
    // WorkflowExecutionStarted event and through SDKs. The are currently only used by the
    // server itself (for the schedules feature) and are not intended to be exposed in
    // StartWorkflowExecution.
    temporal.api.failure.v1.Failure continued_failure = 18;
    temporal.api.common.v1.Payloads last_completion_result = 19;
    // Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    // If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
    // of the delay will be ignored.
    google.protobuf.Duration workflow_start_delay = 20;
    // Callbacks to be called by the server when this workflow reaches a terminal state.
    // If the workflow continues-as-new, these callbacks will be carried over to the new execution.
    // Callback addresses must be whitelisted in the server's dynamic configuration.
    repeated temporal.api.common.v1.Callback completion_callbacks = 21;
}

message StartWorkflowExecutionResponse {
    // The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
    string run_id = 1;
    // If true, a new workflow was started.
    bool started = 3;
    // When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
    // return the first workflow task to be eagerly executed.
    // The caller is expected to have a worker available to process the task.
    PollWorkflowTaskQueueResponse eager_workflow_task = 2;
}

message GetWorkflowExecutionHistoryRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    int32 maximum_page_size = 3;
    // If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
    // these, it should be passed here to fetch the next page.
    bytes next_page_token = 4;
    // If set to true, the RPC call will not resolve until there is a new event which matches
    // the `history_event_filter_type`, or a timeout is hit.
    bool wait_new_event = 5;
    // Filter returned events such that they match the specified filter type.
    // Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
    temporal.api.enums.v1.HistoryEventFilterType history_event_filter_type = 6;
    bool skip_archival = 7;
}

message GetWorkflowExecutionHistoryResponse {
    temporal.api.history.v1.History history = 1;
    // Raw history is an alternate representation of history that may be returned if configured on
    // the frontend. This is not supported by all SDKs. Either this or `history` will be set.
    repeated temporal.api.common.v1.DataBlob raw_history = 2;
    // Will be set if there are more history events than were included in this response
    bytes next_page_token = 3;
    bool archived = 4;
}

message GetWorkflowExecutionHistoryReverseRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    int32 maximum_page_size = 3;
    bytes next_page_token = 4;
}

message GetWorkflowExecutionHistoryReverseResponse {
    temporal.api.history.v1.History history = 1;
    // Will be set if there are more history events than were included in this response
    bytes next_page_token = 3;
}

message PollWorkflowTaskQueueRequest {
    string namespace = 1;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
    // The identity of the worker/client who is polling this task queue
    string identity = 3;
    // DEPRECATED since 1.21 - use `worker_version_capabilities` instead.
    // Each worker process should provide an ID unique to the specific set of code it is running
    // "checksum" in this field name isn't very accurate, it should be though of as an id.
    string binary_checksum = 4;
    // Information about this worker's build identifier and if it is choosing to use the versioning
    // feature. See the `WorkerVersionCapabilities` docstring for more.
    temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5;
}

message PollWorkflowTaskQueueResponse {
    // A unique identifier for this task
    bytes task_token = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    // The last workflow task started event which was processed by some worker for this execution.
    // Will be zero if no task has ever started.
    int64 previous_started_event_id = 4;
    // The id of the most recent workflow task started event, which will have been generated as a
    // result of this poll request being served. Will be zero if the task
    // does not contain any events which would advance history (no new WFT started).
    // Currently this can happen for queries.
    int64 started_event_id = 5;
    // Starting at 1, the number of attempts to complete this task by any worker.
    int32 attempt = 6;
    // A hint that there are more tasks already present in this task queue. Can be used to
    // prioritize draining a sticky queue before polling from a normal queue.
    int64 backlog_count_hint = 7;
    // The history for this workflow, which will either be complete or partial. Partial histories
    // are sent to workers who have signaled that they are using a sticky queue when completing
    // a workflow task.
    temporal.api.history.v1.History history = 8;
    // Will be set if there are more history events than were included in this response. Such events
    // should be fetched via `GetWorkflowExecutionHistory`.
    bytes next_page_token = 9;
    // Legacy queries appear in this field. The query must be responded to via
    // `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
    // closed workflows) then the `history` field will be populated with the entire history. It
    // may also be populated if this task originates on a non-sticky queue.
    temporal.api.query.v1.WorkflowQuery query = 10;
    // The task queue this task originated from, which will always be the original non-sticky name
    // for the queue, even if this response came from polling a sticky queue.
    temporal.api.taskqueue.v1.TaskQueue workflow_execution_task_queue = 11;
    // When this task was scheduled by the server
    google.protobuf.Timestamp scheduled_time = 12;
    // When the current workflow task started event was generated, meaning the current attempt.
    google.protobuf.Timestamp started_time = 13;
    // Queries that should be executed after applying the history in this task. Responses should be
    // attached to `RespondWorkflowTaskCompletedRequest::query_results`
    map<string, temporal.api.query.v1.WorkflowQuery> queries = 14;
    // Protocol messages piggybacking on a WFT as a transport
    repeated temporal.api.protocol.v1.Message messages = 15;
}

message RespondWorkflowTaskCompletedRequest {
    // The task token as received in `PollWorkflowTaskQueueResponse`
    bytes task_token = 1;
    // A list of commands generated when driving the workflow code in response to the new task
    repeated temporal.api.command.v1.Command commands = 2;
    // The identity of the worker/client
    string identity = 3;
    // May be set by workers to indicate that the worker desires future tasks to be provided with
    // incremental history on a sticky queue.
    temporal.api.taskqueue.v1.StickyExecutionAttributes sticky_attributes = 4;
    // If set, the worker wishes to immediately receive the next workflow task as a response to
    // this completion. This can save on polling round-trips.
    bool return_new_workflow_task = 5;
    // Can be used to *force* creation of a new workflow task, even if no commands have resolved or
    // one would not otherwise have been generated. This is used when the worker knows it is doing
    // something useful, but cannot complete it within the workflow task timeout. Local activities
    // which run for longer than the task timeout being the prime example.
    bool force_create_new_workflow_task = 6;
    // DEPRECATED since 1.21 - use `worker_version_stamp` instead.
    // Worker process' unique binary id
    string binary_checksum = 7;
    // Responses to the `queries` field in the task being responded to
    map<string, temporal.api.query.v1.WorkflowQueryResult> query_results = 8;
    string namespace = 9;
    // Version info of the worker who processed this task. This message's `build_id` field should
    // always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    // field to true. See message docstrings for more.
    temporal.api.common.v1.WorkerVersionStamp worker_version_stamp = 10;
    // Protocol messages piggybacking on a WFT as a transport
    repeated temporal.api.protocol.v1.Message messages = 11;
    // Data the SDK wishes to record for itself, but server need not interpret, and does not
    // directly impact workflow state.
    temporal.api.sdk.v1.WorkflowTaskCompletedMetadata sdk_metadata = 12;
    // Local usage data collected for metering
    temporal.api.common.v1.MeteringMetadata metering_metadata = 13;
}

message RespondWorkflowTaskCompletedResponse {
    // See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
    PollWorkflowTaskQueueResponse workflow_task = 1;
    // See `ScheduleActivityTaskCommandAttributes::request_start`
    repeated PollActivityTaskQueueResponse activity_tasks = 2;

    int64 reset_history_event_id = 3;
}

message RespondWorkflowTaskFailedRequest {
    // The task token as received in `PollWorkflowTaskQueueResponse`
    bytes task_token = 1;
    // Why did the task fail? It's important to note that many of the variants in this enum cannot
    // apply to worker responses. See the type's doc for more.
    temporal.api.enums.v1.WorkflowTaskFailedCause cause = 2;
    // Failure details
    temporal.api.failure.v1.Failure failure = 3;
    // The identity of the worker/client
    string identity = 4;
    // DEPRECATED since 1.21 - use `worker_version_stamp` instead.
    // Worker process' unique binary id
    string binary_checksum = 5;
    string namespace = 6;
    // Protocol messages piggybacking on a WFT as a transport
    repeated temporal.api.protocol.v1.Message messages = 7;
    // Version info of the worker who processed this task. This message's `build_id` field should
    // always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    // field to true. See message docstrings for more.
    temporal.api.common.v1.WorkerVersionStamp worker_version = 8;
}

message RespondWorkflowTaskFailedResponse {
}

message PollActivityTaskQueueRequest {
    string namespace = 1;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
    // The identity of the worker/client
    string identity = 3;
    temporal.api.taskqueue.v1.TaskQueueMetadata task_queue_metadata = 4;
    // Information about this worker's build identifier and if it is choosing to use the versioning
    // feature. See the `WorkerVersionCapabilities` docstring for more.
    temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 5;
}

message PollActivityTaskQueueResponse {
    // A unique identifier for this task
    bytes task_token = 1;
    // The namespace the workflow which requested this activity lives in
    string workflow_namespace = 2;
    // Type of the requesting workflow
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    // Execution info of the requesting workflow
    temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
    temporal.api.common.v1.ActivityType activity_type = 5;
    // The autogenerated or user specified identifier of this activity. Can be used to complete the
    // activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
    // has resolved, but unique IDs for every activity invocation is a good idea.
    string activity_id = 6;
    // Headers specified by the scheduling workflow. Commonly used to propagate contextual info
    // from the workflow to its activities. For example, tracing contexts.
    temporal.api.common.v1.Header header = 7;
    // Arguments to the activity invocation
    temporal.api.common.v1.Payloads input = 8;
    // Details of the last heartbeat that was recorded for this activity as of the time this task
    // was delivered.
    temporal.api.common.v1.Payloads heartbeat_details = 9;
    // When was this task first scheduled
    google.protobuf.Timestamp scheduled_time = 10;
    // When was this task attempt scheduled
    google.protobuf.Timestamp current_attempt_scheduled_time = 11;
    // When was this task started (this attempt)
    google.protobuf.Timestamp started_time = 12;
    // Starting at 1, the number of attempts to perform this activity
    int32 attempt = 13;
    // First scheduled -> final result reported timeout
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 14;
    // Current attempt start -> final result reported timeout
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 15;
    // Window within which the activity must report a heartbeat, or be timed out.
    google.protobuf.Duration heartbeat_timeout = 16;
    // This is the retry policy the service uses which may be different from the one provided
    // (or not) during activity scheduling. The service can override the provided one if some
    // values are not specified or exceed configured system limits.
    temporal.api.common.v1.RetryPolicy retry_policy = 17;
}

message RecordActivityTaskHeartbeatRequest {
    // The task token as received in `PollActivityTaskQueueResponse`
    bytes task_token = 1;
    // Arbitrary data, of which the most recent call is kept, to store for this activity
    temporal.api.common.v1.Payloads details = 2;
    // The identity of the worker/client
    string identity = 3;
    string namespace = 4;
}

message RecordActivityTaskHeartbeatResponse {
    // Will be set to true if the activity has been asked to cancel itself. The SDK should then
    // notify the activity of cancellation if it is still running.
    bool cancel_requested = 1;
}

message RecordActivityTaskHeartbeatByIdRequest {
    // Namespace of the workflow which scheduled this activity
    string namespace = 1;
    // Id of the workflow which scheduled this activity
    string workflow_id = 2;
    // Run Id of the workflow which scheduled this activity
    string run_id = 3;
    // Id of the activity we're heartbeating
    string activity_id = 4;
    // Arbitrary data, of which the most recent call is kept, to store for this activity
    temporal.api.common.v1.Payloads details = 5;
    // The identity of the worker/client
    string identity = 6;
}

message RecordActivityTaskHeartbeatByIdResponse {
    // Will be set to true if the activity has been asked to cancel itself. The SDK should then
    // notify the activity of cancellation if it is still running.
    bool cancel_requested = 1;
}

message RespondActivityTaskCompletedRequest {
    // The task token as received in `PollActivityTaskQueueResponse`
    bytes task_token = 1;
    // The result of successfully executing the activity
    temporal.api.common.v1.Payloads result = 2;
    // The identity of the worker/client
    string identity = 3;
    string namespace = 4;
    // Version info of the worker who processed this task. This message's `build_id` field should
    // always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    // field to true. See message docstrings for more.
    temporal.api.common.v1.WorkerVersionStamp worker_version = 5;
}

message RespondActivityTaskCompletedResponse {
}

message RespondActivityTaskCompletedByIdRequest {
    // Namespace of the workflow which scheduled this activity
    string namespace = 1;
    // Id of the workflow which scheduled this activity
    string workflow_id = 2;
    // Run Id of the workflow which scheduled this activity
    string run_id = 3;
    // Id of the activity to complete
    string activity_id = 4;
    // The serialized result of activity execution
    temporal.api.common.v1.Payloads result = 5;
    // The identity of the worker/client
    string identity = 6;
}

message RespondActivityTaskCompletedByIdResponse {
}

message RespondActivityTaskFailedRequest {
    // The task token as received in `PollActivityTaskQueueResponse`
    bytes task_token = 1;
    // Detailed failure information
    temporal.api.failure.v1.Failure failure = 2;
    // The identity of the worker/client
    string identity = 3;
    string namespace = 4;
    // Additional details to be stored as last activity heartbeat
    temporal.api.common.v1.Payloads last_heartbeat_details = 5;
    // Version info of the worker who processed this task. This message's `build_id` field should
    // always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    // field to true. See message docstrings for more.
    temporal.api.common.v1.WorkerVersionStamp worker_version = 6;
}

message RespondActivityTaskFailedResponse {
    // Server validation failures could include
    // last_heartbeat_details payload is too large, request failure is too large
    repeated temporal.api.failure.v1.Failure failures = 1;
}

message RespondActivityTaskFailedByIdRequest {
    // Namespace of the workflow which scheduled this activity
    string namespace = 1;
    // Id of the workflow which scheduled this activity
    string workflow_id = 2;
    // Run Id of the workflow which scheduled this activity
    string run_id = 3;
    // Id of the activity to fail
    string activity_id = 4;
    // Detailed failure information
    temporal.api.failure.v1.Failure failure = 5;
    // The identity of the worker/client
    string identity = 6;
    // Additional details to be stored as last activity heartbeat
    temporal.api.common.v1.Payloads last_heartbeat_details = 7;
}

message RespondActivityTaskFailedByIdResponse {
    // Server validation failures could include
    // last_heartbeat_details payload is too large, request failure is too large
    repeated temporal.api.failure.v1.Failure failures = 1;
}

message RespondActivityTaskCanceledRequest {
    // The task token as received in `PollActivityTaskQueueResponse`
    bytes task_token = 1;
    // Serialized additional information to attach to the cancellation
    temporal.api.common.v1.Payloads details = 2;
    // The identity of the worker/client
    string identity = 3;
    string namespace = 4;
    // Version info of the worker who processed this task. This message's `build_id` field should
    // always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    // field to true. See message docstrings for more.
    temporal.api.common.v1.WorkerVersionStamp worker_version = 5;
}

message RespondActivityTaskCanceledResponse {
}

message RespondActivityTaskCanceledByIdRequest {
    // Namespace of the workflow which scheduled this activity
    string namespace = 1;
    // Id of the workflow which scheduled this activity
    string workflow_id = 2;
    // Run Id of the workflow which scheduled this activity
    string run_id = 3;
    // Id of the activity to confirm is cancelled
    string activity_id = 4;
    // Serialized additional information to attach to the cancellation
    temporal.api.common.v1.Payloads details = 5;
    // The identity of the worker/client
    string identity = 6;
}

message RespondActivityTaskCanceledByIdResponse {
}

message RequestCancelWorkflowExecutionRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    // The identity of the worker/client
    string identity = 3;
    // Used to de-dupe cancellation requests
    string request_id = 4;
    // If set, this call will error if the most recent (if no run id is set on
    // `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    // execution chain as this id.
    string first_execution_run_id = 5;
    // Reason for requesting the cancellation
    string reason = 6;
}

message RequestCancelWorkflowExecutionResponse {
}

message SignalWorkflowExecutionRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    // The workflow author-defined name of the signal to send to the workflow
    string signal_name = 3;
    // Serialized value(s) to provide with the signal
    temporal.api.common.v1.Payloads input = 4;
    // The identity of the worker/client
    string identity = 5;
    // Used to de-dupe sent signals
    string request_id = 6;
    // Deprecated
    string control = 7;
    // Headers that are passed with the signal to the processing workflow.
    // These can include things like auth or tracing tokens.
    temporal.api.common.v1.Header header = 8;
    // Indicates that a new workflow task should not be generated when this signal is received.
    bool skip_generate_workflow_task = 9;
}

message SignalWorkflowExecutionResponse {
}

message SignalWithStartWorkflowExecutionRequest {
    string namespace = 1;
    string workflow_id = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    // The task queue to start this workflow on, if it will be started
    temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
    // Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    temporal.api.common.v1.Payloads input = 5;
    // Total workflow execution timeout including retries and continue as new
    google.protobuf.Duration workflow_execution_timeout = 6;
    // Timeout of a single workflow run
    google.protobuf.Duration workflow_run_timeout = 7;
    // Timeout of a single workflow task
    google.protobuf.Duration workflow_task_timeout = 8;
    // The identity of the worker/client
    string identity = 9;
    // Used to de-dupe signal w/ start requests
    string request_id = 10;
    // Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    // The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    //
    // See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
    temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 11;
    // Defines how to resolve a workflow id conflict with a *running* workflow.
    // The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
    // Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
    //
    // See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    temporal.api.enums.v1.WorkflowIdConflictPolicy workflow_id_conflict_policy = 22;
    // The workflow author-defined name of the signal to send to the workflow
    string signal_name = 12;
    // Serialized value(s) to provide with the signal
    temporal.api.common.v1.Payloads signal_input = 13;
    // Deprecated
    string control = 14;
    // Retry policy for the workflow
    temporal.api.common.v1.RetryPolicy retry_policy = 15;
    // See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    string cron_schedule = 16;
    temporal.api.common.v1.Memo memo = 17;
    temporal.api.common.v1.SearchAttributes search_attributes = 18;
    temporal.api.common.v1.Header header = 19;
    // Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    // Note that the signal will be delivered with the first workflow task. If the workflow gets
    // another SignalWithStartWorkflow before the delay and `skip_generate_workflow_task` is false
    // or not set, a workflow task will be dispatched immediately and the rest of the delay period
    // will be ignored, even if that request also had a delay. Signal via SignalWorkflowExecution
    // will not unblock the workflow.
    google.protobuf.Duration workflow_start_delay = 20;
    // Indicates that a new workflow task should not be generated when this signal is received.
    bool skip_generate_workflow_task = 21;
}

message SignalWithStartWorkflowExecutionResponse {
    // The run id of the workflow that was started - or just signaled, if it was already running.
    string run_id = 1;
    // If true, a new workflow was started.
    bool started = 2;
}

message ResetWorkflowExecutionRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    string reason = 3;
    // The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
    // `WORKFLOW_TASK_STARTED` event to reset to.
    int64 workflow_task_finish_event_id = 4;
    // Used to de-dupe reset requests
    string request_id = 5;
    // Event types to be reapplied (deprecated)
    // Default: RESET_REAPPLY_TYPE_SIGNAL
    temporal.api.enums.v1.ResetReapplyType reset_reapply_type = 6;
    // Event types not to be reapplied
    repeated temporal.api.enums.v1.ResetReapplyExcludeType reset_reapply_exclude_types = 7;
}

message ResetWorkflowExecutionResponse {
    string run_id = 1;
}

message TerminateWorkflowExecutionRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    string reason = 3;
    // Serialized additional information to attach to the termination event
    temporal.api.common.v1.Payloads details = 4;
    // The identity of the worker/client
    string identity = 5;
    // If set, this call will error if the most recent (if no run id is set on
    // `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    // execution chain as this id.
    string first_execution_run_id = 6;
}

message TerminateWorkflowExecutionResponse {
}

message DeleteWorkflowExecutionRequest {
    string namespace = 1;
    // Workflow Execution to delete. If run_id is not specified, the latest one is used.
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
}

message DeleteWorkflowExecutionResponse {
}

message ListOpenWorkflowExecutionsRequest {
    string namespace = 1;
    int32 maximum_page_size = 2;
    bytes next_page_token = 3;
    temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
    oneof filters {
        temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
        temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
    }
}

message ListOpenWorkflowExecutionsResponse {
    repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
    bytes next_page_token = 2;
}

message ListClosedWorkflowExecutionsRequest {
    string namespace = 1;
    int32 maximum_page_size = 2;
    bytes next_page_token = 3;
    temporal.api.filter.v1.StartTimeFilter start_time_filter = 4;
    oneof filters {
        temporal.api.filter.v1.WorkflowExecutionFilter execution_filter = 5;
        temporal.api.filter.v1.WorkflowTypeFilter type_filter = 6;
        temporal.api.filter.v1.StatusFilter status_filter = 7;
    }
}

message ListClosedWorkflowExecutionsResponse {
    repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
    bytes next_page_token = 2;
}

message ListWorkflowExecutionsRequest {
    string namespace = 1;
    int32 page_size = 2;
    bytes next_page_token = 3;
    string query = 4;
}

message ListWorkflowExecutionsResponse {
    repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
    bytes next_page_token = 2;
}

message ListArchivedWorkflowExecutionsRequest {
    string namespace = 1;
    int32 page_size = 2;
    bytes next_page_token = 3;
    string query = 4;
}

message ListArchivedWorkflowExecutionsResponse {
    repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
    bytes next_page_token = 2;
}

message ScanWorkflowExecutionsRequest {
    string namespace = 1;
    int32 page_size = 2;
    bytes next_page_token = 3;
    string query = 4;
}

message ScanWorkflowExecutionsResponse {
    repeated temporal.api.workflow.v1.WorkflowExecutionInfo executions = 1;
    bytes next_page_token = 2;
}

message CountWorkflowExecutionsRequest {
    string namespace = 1;
    string query = 2;
}

message CountWorkflowExecutionsResponse {
    // If `query` is not grouping by any field, the count is an approximate number
    // of workflows that matches the query.
    // If `query` is grouping by a field, the count is simply the sum of the counts
    // of the groups returned in the response. This number can be smaller than the
    // total number of workflows matching the query.
    int64 count = 1;

    // `groups` contains the groups if the request is grouping by a field.
    // The list might not be complete, and the counts of each group is approximate.
    repeated AggregationGroup groups = 2;

    message AggregationGroup {
        repeated temporal.api.common.v1.Payload group_values = 1;
        int64 count = 2;
    }
}

message GetSearchAttributesRequest {
}

message GetSearchAttributesResponse {
    map<string, temporal.api.enums.v1.IndexedValueType> keys = 1;
}

message RespondQueryTaskCompletedRequest {
    bytes task_token = 1;
    temporal.api.enums.v1.QueryResultType completed_type = 2;
    temporal.api.common.v1.Payloads query_result = 3;
    string error_message = 4;
    reserved 5;
    string namespace = 6;
}

message RespondQueryTaskCompletedResponse {
}

message ResetStickyTaskQueueRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message ResetStickyTaskQueueResponse {
}

message QueryWorkflowRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
    temporal.api.query.v1.WorkflowQuery query = 3;
    // QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
    // Default: QUERY_REJECT_CONDITION_NONE.
    temporal.api.enums.v1.QueryRejectCondition query_reject_condition = 4;
}

message QueryWorkflowResponse {
    temporal.api.common.v1.Payloads query_result = 1;
    temporal.api.query.v1.QueryRejected query_rejected = 2;
}

message DescribeWorkflowExecutionRequest {
    string namespace = 1;
    temporal.api.common.v1.WorkflowExecution execution = 2;
}

message DescribeWorkflowExecutionResponse {
    temporal.api.workflow.v1.WorkflowExecutionConfig execution_config = 1;
    temporal.api.workflow.v1.WorkflowExecutionInfo workflow_execution_info = 2;
    repeated temporal.api.workflow.v1.PendingActivityInfo pending_activities = 3;
    repeated temporal.api.workflow.v1.PendingChildExecutionInfo pending_children = 4;
    temporal.api.workflow.v1.PendingWorkflowTaskInfo pending_workflow_task = 5;
    repeated temporal.api.workflow.v1.CallbackInfo callbacks = 6;
    repeated temporal.api.workflow.v1.PendingNexusOperationInfo pending_nexus_operations = 7;
}

// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
message DescribeTaskQueueRequest {
    string namespace = 1;
    // Sticky queues are not supported in `ENHANCED` mode.
    temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
    // Deprecated. Use `ENHANCED` mode with `task_queue_types`. Ignored in `ENHANCED` mode.
    // If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
    temporal.api.enums.v1.TaskQueueType task_queue_type = 3;
    // Deprecated. Ignored in `ENHANCED` mode.
    bool include_task_queue_status = 4;

    // All options except `task_queue_type` and `include_task_queue_status` are only available in the `ENHANCED` mode.
    temporal.api.enums.v1.DescribeTaskQueueMode api_mode = 5;

    // Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
    // mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
    // unversioned queue will be returned.
    // (-- api-linter: core::0140::prepositions --)
    temporal.api.taskqueue.v1.TaskQueueVersionSelection versions = 6;

    // Task queue types to report info about. If not specified, all types are considered.
    repeated temporal.api.enums.v1.TaskQueueType task_queue_types = 7;
    // Report backlog info for the requested task queue types and versions
    // bool report_backlog_info = 8;
    // Report list of pollers for requested task queue types and versions
    bool report_pollers = 9;
    // Report task reachability for the requested versions and all task types (task reachability is not reported
    // per task type).
    bool report_task_reachability = 10;
}

message DescribeTaskQueueResponse {
    // Deprecated. Use `versions_info.types_info.pollers` with `ENHANCED` mode instead.
    // Not set in `ENHANCED` mode.
    repeated temporal.api.taskqueue.v1.PollerInfo pollers = 1;
    // Deprecated. Not set in `ENHANCED` mode.
    temporal.api.taskqueue.v1.TaskQueueStatus task_queue_status = 2;

    // This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
    // Only set in `ENHANCED` mode.
    map<string, temporal.api.taskqueue.v1.TaskQueueVersionInfo> versions_info = 3;
}

message GetClusterInfoRequest {
}

// GetClusterInfoResponse contains information about Temporal cluster.
message GetClusterInfoResponse {
    // Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
    // Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
    map<string,string> supported_clients = 1;
    string server_version = 2;
    string cluster_id = 3;
    temporal.api.version.v1.VersionInfo version_info = 4;
    string cluster_name = 5;
    int32 history_shard_count = 6;
    string persistence_store = 7;
    string visibility_store = 8;
}

message GetSystemInfoRequest {
}

message GetSystemInfoResponse {
    // Version of the server.
    string server_version = 1;

    // All capabilities the system supports.
    Capabilities capabilities = 2;

    // System capability details.
    message Capabilities {
        // True if signal and query headers are supported.
        bool signal_and_query_header = 1;

        // True if internal errors are differentiated from other types of errors for purposes of
        // retrying non-internal errors.
        //
        // When unset/false, clients retry all failures. When true, clients should only retry
        // non-internal errors.
        bool internal_error_differentiation = 2;

        // True if RespondActivityTaskFailed API supports including heartbeat details
        bool activity_failure_include_heartbeat = 3;

        // Supports scheduled workflow features.
        bool supports_schedules = 4;

        // True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
        bool encoded_failure_attributes = 5;

        // True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
        // (see:
        // https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
        bool build_id_based_versioning = 6;

        // True if server supports upserting workflow memo
        bool upsert_memo = 7;

        // True if server supports eager workflow task dispatching for the StartWorkflowExecution API
        bool eager_workflow_start = 8;

        // True if the server knows about the sdk metadata field on WFT completions and will record
        // it in history
        bool sdk_metadata = 9;

        // True if the server supports count group by execution status
        // (-- api-linter: core::0140::prepositions=disabled --)
        bool count_group_by_execution_status = 10;
    }
}

message ListTaskQueuePartitionsRequest {
    string namespace = 1;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 2;
}

message ListTaskQueuePartitionsResponse {
    repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata activity_task_queue_partitions = 1;
    repeated temporal.api.taskqueue.v1.TaskQueuePartitionMetadata workflow_task_queue_partitions = 2;
}

// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
message CreateScheduleRequest {
    // The namespace the schedule should be created in.
    string namespace = 1;
    // The id of the new schedule.
    string schedule_id = 2;
    // The schedule spec, policies, action, and initial state.
    temporal.api.schedule.v1.Schedule schedule = 3;
    // Optional initial patch (e.g. to run the action once immediately).
    temporal.api.schedule.v1.SchedulePatch initial_patch = 4;
    // The identity of the client who initiated this request.
    string identity = 5;
    // A unique identifier for this create request for idempotence. Typically UUIDv4.
    string request_id = 6;
    // Memo and search attributes to attach to the schedule itself.
    temporal.api.common.v1.Memo memo = 7;
    temporal.api.common.v1.SearchAttributes search_attributes = 8;
}

message CreateScheduleResponse {
    bytes conflict_token = 1;
}

message DescribeScheduleRequest {
    // The namespace of the schedule to describe.
    string namespace = 1;
    // The id of the schedule to describe.
    string schedule_id = 2;
}

message DescribeScheduleResponse {
    // The complete current schedule details. This may not match the schedule as
    // created because:
    // - some types of schedule specs may get compiled into others (e.g.
    //   CronString into StructuredCalendarSpec)
    // - some unspecified fields may be replaced by defaults
    // - some fields in the state are modified automatically
    // - the schedule may have been modified by UpdateSchedule or PatchSchedule
    temporal.api.schedule.v1.Schedule schedule = 1;
    // Extra schedule state info.
    temporal.api.schedule.v1.ScheduleInfo info = 2;
    // The memo and search attributes that the schedule was created with.
    temporal.api.common.v1.Memo memo = 3;
    temporal.api.common.v1.SearchAttributes search_attributes = 4;

    // This value can be passed back to UpdateSchedule to ensure that the
    // schedule was not modified between a Describe and an Update, which could
    // lead to lost updates and other confusion.
    bytes conflict_token = 5;
}

message UpdateScheduleRequest {
    // The namespace of the schedule to update.
    string namespace = 1;
    // The id of the schedule to update.
    string schedule_id = 2;
    // The new schedule. The four main fields of the schedule (spec, action,
    // policies, state) are replaced completely by the values in this message.
    temporal.api.schedule.v1.Schedule schedule = 3;
    // This can be the value of conflict_token from a DescribeScheduleResponse,
    // which will cause this request to fail if the schedule has been modified
    // between the Describe and this Update.
    // If missing, the schedule will be updated unconditionally.
    bytes conflict_token = 4;
    // The identity of the client who initiated this request.
    string identity = 5;
    // A unique identifier for this update request for idempotence. Typically UUIDv4.
    string request_id = 6;
    // Schedule search attributes to be updated.
    // Do not set this field if you do not want to update the search attributes.
    // A non-null empty object will set the search attributes to an empty map.
    // Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
    // you must also set the `schedule` field; otherwise, it will unset the schedule.
    temporal.api.common.v1.SearchAttributes search_attributes = 7;
}

message UpdateScheduleResponse {
}

message PatchScheduleRequest {
    // The namespace of the schedule to patch.
    string namespace = 1;
    // The id of the schedule to patch.
    string schedule_id = 2;
    temporal.api.schedule.v1.SchedulePatch patch = 3;
    // The identity of the client who initiated this request.
    string identity = 4;
    // A unique identifier for this update request for idempotence. Typically UUIDv4.
    string request_id = 5;
}

message PatchScheduleResponse {
}

message ListScheduleMatchingTimesRequest {
    // The namespace of the schedule to query.
    string namespace = 1;
    // The id of the schedule to query.
    string schedule_id = 2;
    // Time range to query.
    google.protobuf.Timestamp start_time = 3;
    google.protobuf.Timestamp end_time = 4;
}

message ListScheduleMatchingTimesResponse {
    repeated google.protobuf.Timestamp start_time = 1;
}

message DeleteScheduleRequest {
    // The namespace of the schedule to delete.
    string namespace = 1;
    // The id of the schedule to delete.
    string schedule_id = 2;
    // The identity of the client who initiated this request.
    string identity = 3;
}

message DeleteScheduleResponse {
}

message ListSchedulesRequest {
    // The namespace to list schedules in.
    string namespace = 1;
    // How many to return at once.
    int32 maximum_page_size = 2;
    // Token to get the next page of results.
    bytes next_page_token = 3;
    // Query to filter schedules.
    string query = 4;
}

message ListSchedulesResponse {
    repeated temporal.api.schedule.v1.ScheduleListEntry schedules = 1;
    bytes next_page_token = 2;
}

message UpdateWorkerBuildIdCompatibilityRequest {
    message AddNewCompatibleVersion {
        // A new id to be added to an existing compatible set.
        string new_build_id = 1;
        // A build id which must already exist in the version sets known by the task queue. The new
        // id will be stored in the set containing this id, marking it as compatible with
        // the versions within.
        string existing_compatible_build_id = 2;
        // When set, establishes the compatible set being targeted as the overall default for the
        // queue. If a different set was the current default, the targeted set will replace it as
        // the new default.
        bool make_set_default = 3;
    }

    message MergeSets {
        // A build ID in the set whose default will become the merged set default
        string primary_set_build_id = 1;
        // A build ID in the set which will be merged into the primary set
        string secondary_set_build_id = 2;
    }

    string namespace = 1;
    // Must be set, the task queue to apply changes to. Because all workers on a given task queue
    // must have the same set of workflow & activity implementations, there is no reason to specify
    // a task queue type here.
    string task_queue = 2;
    oneof operation {
        // A new build id. This operation will create a new set which will be the new overall
        // default version for the queue, with this id as its only member. This new set is
        // incompatible with all previous sets/versions.
        //
        // (-- api-linter: core::0140::prepositions=disabled
        //     aip.dev/not-precedent: In makes perfect sense here. --)
        string add_new_build_id_in_new_default_set = 3;
        // Adds a new id to an existing compatible set, see sub-message definition for more.
        AddNewCompatibleVersion add_new_compatible_build_id = 4;
        // Promote an existing set to be the current default (if it isn't already) by targeting
        // an existing build id within it. This field's value is the extant build id.
        //
        // (-- api-linter: core::0140::prepositions=disabled
        //     aip.dev/not-precedent: Names are hard. --)
        string promote_set_by_build_id = 5;
        // Promote an existing build id within some set to be the current default for that set.
        //
        // (-- api-linter: core::0140::prepositions=disabled
        //     aip.dev/not-precedent: Within makes perfect sense here. --)
        string promote_build_id_within_set = 6;
        // Merge two existing sets together, thus declaring all build IDs in both sets compatible
        // with one another. The primary set's default will become the default for the merged set.
        // This is useful if you've accidentally declared a new ID as incompatible you meant to
        // declare as compatible. The unusual case of incomplete replication during failover could
        // also result in a split set, which this operation can repair.
        MergeSets merge_sets = 7;
    }
}
message UpdateWorkerBuildIdCompatibilityResponse {
    reserved 1;
    reserved "version_set_id";
}

message GetWorkerBuildIdCompatibilityRequest {
    string namespace = 1;
    // Must be set, the task queue to interrogate about worker id compatibility.
    string task_queue = 2;
    // Limits how many compatible sets will be returned. Specify 1 to only return the current
    // default major version set. 0 returns all sets.
    int32 max_sets = 3;
}
message GetWorkerBuildIdCompatibilityResponse {
    // Major version sets, in order from oldest to newest. The last element of the list will always
    // be the current default major version. IE: New workflows will target the most recent version
    // in that version set.
    //
    // There may be fewer sets returned than exist, if the request chose to limit this response.
    repeated temporal.api.taskqueue.v1.CompatibleVersionSet major_version_sets = 1;
}

// (-- api-linter: core::0134::request-mask-required=disabled
//     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
// (-- api-linter: core::0134::request-resource-required=disabled
//     aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
message UpdateWorkerVersioningRulesRequest {
    // Inserts the rule to the list of assignment rules for this Task Queue.
    // The rules are evaluated in order, starting from index 0. The first
    // applicable rule will be applied and the rest will be ignored.
    message InsertBuildIdAssignmentRule {
        // Use this option to insert the rule in a particular index. By
        // default, the new rule is inserted at the beginning of the list
        // (index 0). If the given index is too larger the rule will be
        // inserted at the end of the list.
        int32 rule_index = 1;
        temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;
    }

    // Replaces the assignment rule at a given index.
    message ReplaceBuildIdAssignmentRule {
        int32 rule_index = 1;
        temporal.api.taskqueue.v1.BuildIdAssignmentRule rule = 2;

        // By default presence of one unconditional rule is enforced, otherwise
        // the replace operation will be rejected. Set `force` to true to
        // bypass this validation. An unconditional assignment rule:
        //   - Has no hint filter
        //   - Has no ramp
        bool force = 3;
    }

    message DeleteBuildIdAssignmentRule {
        int32 rule_index = 1;

        // By default presence of one unconditional rule is enforced, otherwise
        // the delete operation will be rejected. Set `force` to true to
        // bypass this validation. An unconditional assignment rule:
        //   - Has no hint filter
        //   - Has no ramp
        bool force = 2;
    }

    // Adds the rule to the list of redirect rules for this Task Queue. There
    // can be at most one redirect rule for each distinct Source Build ID.
    message AddCompatibleBuildIdRedirectRule {
        temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
    }

    // Replaces the routing rule with the given source Build ID.
    message ReplaceCompatibleBuildIdRedirectRule {
        temporal.api.taskqueue.v1.CompatibleBuildIdRedirectRule rule = 1;
    }

    message DeleteCompatibleBuildIdRedirectRule {
        string source_build_id = 1;
    }

    // This command is intended to be used to complete the rollout of a Build
    // ID and cleanup unnecessary rules possibly created during a gradual
    // rollout. Specifically, this command will make the following changes
    // atomically:
    //  1. Adds an assignment rule (with full ramp) for the target Build ID at
    //     the end of the list.
    //  2. Removes all previously added assignment rules to the given target
    //     Build ID (if any).
    //  3. Removes any fully-ramped assignment rule for other Build IDs.
    message CommitBuildId {
        string target_build_id = 1;

        // To prevent committing invalid Build IDs, we reject the request if no
        // pollers has been seen recently for this Build ID. Use the `force`
        // option to disable this validation.
        bool force = 2;
    }

    string namespace = 1;
    string task_queue = 2;

    // A valid conflict_token can be taken from the previous
    // ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
    // An invalid token will cause this request to fail, ensuring that if the rules
    // for this Task Queue have been modified between the previous and current
    // operation, the request will fail instead of causing an unpredictable mutation.
    bytes conflict_token = 3;

    oneof operation {
        InsertBuildIdAssignmentRule insert_assignment_rule = 4;
        ReplaceBuildIdAssignmentRule replace_assignment_rule = 5;
        DeleteBuildIdAssignmentRule delete_assignment_rule = 6;
        AddCompatibleBuildIdRedirectRule add_compatible_redirect_rule = 7;
        ReplaceCompatibleBuildIdRedirectRule replace_compatible_redirect_rule = 8;
        DeleteCompatibleBuildIdRedirectRule delete_compatible_redirect_rule = 9;
        CommitBuildId commit_build_id = 10;
    }
}

message UpdateWorkerVersioningRulesResponse {
    repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
    repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;

    // This value can be passed back to UpdateWorkerVersioningRulesRequest to
    // ensure that the rules were not modified between the two updates, which
    // could lead to lost updates and other confusion.
    bytes conflict_token = 3;
}

message GetWorkerVersioningRulesRequest {
    string namespace = 1;
    string task_queue = 2;
}

message GetWorkerVersioningRulesResponse {
    repeated temporal.api.taskqueue.v1.TimestampedBuildIdAssignmentRule assignment_rules = 1;
    repeated temporal.api.taskqueue.v1.TimestampedCompatibleBuildIdRedirectRule compatible_redirect_rules = 2;

    // This value can be passed back to UpdateWorkerVersioningRulesRequest to
    // ensure that the rules were not modified between this List and the Update,
    // which could lead to lost updates and other confusion.
    bytes conflict_token = 3;
}

// Deprecated. Use `DescribeTaskQueue`.
message GetWorkerTaskReachabilityRequest {
    string namespace = 1;
    // Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
    // The number of build ids that can be queried in a single API call is limited.
    // Open source users can adjust this limit by setting the server's dynamic config value for
    // `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
    repeated string build_ids = 2;

    // Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
    // build ids in the namespace.
    // Must specify at least one task queue if querying for an unversioned worker.
    // The number of task queues that the server will fetch reachability information for is limited.
    // See the `GetWorkerTaskReachabilityResponse` documentation for more information.
    repeated string task_queues = 3;

    // Type of reachability to query for.
    // `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
    // Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
    // Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
    // unspecified.
    // See the TaskReachability docstring for information about each enum variant.
    temporal.api.enums.v1.TaskReachability reachability = 4;
}

// Deprecated. Use `DescribeTaskQueue`.
message GetWorkerTaskReachabilityResponse {
    // Task reachability, broken down by build id and then task queue.
    // When requesting a large number of task queues or all task queues associated with the given build ids in a
    // namespace, all task queues will be listed in the response but some of them may not contain reachability
    // information due to a server enforced limit. When reaching the limit, task queues that reachability information
    // could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
    // another call to get the reachability for those task queues.
    //
    // Open source users can adjust this limit by setting the server's dynamic config value for
    // `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
    repeated temporal.api.taskqueue.v1.BuildIdReachability build_id_reachability = 1;
}

// (-- api-linter: core::0134=disabled
//     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
message UpdateWorkflowExecutionRequest {
    // The namespace name of the target workflow
    string namespace = 1;
    // The target workflow id and (optionally) a specific run thereof
    // (-- api-linter: core::0203::optional=disabled
    //     aip.dev/not-precedent: false positive triggered by the word "optional" --)
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    // If set, this call will error if the most recent (if no run id is set on
    // `workflow_execution`), or specified (if it is) workflow execution is not
    // part of the same execution chain as this id.
    string first_execution_run_id = 3;

    // Describes when this request should return - basically whether the
    // update is synchronous, asynchronous, or somewhere in between.
    temporal.api.update.v1.WaitPolicy wait_policy = 4;

    // The request information that will be delivered all the way down to the
    // workflow execution.
    temporal.api.update.v1.Request request = 5;
}

message UpdateWorkflowExecutionResponse {
    // Enough information for subsequent poll calls if needed. Never null.
    temporal.api.update.v1.UpdateRef update_ref = 1;

    // The outcome of the update if and only if the workflow execution update
    // has completed. If this response is being returned before the update has
    // completed then this field will not be set.
    temporal.api.update.v1.Outcome outcome = 2;

    // The most advanced lifecycle stage that the Update is known to have
    // reached, where lifecycle stages are ordered
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    // UNSPECIFIED will be returned if and only if the server's maximum wait
    // time was reached before the Update reached the stage specified in the
    // request WaitPolicy, and before the context deadline expired; clients may
    // may then retry the call as needed.
    temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 3;
}

message StartBatchOperationRequest {
    // Namespace that contains the batch operation
    string namespace = 1;
    // Visibility query defines the the group of workflow to apply the batch operation
    // This field and `executions` are mutually exclusive
    string visibility_query = 2;
    // Job ID defines the unique ID for the batch job
    string job_id = 3;
    // Reason to perform the batch operation
    string reason = 4;
    // Executions to apply the batch operation
    // This field and `visibility_query` are mutually exclusive
    repeated temporal.api.common.v1.WorkflowExecution executions = 5;
    // Limit for the number of operations processed per second within this batch.
    // Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
    // overload and minimize potential delays in executing ongoing tasks for user workers.
    // Note that when no explicit limit is provided, the server will operate according to its limit defined by the
    // dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
    // server's configured limit.
    float max_operations_per_second = 6;
    // Operation input
    oneof operation {
        temporal.api.batch.v1.BatchOperationTermination termination_operation = 10;
        temporal.api.batch.v1.BatchOperationSignal signal_operation = 11;
        temporal.api.batch.v1.BatchOperationCancellation cancellation_operation = 12;
        temporal.api.batch.v1.BatchOperationDeletion deletion_operation = 13;
        temporal.api.batch.v1.BatchOperationReset reset_operation = 14;
    }
}

message StartBatchOperationResponse {
}

message StopBatchOperationRequest {
    // Namespace that contains the batch operation
    string namespace = 1;
    // Batch job id
    string job_id = 2;
    // Reason to stop a batch operation
    string reason = 3;
    // Identity of the operator
    string identity = 4;
}

message StopBatchOperationResponse {
}

message DescribeBatchOperationRequest {
    // Namespace that contains the batch operation
    string namespace = 1;
    // Batch job id
    string job_id = 2;
}

message DescribeBatchOperationResponse {
    // Batch operation type
    temporal.api.enums.v1.BatchOperationType operation_type = 1;
    // Batch job ID
    string job_id = 2;
    // Batch operation state
    temporal.api.enums.v1.BatchOperationState state = 3;
    // Batch operation start time
    google.protobuf.Timestamp start_time = 4;
    // Batch operation close time
    google.protobuf.Timestamp close_time = 5;
    // Total operation count
    int64 total_operation_count = 6;
    // Complete operation count
    int64 complete_operation_count = 7;
    // Failure operation count
    int64 failure_operation_count = 8;
    // Identity indicates the operator identity
    string identity = 9;
    // Reason indicates the reason to stop a operation
    string reason = 10;
}

message ListBatchOperationsRequest {
    // Namespace that contains the batch operation
    string namespace = 1;
    // List page size
    int32 page_size = 2;
    // Next page token
    bytes next_page_token = 3;
}

message ListBatchOperationsResponse {
    // BatchOperationInfo contains the basic info about batch operation
    repeated temporal.api.batch.v1.BatchOperationInfo operation_info = 1;
    bytes next_page_token = 2;
}

message PollWorkflowExecutionUpdateRequest {
    // The namespace of the workflow execution to which the update was
    // originally issued.
    string namespace = 1;
    // The update reference returned in the initial
    // UpdateWorkflowExecutionResponse
    temporal.api.update.v1.UpdateRef update_ref = 2;
    // The identity of the worker/client who is polling this update outcome
    string identity = 3;
    // Describes when this poll request should return a response.
    // Omit to request a non-blocking poll.
    temporal.api.update.v1.WaitPolicy wait_policy = 4;
}

message PollWorkflowExecutionUpdateResponse {
    // The outcome of the update if and only if the update has completed. If
    // this response is being returned before the update has completed (e.g. due
    // to the specification of a wait policy that only waits on
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
    // not be set.
    temporal.api.update.v1.Outcome outcome = 1;
    // The most advanced lifecycle stage that the Update is known to have
    // reached, where lifecycle stages are ordered
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    // UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    // UNSPECIFIED will be returned if and only if the server's maximum wait
    // time was reached before the Update reached the stage specified in the
    // request WaitPolicy, and before the context deadline expired; clients may
    // may then retry the call as needed.
    temporal.api.enums.v1.UpdateWorkflowExecutionLifecycleStage stage = 2;
    // Sufficient information to address this update.
    temporal.api.update.v1.UpdateRef update_ref = 3;
}

message PollNexusTaskQueueRequest {
    string namespace = 1;
    // The identity of the client who initiated this request.
    string identity = 2;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
    // Information about this worker's build identifier and if it is choosing to use the versioning
    // feature. See the `WorkerVersionCapabilities` docstring for more.
    temporal.api.common.v1.WorkerVersionCapabilities worker_version_capabilities = 4;
}

message PollNexusTaskQueueResponse {
    // An opaque unique identifier for this task for correlating a completion request the embedded request.
    bytes task_token = 1;
    // Embedded request as translated from the incoming frontend request.
    temporal.api.nexus.v1.Request request = 2;
}

message RespondNexusTaskCompletedRequest {
    string namespace = 1;
    // The identity of the client who initiated this request.
    string identity = 2;
    // A unique identifier for this task as received via a poll response.
    bytes task_token = 3;
    // Embedded response to be translated into a frontend response.
    temporal.api.nexus.v1.Response response = 4;
}

message RespondNexusTaskCompletedResponse {
}

message RespondNexusTaskFailedRequest {
    string namespace = 1;
    // The identity of the client who initiated this request.
    string identity = 2;
    // A unique identifier for this task.
    bytes task_token = 3;
    // The error the handler failed with.
    temporal.api.nexus.v1.HandlerError error = 4;
}

message RespondNexusTaskFailedResponse {
}

message ExecuteMultiOperationRequest {
    string namespace = 1;

    // List of operations to execute within a single workflow.
    //
    // Preconditions:
    // - The list of operations must not be empty.
    // - The workflow ids must match across operations.
    // - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
    //
    // Note that additional operation-specific restrictions have to be considered.
    repeated Operation operations = 2;

    message Operation {
        oneof operation {
            // Additional restrictions:
            // - setting `cron_schedule` is invalid
            // - setting `request_eager_execution` is invalid
            StartWorkflowExecutionRequest start_workflow = 1;

            UpdateWorkflowExecutionRequest update_workflow = 2;
        }
    }
}

message ExecuteMultiOperationResponse {
    repeated Response responses = 1;

    message Response {
        oneof response {
            StartWorkflowExecutionResponse start_workflow = 1;
            UpdateWorkflowExecutionResponse update_workflow = 2;
        }
    }
}
