// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

syntax = "proto3";

package temporal.api.history.v1;

option go_package = "go.temporal.io/api/history/v1;history";
option java_package = "io.temporal.api.history.v1";
option java_multiple_files = true;
option java_outer_classname = "MessageProto";
option ruby_package = "Temporalio::Api::History::V1";
option csharp_namespace = "Temporalio.Api.History.V1";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

import "temporal/api/enums/v1/event_type.proto";
import "temporal/api/enums/v1/failed_cause.proto";
import "temporal/api/enums/v1/update.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/deployment/v1/message.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/taskqueue/v1/message.proto";
import "temporal/api/update/v1/message.proto";
import "temporal/api/workflow/v1/message.proto";
import "temporal/api/sdk/v1/task_complete_metadata.proto";
import "temporal/api/sdk/v1/user_metadata.proto";

// Always the first event in workflow history
message WorkflowExecutionStartedEventAttributes {
    temporal.api.common.v1.WorkflowType workflow_type = 1;
    // If this workflow is a child, the namespace our parent lives in.
    // SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only.
    string parent_workflow_namespace = 2;
    string parent_workflow_namespace_id = 27;
    // Contains information about parent workflow execution that initiated the child workflow these attributes belong to.
    // If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated.
    temporal.api.common.v1.WorkflowExecution parent_workflow_execution = 3;
    // EventID of the child execution initiated event in parent workflow 
    int64 parent_initiated_event_id = 4;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 5;
    // SDK will deserialize this and provide it as arguments to the workflow function
    temporal.api.common.v1.Payloads input = 6;
    // Total workflow execution timeout including retries and continue as new.
    google.protobuf.Duration workflow_execution_timeout = 7;
    // Timeout of a single workflow run.
    google.protobuf.Duration workflow_run_timeout = 8;
    // Timeout of a single workflow task.
    google.protobuf.Duration workflow_task_timeout = 9;
    // Run id of the previous workflow which continued-as-new or retired or cron executed into this
    // workflow.
    string continued_execution_run_id = 10;
    temporal.api.enums.v1.ContinueAsNewInitiator initiator = 11;
    temporal.api.failure.v1.Failure continued_failure = 12;
    temporal.api.common.v1.Payloads last_completion_result = 13;
    // This is the run id when the WorkflowExecutionStarted event was written.
    // A workflow reset changes the execution run_id, but preserves this field.
    string original_execution_run_id = 14;
    // Identity of the client who requested this execution
    string identity = 15;
    // This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
    // Used to identify a chain.
    string first_execution_run_id = 16;
    temporal.api.common.v1.RetryPolicy retry_policy = 17;
    // Starting at 1, the number of times we have tried to execute this workflow
    int32 attempt = 18;
    // The absolute time at which the workflow will be timed out.
    // This is passed without change to the next run/retry of a workflow.
    google.protobuf.Timestamp workflow_execution_expiration_time = 19;
    // If this workflow runs on a cron schedule, it will appear here
    string cron_schedule = 20;
    // For a cron workflow, this contains the amount of time between when this iteration of
    // the cron workflow was scheduled and when it should run next per its cron_schedule.
    google.protobuf.Duration first_workflow_task_backoff = 21;
    temporal.api.common.v1.Memo memo = 22;
    temporal.api.common.v1.SearchAttributes search_attributes = 23;
    temporal.api.workflow.v1.ResetPoints prev_auto_reset_points = 24;
    temporal.api.common.v1.Header header = 25;
    // Version of the child execution initiated event in parent workflow
    // It should be used together with parent_initiated_event_id to identify
    // a child initiated event for global namespace
    int64 parent_initiated_event_version = 26;
    // This field is new in 1.21.
    string workflow_id = 28;
    // If this workflow intends to use anything other than the current overall default version for
    // the queue, then we include it here.
    // Deprecated. [cleanup-experimental-wv]
    temporal.api.common.v1.WorkerVersionStamp source_version_stamp = 29;
    // Completion callbacks attached when this workflow was started.
    repeated temporal.api.common.v1.Callback completion_callbacks = 30;

    // Contains information about the root workflow execution.
    // The root workflow execution is defined as follows:
    // 1. A workflow without parent workflow is its own root workflow.
    // 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
    // Note: workflows continued as new or reseted may or may not have parents, check examples below.
    //
    // Examples:
    //   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
    //     - The root workflow of all three workflows is W1.
    //   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
    //     - The root workflow of all three workflows is W1.
    //   Scenario 3: Workflow W1 continued as new W2.
    //     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
    //   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
    //     - The root workflow of all three workflows is W1.
    //   Scenario 5: Workflow W1 is reseted, creating W2.
    //     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
    temporal.api.common.v1.WorkflowExecution root_workflow_execution = 31;
    // When present, this execution is assigned to the build ID of its parent or previous execution.
    // Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    string inherited_build_id = 32;
    // Versioning override applied to this workflow when it was started.
    temporal.api.workflow.v1.VersioningOverride versioning_override = 33;
    // When present, it means this is a child workflow of a parent that is Pinned to this Worker
    // Deployment Version. In this case, child workflow will start as Pinned to this Version instead
    // of starting on the Current Version of its Task Queue.
    // This is set only if the child workflow is starting on a Task Queue belonging to the same
    // Worker Deployment Version.
    string parent_pinned_worker_deployment_version = 34;

    // Priority metadata
    temporal.api.common.v1.Priority priority = 35;
}

message WorkflowExecutionCompletedEventAttributes {
    // Serialized result of workflow completion (ie: The return value of the workflow function)
    temporal.api.common.v1.Payloads result = 1;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 2;
    // If another run is started by cron, this contains the new run id.
    string new_execution_run_id = 3;
}

message WorkflowExecutionFailedEventAttributes {
    // Serialized result of workflow failure (ex: An exception thrown, or error returned)
    temporal.api.failure.v1.Failure failure = 1;
    temporal.api.enums.v1.RetryState retry_state = 2;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 3;
    // If another run is started by cron or retry, this contains the new run id.
    string new_execution_run_id = 4;
}

message WorkflowExecutionTimedOutEventAttributes {
    temporal.api.enums.v1.RetryState retry_state = 1;
    // If another run is started by cron or retry, this contains the new run id.
    string new_execution_run_id = 2;
}

message WorkflowExecutionContinuedAsNewEventAttributes {
    // The run ID of the new workflow started by this continue-as-new
    string new_execution_run_id = 1;
    temporal.api.common.v1.WorkflowType workflow_type = 2;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 3;
    temporal.api.common.v1.Payloads input = 4;
    // Timeout of a single workflow run.
    google.protobuf.Duration workflow_run_timeout = 5;
    // Timeout of a single workflow task.
    google.protobuf.Duration workflow_task_timeout = 6;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 7;
    // TODO: How and is this used?
    google.protobuf.Duration backoff_start_interval = 8;
    temporal.api.enums.v1.ContinueAsNewInitiator initiator = 9;
    // TODO: David are these right?
    // Deprecated. If a workflow's retry policy would cause a new run to start when the current one
    // has failed, this field would be populated with that failure. Now (when supported by server
    // and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set.
    temporal.api.failure.v1.Failure failure = 10;
    // TODO: Is this the result of *this* workflow as it continued-as-new?
    temporal.api.common.v1.Payloads last_completion_result = 11;
    temporal.api.common.v1.Header header = 12;
    temporal.api.common.v1.Memo memo = 13;
    temporal.api.common.v1.SearchAttributes search_attributes = 14;
    // If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
    // the assignment rules will be used to independently assign a Build ID to the new execution.
    bool inherit_build_id = 15;

    // workflow_execution_timeout is omitted as it shouldn't be overridden from within a workflow.
}

message WorkflowTaskScheduledEventAttributes {
    // The task queue this workflow task was enqueued in, which could be a normal or sticky queue
    temporal.api.taskqueue.v1.TaskQueue task_queue = 1;
    // How long the worker has to process this task once receiving it before it times out
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 2;
    // Starting at 1, how many attempts there have been to complete this task
    int32 attempt = 3;
}

message WorkflowTaskStartedEventAttributes {
    // The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
    int64 scheduled_event_id = 1;
    // Identity of the worker who picked up this task
    string identity = 2;
    // TODO: ? Appears unused?
    string request_id = 3;
    // True if this workflow should continue-as-new soon because its history size (in
    // either event count or bytes) is getting large.
    bool suggest_continue_as_new = 4;
    // Total history size in bytes, which the workflow might use to decide when to
    // continue-as-new regardless of the suggestion. Note that history event count is
    // just the event id of this event, so we don't include it explicitly here.
    int64 history_size_bytes = 5;
    // Version info of the worker to whom this task was dispatched.
    // Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    temporal.api.common.v1.WorkerVersionStamp worker_version = 6;
    // Used by server internally to properly reapply build ID redirects to an execution
    // when rebuilding it from events.
    // Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    int64 build_id_redirect_counter = 7;
}

message WorkflowTaskCompletedEventAttributes {
    // The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
    int64 scheduled_event_id = 1;
    // The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
    int64 started_event_id = 2;
    // Identity of the worker who completed this task
    string identity = 3;
    // Binary ID of the worker who completed this task
    string binary_checksum = 4;
    // Version info of the worker who processed this workflow task. If present, the `build_id` field
    // within is also used as `binary_checksum`, which may be omitted in that case (it may also be
    // populated to preserve compatibility).
    // Deprecated. Use `deployment` and `versioning_behavior` instead.
    temporal.api.common.v1.WorkerVersionStamp worker_version = 5;
    // Data the SDK wishes to record for itself, but server need not interpret, and does not
    // directly impact workflow state.
    temporal.api.sdk.v1.WorkflowTaskCompletedMetadata sdk_metadata = 6;

    // Local usage data sent during workflow task completion and recorded here for posterity
    temporal.api.common.v1.MeteringMetadata metering_metadata = 13;

    // The deployment that completed this task. May or may not be set for unversioned workers,
    // depending on whether a value is sent by the SDK. This value updates workflow execution's
    // `versioning_info.deployment`.
    // Deprecated. Replaced with `worker_deployment_version`.
    temporal.api.deployment.v1.Deployment deployment = 7 [deprecated = true];
    // Versioning behavior sent by the worker that completed this task for this particular workflow
    // execution. UNSPECIFIED means the task was completed by an unversioned worker. This value
    // updates workflow execution's `versioning_info.behavior`.
    temporal.api.enums.v1.VersioningBehavior versioning_behavior = 8;
    // The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
    // is set. This value updates workflow execution's `versioning_info.version`.
    // Experimental. Worker Deployments are experimental and might significantly change in the future.
    string worker_deployment_version = 9;
    // The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`
    // is set. This value updates workflow execution's `worker_deployment_name`.
    // Experimental. Worker Deployments are experimental and might significantly change in the future.
    string worker_deployment_name = 10;
}

message WorkflowTaskTimedOutEventAttributes {
    // The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
    int64 scheduled_event_id = 1;
    // The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
    int64 started_event_id = 2;
    temporal.api.enums.v1.TimeoutType timeout_type = 3;
}

message WorkflowTaskFailedEventAttributes {
    // The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
    int64 scheduled_event_id = 1;
    // The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
    int64 started_event_id = 2;
    temporal.api.enums.v1.WorkflowTaskFailedCause cause = 3;
    // The failure details
    temporal.api.failure.v1.Failure failure = 4;
    // If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?
    string identity = 5;
    // The original run id of the workflow. For reset workflow.
    string base_run_id = 6;
    // If the workflow is being reset, the new run id.
    string new_run_id = 7;
    // TODO: ?
    int64 fork_event_version = 8;
    // DEPRECATED since 1.21 - use `worker_version` instead.
    // If a worker explicitly failed this task, its binary id
    string binary_checksum = 9;
    // Version info of the worker who processed this workflow task. If present, the `build_id` field
    // within is also used as `binary_checksum`, which may be omitted in that case (it may also be
    // populated to preserve compatibility).
    // Deprecated. Use the info inside the corresponding WorkflowTaskStartedEvent
    temporal.api.common.v1.WorkerVersionStamp worker_version = 10;
}

message ActivityTaskScheduledEventAttributes {
    // The worker/user assigned identifier for the activity
    string activity_id = 1;
    temporal.api.common.v1.ActivityType activity_type = 2;
    // This used to be a `namespace` field which allowed to schedule activity in another namespace.
    reserved 3;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
    temporal.api.common.v1.Header header = 5;
    temporal.api.common.v1.Payloads input = 6;
    // Indicates how long the caller is willing to wait for an activity completion. Limits how long
    // retries will be attempted. Either this or `start_to_close_timeout` must be specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 7;
    // Limits time an activity task can stay in a task queue before a worker picks it up. This
    // timeout is always non retryable, as all a retry would achieve is to put it back into the same
    // queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
    // specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_start_timeout = 8;
    // Maximum time an activity is allowed to execute after being picked up by a worker. This
    // timeout is always retryable. Either this or `schedule_to_close_timeout` must be
    // specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 9;
    // Maximum permitted time between successful worker heartbeats.
    google.protobuf.Duration heartbeat_timeout = 10;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 11;
    // Activities are assigned a default retry policy controlled by the service's dynamic
    // configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set
    // retry_policy.maximum_attempts to 1.
    temporal.api.common.v1.RetryPolicy retry_policy = 12;
    // If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
    // Assignment rules of the activity's Task Queue will be used to determine the Build ID.
    bool use_workflow_build_id = 13;
    // Priority metadata. If this message is not present, or any fields are not
    // present, they inherit the values from the workflow.
    temporal.api.common.v1.Priority priority = 14;
}

message ActivityTaskStartedEventAttributes {
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to
    int64 scheduled_event_id = 1;
    // id of the worker that picked up this task
    string identity = 2;
    // TODO ??
    string request_id = 3;
    // Starting at 1, the number of times this task has been attempted
    int32 attempt = 4;
    // Will be set to the most recent failure details, if this task has previously failed and then
    // been retried.
    temporal.api.failure.v1.Failure last_failure = 5;
    // Version info of the worker to whom this task was dispatched.
    // Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    temporal.api.common.v1.WorkerVersionStamp worker_version = 6;
    // Used by server internally to properly reapply build ID redirects to an execution
    // when rebuilding it from events.
    // Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    int64 build_id_redirect_counter = 7;
}

message ActivityTaskCompletedEventAttributes {
    // Serialized results of the activity. IE: The return value of the activity function
    temporal.api.common.v1.Payloads result = 1;
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to
    int64 scheduled_event_id = 2;
    // The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to
    int64 started_event_id = 3;
    // id of the worker that completed this task
    string identity = 4;
    // Version info of the worker who processed this workflow task.
    // Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
    temporal.api.common.v1.WorkerVersionStamp worker_version = 5;
}

message ActivityTaskFailedEventAttributes {
    // Failure details
    temporal.api.failure.v1.Failure failure = 1;
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to
    int64 scheduled_event_id = 2;
    // The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to
    int64 started_event_id = 3;
    // id of the worker that failed this task
    string identity = 4;
    temporal.api.enums.v1.RetryState retry_state = 5;
    // Version info of the worker who processed this workflow task.
    // Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
    temporal.api.common.v1.WorkerVersionStamp worker_version = 6;
}

message ActivityTaskTimedOutEventAttributes {
    // If this activity had failed, was retried, and then timed out, that failure is stored as the
    // `cause` in here.
    temporal.api.failure.v1.Failure failure = 1;
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to
    int64 scheduled_event_id = 2;
    // The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to
    int64 started_event_id = 3;
    temporal.api.enums.v1.RetryState retry_state = 4;
}

message ActivityTaskCancelRequestedEventAttributes {
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to
    int64 scheduled_event_id = 1;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 2;
}

message ActivityTaskCanceledEventAttributes {
    // Additional information that the activity reported upon confirming cancellation
    temporal.api.common.v1.Payloads details = 1;
    // id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
    // activity
    int64 latest_cancel_requested_event_id = 2;
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to
    int64 scheduled_event_id = 3;
    // The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to
    int64 started_event_id = 4;
    // id of the worker who canceled this activity
    string identity = 5;
    // Version info of the worker who processed this workflow task.
    // Deprecated. Use the info inside the corresponding ActivityTaskStartedEvent
    temporal.api.common.v1.WorkerVersionStamp worker_version = 6;
}

message TimerStartedEventAttributes {
    // The worker/user assigned id for this timer
    string timer_id = 1;
    // How long until this timer fires
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_fire_timeout = 2;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 3;
}

message TimerFiredEventAttributes {
    // Will match the `timer_id` from `TIMER_STARTED` event for this timer
    string timer_id = 1;
    // The id of the `TIMER_STARTED` event itself
    int64 started_event_id = 2;
}

message TimerCanceledEventAttributes {
    // Will match the `timer_id` from `TIMER_STARTED` event for this timer
    string timer_id = 1;
    // The id of the `TIMER_STARTED` event itself
    int64 started_event_id = 2;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 3;
    // The id of the worker who requested this cancel
    string identity = 4;
}

message WorkflowExecutionCancelRequestedEventAttributes {
    // User provided reason for requesting cancellation
    // TODO: shall we create a new field with name "reason" and deprecate this one? 
    string cause = 1; 
    // TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?
    int64 external_initiated_event_id = 2;
    temporal.api.common.v1.WorkflowExecution external_workflow_execution = 3;
    // id of the worker or client who requested this cancel
    string identity = 4;
}

message WorkflowExecutionCanceledEventAttributes {
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 1;
    temporal.api.common.v1.Payloads details = 2;
}

message MarkerRecordedEventAttributes {
    // Workers use this to identify the "types" of various markers. Ex: Local activity, side effect.
    string marker_name = 1;
    // Serialized information recorded in the marker
    map<string, temporal.api.common.v1.Payloads> details = 2;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 3;
    temporal.api.common.v1.Header header = 4;
    // Some uses of markers, like a local activity, could "fail". If they did that is recorded here.
    temporal.api.failure.v1.Failure failure = 5;
}

message WorkflowExecutionSignaledEventAttributes {
    // The name/type of the signal to fire
    string signal_name = 1;
    // Will be deserialized and provided as argument(s) to the signal handler
    temporal.api.common.v1.Payloads input = 2;
    // id of the worker/client who sent this signal
    string identity = 3;
    // Headers that were passed by the sender of the signal and copied by temporal 
    // server into the workflow task.
    temporal.api.common.v1.Header header = 4;
    // This field is deprecated and never respected. It should always be set to false.
    bool skip_generate_workflow_task = 5 [deprecated = true];
    // When signal origin is a workflow execution, this field is set.
    temporal.api.common.v1.WorkflowExecution external_workflow_execution = 6;
}

message WorkflowExecutionTerminatedEventAttributes {
    // User/client provided reason for termination
    string reason = 1;
    temporal.api.common.v1.Payloads details = 2;
    // id of the client who requested termination
    string identity = 3;
}

message RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 1;
    // The namespace the workflow to be cancelled lives in.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    // Deprecated
    string control = 4;
    // Workers are expected to set this to true if the workflow they are requesting to cancel is
    // a child of the workflow which issued the request
    bool child_workflow_only = 5;
    // Reason for requesting the cancellation
    string reason = 6;
}

message RequestCancelExternalWorkflowExecutionFailedEventAttributes {
    temporal.api.enums.v1.CancelExternalWorkflowExecutionFailedCause cause = 1;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 2;
    // Namespace of the workflow which failed to cancel.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 3;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
    // id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
    // corresponds to
    int64 initiated_event_id = 5;
    // Deprecated
    string control = 6;
}

message ExternalWorkflowExecutionCancelRequestedEventAttributes {
    // id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
    // to
    int64 initiated_event_id = 1;
    // Namespace of the to-be-cancelled workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 4;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
}

message SignalExternalWorkflowExecutionInitiatedEventAttributes {
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 1;
    // Namespace of the to-be-signalled workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 9;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    // name/type of the signal to fire in the external workflow
    string signal_name = 4;
    // Serialized arguments to provide to the signal handler
    temporal.api.common.v1.Payloads input = 5;
    // Deprecated
    string control = 6;
    // Workers are expected to set this to true if the workflow they are requesting to cancel is
    // a child of the workflow which issued the request
    bool child_workflow_only = 7;
    temporal.api.common.v1.Header header = 8;
}

message SignalExternalWorkflowExecutionFailedEventAttributes {
    temporal.api.enums.v1.SignalExternalWorkflowExecutionFailedCause cause = 1;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 2;
    // Namespace of the workflow which failed the signal.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 3;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 4;
    int64 initiated_event_id = 5;
    // Deprecated
    string control = 6;
}

message ExternalWorkflowExecutionSignaledEventAttributes {
    // id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to
    int64 initiated_event_id = 1;
    // Namespace of the workflow which was signaled.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 5;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    // Deprecated
    string control = 4;
}

message UpsertWorkflowSearchAttributesEventAttributes {
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 1;
    temporal.api.common.v1.SearchAttributes search_attributes = 2;
}

message WorkflowPropertiesModifiedEventAttributes {
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 1;
    // If set, update the workflow memo with the provided values. The values will be merged with
    // the existing memo. If the user wants to delete values, a default/empty Payload should be
    // used as the value for the key being deleted.
    temporal.api.common.v1.Memo upserted_memo = 2;
}

message StartChildWorkflowExecutionInitiatedEventAttributes {
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 1;
    string namespace_id = 18;
    string workflow_id = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    temporal.api.taskqueue.v1.TaskQueue task_queue = 4;
    temporal.api.common.v1.Payloads input = 5;
    // Total workflow execution timeout including retries and continue as new.
    google.protobuf.Duration workflow_execution_timeout = 6;
    // Timeout of a single workflow run.
    google.protobuf.Duration workflow_run_timeout = 7;
    // Timeout of a single workflow task.
    google.protobuf.Duration workflow_task_timeout = 8;
    // Default: PARENT_CLOSE_POLICY_TERMINATE.
    temporal.api.enums.v1.ParentClosePolicy parent_close_policy = 9;
    // Deprecated
    string control = 10;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 11;
    // Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    temporal.api.enums.v1.WorkflowIdReusePolicy workflow_id_reuse_policy = 12;
    temporal.api.common.v1.RetryPolicy retry_policy = 13;
    // If this child runs on a cron schedule, it will appear here
    string cron_schedule = 14;
    temporal.api.common.v1.Header header = 15;
    temporal.api.common.v1.Memo memo = 16;
    temporal.api.common.v1.SearchAttributes search_attributes = 17;
    // If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
    // rules of the child's Task Queue will be used to independently assign a Build ID to it.
    bool inherit_build_id = 19;
    // Priority metadata
    temporal.api.common.v1.Priority priority = 20;
}

message StartChildWorkflowExecutionFailedEventAttributes {
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 1;
    string namespace_id = 8;
    string workflow_id = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    temporal.api.enums.v1.StartChildWorkflowExecutionFailedCause cause = 4;
    // Deprecated
    string control = 5;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 6;
    // The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
    int64 workflow_task_completed_event_id = 7;
}

message ChildWorkflowExecutionStartedEventAttributes {
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 1;
    string namespace_id = 6;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 2;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    temporal.api.common.v1.WorkflowType workflow_type = 4;
    temporal.api.common.v1.Header header = 5;
}

message ChildWorkflowExecutionCompletedEventAttributes {
    temporal.api.common.v1.Payloads result = 1;
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    temporal.api.common.v1.WorkflowType workflow_type = 4;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 5;
    // Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
    int64 started_event_id = 6;
}

message ChildWorkflowExecutionFailedEventAttributes {
    temporal.api.failure.v1.Failure failure = 1;
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 8;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    temporal.api.common.v1.WorkflowType workflow_type = 4;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 5;
    // Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
    int64 started_event_id = 6;
    temporal.api.enums.v1.RetryState retry_state = 7;
}

message ChildWorkflowExecutionCanceledEventAttributes {
    temporal.api.common.v1.Payloads details = 1;
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 2;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    temporal.api.common.v1.WorkflowType workflow_type = 4;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 5;
    // Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
    int64 started_event_id = 6;
}

message ChildWorkflowExecutionTimedOutEventAttributes {
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 1;
    string namespace_id = 7;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 4;
    // Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
    int64 started_event_id = 5;
    temporal.api.enums.v1.RetryState retry_state = 6;
}

message ChildWorkflowExecutionTerminatedEventAttributes {
    // Namespace of the child workflow.
    // SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
    string namespace = 1;
    string namespace_id = 6;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 2;
    temporal.api.common.v1.WorkflowType workflow_type = 3;
    // Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
    int64 initiated_event_id = 4;
    // Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
    int64 started_event_id = 5;
}

message WorkflowExecutionOptionsUpdatedEventAttributes {
    // Versioning override upserted in this event.
    // Ignored if nil or if unset_versioning_override is true.
    temporal.api.workflow.v1.VersioningOverride versioning_override = 1;
    // Versioning override removed in this event.
    bool unset_versioning_override = 2;
    // Request ID attachedto the running workflow execution so that subsequent requests with same
    // request ID will be deduped.
    string attached_request_id = 3;
    // Completion callbacks attached to the running workflow execution.
    repeated temporal.api.common.v1.Callback attached_completion_callbacks = 4;
}

// Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes
message WorkflowPropertiesModifiedExternallyEventAttributes {
    // Not used.
    string new_task_queue = 1;
    // Not used.
    google.protobuf.Duration new_workflow_task_timeout = 2;
    // Not used.
    google.protobuf.Duration new_workflow_run_timeout = 3;
    // Not used.
    google.protobuf.Duration new_workflow_execution_timeout = 4;
    // Not used.
    temporal.api.common.v1.Memo upserted_memo = 5;
}

message ActivityPropertiesModifiedExternallyEventAttributes {
    // The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to.
    int64 scheduled_event_id = 1;
    // If set, update the retry policy of the activity, replacing it with the specified one.
    // The number of attempts at the activity is preserved.
    temporal.api.common.v1.RetryPolicy new_retry_policy = 2;
}

message WorkflowExecutionUpdateAcceptedEventAttributes {
    // The instance ID of the update protocol that generated this event.
    string protocol_instance_id = 1;
    // The message ID of the original request message that initiated this
    // update. Needed so that the worker can recreate and deliver that same
    // message as part of replay.
    string accepted_request_message_id = 2;
    // The event ID used to sequence the original request message.
    int64 accepted_request_sequencing_event_id = 3;
    // The message payload of the original request message that initiated this
    // update.
    temporal.api.update.v1.Request accepted_request = 4;
}

message WorkflowExecutionUpdateCompletedEventAttributes {
    // The metadata about this update.
    temporal.api.update.v1.Meta meta = 1;

    // The event ID indicating the acceptance of this update.
    int64 accepted_event_id = 3;

    // The outcome of executing the workflow update function.
    temporal.api.update.v1.Outcome outcome = 2;
}

message WorkflowExecutionUpdateRejectedEventAttributes {
    // The instance ID of the update protocol that generated this event.
    string protocol_instance_id = 1;
    // The message ID of the original request message that initiated this
    // update. Needed so that the worker can recreate and deliver that same
    // message as part of replay.
    string rejected_request_message_id = 2;
    // The event ID used to sequence the original request message.
    int64 rejected_request_sequencing_event_id = 3;
    // The message payload of the original request message that initiated this
    // update.
    temporal.api.update.v1.Request rejected_request = 4;
    // The cause of rejection.
    temporal.api.failure.v1.Failure failure = 5;
}

message WorkflowExecutionUpdateAdmittedEventAttributes {
    // The update request associated with this event.
    temporal.api.update.v1.Request request = 1;
    // An explanation of why this event was written to history.
    temporal.api.enums.v1.UpdateAdmittedEventOrigin origin = 2;
}

// Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command.
message NexusOperationScheduledEventAttributes {
    // Endpoint name, must exist in the endpoint registry.
    string endpoint = 1;
    // Service name.
    string service = 2;
    // Operation name.
    string operation = 3;
    // Input for the operation. The server converts this into Nexus request content and the appropriate content headers
    // internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
    // content is transformed back to the original Payload stored in this event.
    temporal.api.common.v1.Payload input = 4;
    // Schedule-to-close timeout for this operation.
    // Indicates how long the caller is willing to wait for operation completion.
    // Calls are retried internally by the server.
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 5;
    // Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
    // activities and child workflows, these are transmitted to Nexus operations that may be external and are not
    // traditional payloads.
    map<string, string> nexus_header = 6;
    // The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with.
    int64 workflow_task_completed_event_id = 7;
    // A unique ID generated by the history service upon creation of this event.
    // The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key.
    string request_id = 8;

    // Endpoint ID as resolved in the endpoint registry at the time this event was generated.
    // This is stored on the event and used internally by the server in case the endpoint is renamed from the time the
    // event was originally scheduled.
    string endpoint_id = 9;
}

// Event marking an asynchronous operation was started by the responding Nexus handler.
// If the operation completes synchronously, this event is not generated.
// In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
// this event upon receiving the operation completion via callback.
message NexusOperationStartedEventAttributes {
    // The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to.
    int64 scheduled_event_id = 1;
    // The operation ID returned by the Nexus handler in the response to the StartOperation request.
    // This ID is used when canceling the operation.
    //
    // Deprecated: Renamed to operation_token.
    string operation_id = 3;

    // The request ID allocated at schedule time.
    string request_id = 4;

    // The operation token returned by the Nexus handler in the response to the StartOperation request.
    // This token is used when canceling the operation.
    string operation_token = 5;
}

// Nexus operation completed successfully.
message NexusOperationCompletedEventAttributes {
    // The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
    int64 scheduled_event_id = 1;
    // Serialized result of the Nexus operation. The response of the Nexus handler.
    // Delivered either via a completion callback or as a response to a synchronous operation.
    temporal.api.common.v1.Payload result = 2;

    // The request ID allocated at schedule time.
    string request_id = 3;
}

// Nexus operation failed.
message NexusOperationFailedEventAttributes {
    // The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
    int64 scheduled_event_id = 1;
    // Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo.
    temporal.api.failure.v1.Failure failure = 2;

    // The request ID allocated at schedule time.
    string request_id = 3;
}

// Nexus operation timed out.
message NexusOperationTimedOutEventAttributes {
    // The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
    int64 scheduled_event_id = 1;
    // Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo.
    temporal.api.failure.v1.Failure failure = 2;

    // The request ID allocated at schedule time.
    string request_id = 3;
}

// Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow.
message NexusOperationCanceledEventAttributes {
    // The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
    int64 scheduled_event_id = 1;
    // Cancellation details.
    temporal.api.failure.v1.Failure failure = 2;

    // The request ID allocated at schedule time.
    string request_id = 3;
}

message NexusOperationCancelRequestedEventAttributes {
    // The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
    int64 scheduled_event_id = 1;
    // The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
    // with.
    int64 workflow_task_completed_event_id = 2;
}

// History events are the method by which Temporal SDKs advance (or recreate) workflow state.
// See the `EventType` enum for more info about what each event is for.
message HistoryEvent {
    // Monotonically increasing event number, starts at 1.
    int64 event_id = 1;
    google.protobuf.Timestamp event_time = 2;
    temporal.api.enums.v1.EventType event_type = 3;
    // TODO: What is this? Appears unused by SDKs
    int64 version = 4;
    // TODO: What is this? Appears unused by SDKs
    int64 task_id = 5;
    // Set to true when the SDK may ignore the event as it does not impact workflow state or
    // information in any way that the SDK need be concerned with. If an SDK encounters an event
    // type which it does not understand, it must error unless this is true. If it is true, it's
    // acceptable for the event type and/or attributes to be uninterpretable.
    bool worker_may_ignore = 300;
    // Metadata on the event. This is often carried over from commands and client calls. Most events
    // won't have this information, and how this information is used is dependent upon the interface
    // that reads it.
    //
    // Current well-known uses:
    //  * workflow_execution_started_event_attributes - summary and details from start workflow.
    //  * timer_started_event_attributes - summary represents an identifier for the timer for use by
    //    user interfaces.
    temporal.api.sdk.v1.UserMetadata user_metadata = 301;
    // Links associated with the event.
    repeated temporal.api.common.v1.Link links = 302;
    // The event details. The type must match that in `event_type`.
    oneof attributes {
        WorkflowExecutionStartedEventAttributes workflow_execution_started_event_attributes = 6;
        WorkflowExecutionCompletedEventAttributes workflow_execution_completed_event_attributes = 7;
        WorkflowExecutionFailedEventAttributes workflow_execution_failed_event_attributes = 8;
        WorkflowExecutionTimedOutEventAttributes workflow_execution_timed_out_event_attributes = 9;
        WorkflowTaskScheduledEventAttributes workflow_task_scheduled_event_attributes = 10;
        WorkflowTaskStartedEventAttributes workflow_task_started_event_attributes = 11;
        WorkflowTaskCompletedEventAttributes workflow_task_completed_event_attributes = 12;
        WorkflowTaskTimedOutEventAttributes workflow_task_timed_out_event_attributes = 13;
        WorkflowTaskFailedEventAttributes workflow_task_failed_event_attributes = 14;
        ActivityTaskScheduledEventAttributes activity_task_scheduled_event_attributes = 15;
        ActivityTaskStartedEventAttributes activity_task_started_event_attributes = 16;
        ActivityTaskCompletedEventAttributes activity_task_completed_event_attributes = 17;
        ActivityTaskFailedEventAttributes activity_task_failed_event_attributes = 18;
        ActivityTaskTimedOutEventAttributes activity_task_timed_out_event_attributes = 19;
        TimerStartedEventAttributes timer_started_event_attributes = 20;
        TimerFiredEventAttributes timer_fired_event_attributes = 21;
        ActivityTaskCancelRequestedEventAttributes activity_task_cancel_requested_event_attributes = 22;
        ActivityTaskCanceledEventAttributes activity_task_canceled_event_attributes = 23;
        TimerCanceledEventAttributes timer_canceled_event_attributes = 24;
        MarkerRecordedEventAttributes marker_recorded_event_attributes = 25;
        WorkflowExecutionSignaledEventAttributes workflow_execution_signaled_event_attributes = 26;
        WorkflowExecutionTerminatedEventAttributes workflow_execution_terminated_event_attributes = 27;
        WorkflowExecutionCancelRequestedEventAttributes workflow_execution_cancel_requested_event_attributes = 28;
        WorkflowExecutionCanceledEventAttributes workflow_execution_canceled_event_attributes = 29;
        RequestCancelExternalWorkflowExecutionInitiatedEventAttributes request_cancel_external_workflow_execution_initiated_event_attributes = 30;
        RequestCancelExternalWorkflowExecutionFailedEventAttributes request_cancel_external_workflow_execution_failed_event_attributes = 31;
        ExternalWorkflowExecutionCancelRequestedEventAttributes external_workflow_execution_cancel_requested_event_attributes = 32;
        WorkflowExecutionContinuedAsNewEventAttributes workflow_execution_continued_as_new_event_attributes = 33;
        StartChildWorkflowExecutionInitiatedEventAttributes start_child_workflow_execution_initiated_event_attributes = 34;
        StartChildWorkflowExecutionFailedEventAttributes start_child_workflow_execution_failed_event_attributes = 35;
        ChildWorkflowExecutionStartedEventAttributes child_workflow_execution_started_event_attributes = 36;
        ChildWorkflowExecutionCompletedEventAttributes child_workflow_execution_completed_event_attributes = 37;
        ChildWorkflowExecutionFailedEventAttributes child_workflow_execution_failed_event_attributes = 38;
        ChildWorkflowExecutionCanceledEventAttributes child_workflow_execution_canceled_event_attributes = 39;
        ChildWorkflowExecutionTimedOutEventAttributes child_workflow_execution_timed_out_event_attributes = 40;
        ChildWorkflowExecutionTerminatedEventAttributes child_workflow_execution_terminated_event_attributes = 41;
        SignalExternalWorkflowExecutionInitiatedEventAttributes signal_external_workflow_execution_initiated_event_attributes = 42;
        SignalExternalWorkflowExecutionFailedEventAttributes signal_external_workflow_execution_failed_event_attributes = 43;
        ExternalWorkflowExecutionSignaledEventAttributes external_workflow_execution_signaled_event_attributes = 44;
        UpsertWorkflowSearchAttributesEventAttributes upsert_workflow_search_attributes_event_attributes = 45;
        WorkflowExecutionUpdateAcceptedEventAttributes workflow_execution_update_accepted_event_attributes = 46;
        WorkflowExecutionUpdateRejectedEventAttributes workflow_execution_update_rejected_event_attributes = 47;
        WorkflowExecutionUpdateCompletedEventAttributes workflow_execution_update_completed_event_attributes = 48;
        WorkflowPropertiesModifiedExternallyEventAttributes workflow_properties_modified_externally_event_attributes = 49;
        ActivityPropertiesModifiedExternallyEventAttributes activity_properties_modified_externally_event_attributes = 50;
        WorkflowPropertiesModifiedEventAttributes workflow_properties_modified_event_attributes = 51;
        WorkflowExecutionUpdateAdmittedEventAttributes workflow_execution_update_admitted_event_attributes = 52;
        NexusOperationScheduledEventAttributes nexus_operation_scheduled_event_attributes = 53;
        NexusOperationStartedEventAttributes nexus_operation_started_event_attributes = 54;
        NexusOperationCompletedEventAttributes nexus_operation_completed_event_attributes = 55;
        NexusOperationFailedEventAttributes nexus_operation_failed_event_attributes = 56;
        NexusOperationCanceledEventAttributes nexus_operation_canceled_event_attributes = 57;
        NexusOperationTimedOutEventAttributes nexus_operation_timed_out_event_attributes = 58;
        NexusOperationCancelRequestedEventAttributes nexus_operation_cancel_requested_event_attributes = 59;
        WorkflowExecutionOptionsUpdatedEventAttributes workflow_execution_options_updated_event_attributes = 60;
    }
}

message History {
    repeated HistoryEvent events = 1;
}
