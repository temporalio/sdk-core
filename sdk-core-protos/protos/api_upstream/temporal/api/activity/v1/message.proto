syntax = "proto3";

package temporal.api.activity.v1;

option go_package = "go.temporal.io/api/activity/v1;activity";
option java_package = "io.temporal.api.activity.v1";
option java_multiple_files = true;
option java_outer_classname = "MessageProto";
option ruby_package = "Temporalio::Api::Activity::V1";
option csharp_namespace = "Temporalio.Api.Activity.V1";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";

import "temporal/api/common/v1/message.proto";
import "temporal/api/deployment/v1/message.proto";
import "temporal/api/enums/v1/activity.proto";
import "temporal/api/enums/v1/workflow.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/taskqueue/v1/message.proto";
import "temporal/api/sdk/v1/user_metadata.proto";

// When StartActivityExecution uses the ID_CONFLICT_POLICY_USE_EXISTING and there is already an existing running
// activity, OnConflictOptions defines actions to be taken on the existing running activity, updating its state.
message OnConflictOptions {
    // Attaches the request ID to the running workflow.
    bool attach_request_id = 1;
    // Attaches the completion callbacks to the running workflow.
    bool attach_completion_callbacks = 2;
    // Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
    bool attach_links = 3;
}

message ActivityOptions {
    temporal.api.taskqueue.v1.TaskQueue task_queue = 1;

    // Indicates how long the caller is willing to wait for an activity completion. Limits how long
    // retries will be attempted. Either this or `start_to_close_timeout` must be specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 2;
    // Limits time an activity task can stay in a task queue before a worker picks it up. This
    // timeout is always non retryable, as all a retry would achieve is to put it back into the same
    // queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
    // specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_start_timeout = 3;
    // Maximum time an activity is allowed to execute after being picked up by a worker. This
    // timeout is always retryable. Either this or `schedule_to_close_timeout` must be
    // specified.
    //
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 4;
    // Maximum permitted time between successful worker heartbeats.
    google.protobuf.Duration heartbeat_timeout = 5;
    // The retry policy for the activity. Will never exceed `schedule_to_close_timeout`.
    temporal.api.common.v1.RetryPolicy retry_policy = 6;
}

// Info for a standalone activity.
message ActivityExecutionInfo {
    // Unique identifier of this activity within its namespace along with run ID (below).
    string activity_id = 1;
    string run_id = 2;

    // The type of the activity, a string that maps to a registered activity on a worker.
    temporal.api.common.v1.ActivityType activity_type = 3;
    // A general status for this activity, indicates whether it is currently running or in one of the terminal statuses.
    temporal.api.enums.v1.ActivityExecutionStatus status = 4;
    // More detailed breakdown of ACTIVITY_EXECUTION_STATUS_RUNNING.
    temporal.api.enums.v1.PendingActivityState run_state = 5;
    // Details provided in the last recorded activity heartbeat.
    temporal.api.common.v1.Payloads heartbeat_details = 6;
    // Time the last heartbeat was recorded.
    google.protobuf.Timestamp last_heartbeat_time = 7;
    // Time the last attempt was started.
    google.protobuf.Timestamp last_started_time = 8;
    // The attempt this activity is currently on.
    // Incremented each time a new attempt is started.
    // TODO: Confirm if this is on scheduled or started.
    int32 attempt = 9;
    int32 maximum_attempts = 10;
    // Time the activity was originally scheduled via a StartActivityExecution request.
    google.protobuf.Timestamp scheduled_time = 11;
    // Scheduled time + schedule to close timeout.
    google.protobuf.Timestamp expiration_time = 12;
    // Failure details from the last failed attempt.
    temporal.api.failure.v1.Failure last_failure = 13;
    string last_worker_identity = 14;

    // Time from the last attempt failure to the next activity retry.
    // If the activity is currently running, this represents the next retry interval in case the attempt fails.
    // If activity is currently backing off between attempt, this represents the current retry interval.
    // If there is no next retry allowed, this field will be null.
    // This interval is typically calculated from the specified retry policy, but may be modified if an activity fails
    // with a retryable application failure specifying a retry delay.
    google.protobuf.Duration current_retry_interval = 15;

    // The time when the last activity attempt completed. If activity has not been completed yet, it will be null.
    google.protobuf.Timestamp last_attempt_complete_time = 16;

    // The time when the next activity attempt will be scheduled.
    // If activity is currently scheduled or started, this field will be null.
    google.protobuf.Timestamp next_attempt_schedule_time = 17;

    // The Worker Deployment Version this activity was dispatched to most recently.
    // If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
    temporal.api.deployment.v1.WorkerDeploymentVersion last_deployment_version = 18;

    // Priority metadata.
    temporal.api.common.v1.Priority priority = 19;

    // Current activity options. May be different from the one used to start the activity.
    temporal.api.activity.v1.ActivityOptions activity_options = 20;

    // Serialized activity input, passed as arguments to the activity function.
    temporal.api.common.v1.Payloads input = 21;

    // Incremented each time the activity's state is mutated in persistence.
    int64 state_transition_count = 22;

    temporal.api.common.v1.SearchAttributes search_attributes = 23;
    temporal.api.common.v1.Header header = 24;
    // Whether the activity was started with a request_eager_execution flag set to `true`, indicating that the first
    // task was delivered inline in the start response, bypassing matching.
    bool eager_execution_requested = 25;

    // Callbacks to be called by the server when this activity reaches a terminal status.
    // Callback addresses must be whitelisted in the server's dynamic configuration.
    repeated temporal.api.common.v1.Callback completion_callbacks = 26;
    // Metadata for use by user interfaces to display the fixed as-of-start summary and details of the activity.
    temporal.api.sdk.v1.UserMetadata user_metadata = 27;
    // Links to be associated with the activity.
    repeated temporal.api.common.v1.Link links = 28;

    // Set if activity cancelation was requested.
    string canceled_reason = 29;

    // TODO: Move this to a common package?
    message PauseInfo {
        // The time when the activity was paused.
        google.protobuf.Timestamp pause_time = 1;

        message Manual {
            // The identity of the actor that paused the activity.
            string identity = 1;
            // Reason for pausing the activity.
            string reason = 2;
        }

        oneof paused_by {
            // The activity was paused by direct API invocation.
            Manual manual = 2;
        }
    }

    PauseInfo pause_info = 30;
}

// Limited activity information returned in the list response.
message ActivityListInfo {
    // For standalone activity - a unique identifier of this activity within its namespace along with run ID (below).
    string activity_id = 1;
    // The run ID of the workflow or standalone activity.
    string run_id = 2;
    // Workflow that contains this activity - only present for workflow activity.
    string workflow_id = 3;

    // The type of the activity, a string that maps to a registered activity on a worker.
    temporal.api.common.v1.ActivityType activity_type = 4;
    // Time the activity was originally scheduled via a StartActivityExecution request.
    // TODO: Workflows call this schedule_time but it's scheduled_time in PendingActivityInfo, what should we choose for
    // consistency?
    google.protobuf.Timestamp scheduled_time = 5;
    // If the activity is in a terminal status, this field represents the time the activity transitioned to that status.
    google.protobuf.Timestamp close_time = 6;
    // Only scheduled and terminal statuses appear here. More detailed information in PendingActivityInfo but not
    // available in the list response.
    temporal.api.enums.v1.ActivityExecutionStatus status = 7;

    // Search attributes from the start request.
    temporal.api.common.v1.SearchAttributes search_attributes = 8;

    // The task queue this activity was scheduled on when it was originally started, updated on activity options update.
    string task_queue = 9;
    // Updated on terminal status.
    int64 state_transition_count = 10;
    // Updated once on scheduled and once on terminal status.
    int64 state_size_bytes = 11;
    // The difference between close time and scheduled time.
    // This field is only populated if the activity is closed.
    google.protobuf.Duration execution_duration = 12;

    // TODO: pause_info
}
