syntax = "proto3";

package coresdk;

// Note: Intellij will think these imports don't work because of the slightly odd nature of
// the include paths. You can make it work by going to the "Protobuf Support" settings section
// and adding the "api_upstream" subdir as an include path.

import "common.proto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";

// A request as given to [crate::Core::poll_task]
message PollTaskReq {
    // What type of task to poll for
    enum TaskType {
        // Poll for workflows
        WORKFLOWS = 0;
        // Poll for activities
        ACTIVITIES = 1;
    }

    // A list of task types to poll for
    repeated TaskType types = 1;
}

// An instruction to perform work from core->lang sdk
message Task {
    // A unique identifier for this task
    bytes task_token = 1;
    // The type of task to be performed
    oneof variant {
        // Wake up a workflow
        WFActivation workflow = 2;
        // Run an activity
        ActivityTask activity = 3;
    }
}

// An instruction to the lang sdk to run some workflow code, whether for the first time or from
// a cached state.
message WFActivation {
    // The current time as understood by the workflow, which is set by workflow task started events
    google.protobuf.Timestamp timestamp = 1;
    // The id of the currently active run of the workflow
    string run_id = 2;
    // The things to do upon activating the workflow
    repeated WFActivationJob jobs = 3;
}

message WFActivationJob {
    oneof variant {
        // Begin a workflow for the first time
        StartWorkflow start_workflow = 1;
        // A timer has fired, allowing whatever was waiting on it (if anything) to proceed
        FireTimer fire_timer = 2;
        // A timer was canceled, and needs to be unblocked on the lang side.
        CancelTimer cancel_timer = 3;
        // Workflow was reset. The randomness seed must be updated.
        UpdateRandomSeed update_random_seed = 4;
        // A request to query the workflow was received.
        QueryWorkflow query_workflow = 5;
        // A request to cancel the workflow was received.
        CancelWorkflow cancel_workflow = 6;
        // A request to signal the workflow was received.
        SignalWorkflow signal_workflow = 7;
        // An activity was resolved with, result could be completed, failed or cancelled
        ResolveActivity resolve_activity = 8;
    }
}

message StartWorkflow {
    // The identifier the lang-specific sdk uses to execute workflow code
    string workflow_type = 1;
    // The workflow id used on the temporal server
    string workflow_id = 2;
    // Inputs to the workflow code
    repeated common.Payload arguments = 3;
    // The seed must be used to initialize the random generator used by SDK.
    // RandomSeedUpdatedAttributes are used to deliver seed updates.
    uint64 randomness_seed = 4;

    // TODO: Do we need namespace here, or should that just be fetchable easily?
    //   will be others - workflow exe started attrs, etc
}

message FireTimer {
    string timer_id = 1;
}

message ResolveActivity {
    string activity_id = 1;
    ActivityResult result = 2;
}

message CancelTimer {
    string timer_id = 1;
}

message UpdateRandomSeed {
    uint64 randomness_seed = 1;
}

message QueryWorkflow {
    string query_type = 1;
    repeated common.Payload arguments = 2;
}

message CancelWorkflow {
    // TODO: add attributes here
}

message SignalWorkflow {
    string signal_name = 1;
    repeated common.Payload input = 2;
    string identity = 3;
}

message ActivityTask {
    string activity_id = 1;
    oneof variant {
        // Start activity execution.
        StartActivity start = 2;
        // Attempt to cancel activity execution.
        CancelActivity cancel = 3;
    }
}

message StartActivity {
    string workflow_namespace = 1;
    // The workflow's type name or function identifier
    string workflow_type = 2;
    common.WorkflowExecution workflow_execution = 3;
    // The activity's type name or function identifier
    string activity_type = 4;
    map<string, common.Payload> header_fields = 5;
    // Arguments to the activity
    repeated common.Payload input = 6;
    repeated common.Payload heartbeat_details = 7;

    google.protobuf.Timestamp scheduled_time = 8;
    google.protobuf.Timestamp current_attempt_scheduled_time = 9;
    google.protobuf.Timestamp started_time = 10;
    int32 attempt = 11;

    google.protobuf.Duration schedule_to_close_timeout = 12;
    google.protobuf.Duration start_to_close_timeout = 13;
    google.protobuf.Duration heartbeat_timeout = 14;
    // This is an actual retry policy the service uses. It can be different from the one provided
    // (or not) during activity scheduling as the service can override the provided one in case its
    // values are not specified or exceed configured system limits.
    common.RetryPolicy retry_policy = 15;
}

message CancelActivity {
    // TODO: add attributes
}


// Sent from lang side to core when calling [crate::Core::complete_task]
message TaskCompletion {
    // The id from the [Task] being completed
    bytes task_token = 1;
    oneof variant {
        // Complete a workflow task
        WFActivationCompletion workflow = 2;
        // Complete an activity task
        ActivityResult activity = 3;
    }
}

message WFActivationCompletion {
    oneof status {
        WFActivationSuccess successful = 1;
        WFActivationFailure failed = 2;
    }
}

/// Used to report activity completion to core and to resolve the activity in a workflow activation
message ActivityResult {
    oneof status {
        ActivityTaskSuccess completed = 1;
        ActivityTaskFailure failed = 2;
        ActivityTaskCancelation canceled = 3;
    }
}

/// Request cancellation of an activity from a workflow
message RequestActivityCancellation {
    string activity_id = 1;
    string reason = 2;
}

message CoreCommand {
    oneof variant {
        WFQueryResult respond_to_query = 1;
        RequestActivityCancellation request_activity_cancellation = 2;
    }
}

// Included in successful [WfActivationCompletion]s, indicates what the workflow wishes to do next
message Command {
    oneof variant {
        temporal.api.command.v1.Command api = 1;
        CoreCommand core = 2;
    }
}

message WFActivationSuccess {
    // A list of commands to send back to the temporal server
    repeated Command commands = 1;
}

message WFActivationFailure {
    common.UserCodeFailure failure = 1;
}

message WFQueryResult {
    oneof variant {
        WFQuerySuccess succeeded = 1;
        string failed_with_message = 2;
    }
}

message WFQuerySuccess {
    repeated common.Payload responses = 1;
}

/// Used in ActivityResult to report cancellation
message ActivityTaskCancelation {
    repeated common.Payload details = 1;
}

/// Used in ActivityResult to report successful completion
message ActivityTaskSuccess {
    repeated common.Payload result = 1;
    // Other bits from RespondActivityTaskCompletedRequest as needed
}

/// Used in ActivityResult to report failure
message ActivityTaskFailure {
    repeated common.Payload failure = 1;
    // Other bits from RespondActivityTaskFailedRequest as needed
}

// A request as given to [crate::Core::send_activity_heartbeat]
message ActivityHeartbeat {
    string activity_id = 1;
    repeated common.Payload details = 2;
}
