syntax = "proto3";

package coresdk;

// Note: Intellij will think these imports don't work because of the slightly odd nature of
// the include paths. You can make it work by going to the "Protobuf Support" settings section
// and adding the "api_upstream" subdir as an include path.

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/empty.proto";
import "dependencies/gogoproto/gogo.proto";
import "temporal/api/workflowservice/v1/request_response.proto";
import "temporal/api/taskqueue/v1/message.proto";
import "temporal/api/enums/v1/failed_cause.proto";
import "temporal/api/failure/v1/message.proto";
import "temporal/api/history/v1/message.proto";
import "temporal/api/common/v1/message.proto";
import "temporal/api/command/v1/message.proto";
import "temporal/api/query/v1/message.proto";

// A request as given to [crate::Core::poll_task]
message PollTaskReq {
    // What type of task to poll for
    enum TaskType {
        // Poll for workflows
        WORKFLOWS = 0;
        // Poll for activities
        ACTIVITIES = 1;
    }

    // A list of task types to poll for
    repeated TaskType types = 1;
}

// An instruction to perform work from core->lang sdk
message Task {
    // A unique identifier for this task
    bytes task_token = 1;
    // The type of task to be performed
    oneof variant {
        // Wake up a workflow
        WFActivation workflow = 2;
        // Run an activity
        ActivityTask activity = 3;
    }
}

// An instruction to the lang sdk to run some workflow code, whether for the first time or from
// a cached state.
message WFActivation {
    // The current time as understood by the workflow, which is set by workflow task started events
    google.protobuf.Timestamp timestamp = 1 [(gogoproto.stdtime) = true];
    // The id of the currently active run of the workflow
    string run_id = 2;
    // The things to do upon activating the workflow
    repeated WFActivationJob jobs = 3;
}

message WFActivationJob {
    oneof variant {
        // Begin a workflow for the first time
        StartWorkflow start_workflow = 1;
        // A timer has fired, allowing whatever was waiting on it (if anything) to proceed
        FireTimer fire_timer = 2;
        // A timer was canceled, and needs to be unblocked on the lang side.
        CancelTimer cancel_timer = 3;
        // Workflow was reset. The randomness seed must be updated.
        UpdateRandomSeed update_random_seed = 4;
        // A request to query the workflow was received.
        QueryWorkflow query_workflow = 5;
        // A request to cancel the workflow was received.
        CancelWorkflow cancel_workflow = 6;
        // A request to signal the workflow was received.
        SignalWorkflow signal_workflow = 7;
        // An activity was resolved with, result could be completed, failed or cancelled
        ResolveActivity resolve_activity = 8;
    }
}

message StartWorkflow {
    // The identifier the lang-specific sdk uses to execute workflow code
    string workflow_type = 1;
    // The workflow id used on the temporal server
    string workflow_id = 2;
    // Input to the workflow code
    temporal.api.common.v1.Payloads arguments = 3;
    // The seed must be used to initialize the random generator used by SDK.
    // RandomSeedUpdatedAttributes are used to deliver seed updates.
    uint64 randomness_seed = 4;

    // TODO: Do we need namespace here, or should that just be fetchable easily?
    //   will be others - workflow exe started attrs, etc
}

message FireTimer {
    string timer_id = 1;
}

message ResolveActivity {
    string activity_id = 1;
    ActivityResult result = 2;
}

message CancelTimer {
    string timer_id = 1;
}

message UpdateRandomSeed {
    uint64 randomness_seed = 1;
}

message QueryWorkflow {
    temporal.api.query.v1.WorkflowQuery query = 1;
}

message CancelWorkflow {
    // TODO: add attributes here
}

message SignalWorkflow {
    // The signal information from the workflow's history
    temporal.api.history.v1.WorkflowExecutionSignaledEventAttributes signal = 1;
}

message StartActivity {
    string workflow_namespace = 1;
    temporal.api.common.v1.WorkflowType workflow_type = 2;
    temporal.api.common.v1.WorkflowExecution workflow_execution = 3;
    temporal.api.common.v1.ActivityType activity_type = 4;
    temporal.api.common.v1.Header header = 5;
    temporal.api.common.v1.Payloads input = 6;
    temporal.api.common.v1.Payloads heartbeat_details = 7;
    google.protobuf.Timestamp scheduled_time = 8 [(gogoproto.stdtime) = true];
    google.protobuf.Timestamp current_attempt_scheduled_time = 9 [(gogoproto.stdtime) = true];
    google.protobuf.Timestamp started_time = 10 [(gogoproto.stdtime) = true];
    int32 attempt = 11;
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration schedule_to_close_timeout = 12 [(gogoproto.stdduration) = true];
    // (-- api-linter: core::0140::prepositions=disabled
    //     aip.dev/not-precedent: "to" is used to indicate interval. --)
    google.protobuf.Duration start_to_close_timeout = 13 [(gogoproto.stdduration) = true];
    google.protobuf.Duration heartbeat_timeout = 14 [(gogoproto.stdduration) = true];
    // This is an actual retry policy the service uses.
    // It can be different from the one provided (or not) during activity scheduling
    // as the service can override the provided one in case its values are not specified
    // or exceed configured system limits.
    temporal.api.common.v1.RetryPolicy retry_policy = 15;
}

message CancelActivity {
    // TODO: add attributes
}

message ActivityTask {
    string activity_id = 1;
    oneof job {
        // Start activity execution.
        StartActivity start = 2;
        // Attempt to cancel activity execution.
        CancelActivity cancel = 3;
    }
}


// Sent from lang side to core when calling [crate::Core::complete_task]
message TaskCompletion {
    // The id from the [Task] being completed
    bytes task_token = 1;
    oneof variant {
        // Complete a workflow task
        WFActivationCompletion workflow = 2;
        // Complete an activity task
        ActivityResult activity = 3;
    }
}

message WFActivationCompletion {
    oneof status {
        WFActivationSuccess successful = 1;
        WFActivationFailure failed = 2;
    }
}

/// Used to report activity completion to core and to resolve the activity in a workflow activtion
message ActivityResult {
    oneof status {
        ActivityTaskSuccess completed = 1;
        ActivityTaskCancelation canceled = 2;
        ActivityTaskFailure failed = 3;
    }
}

/// Request cancellation of an activity from a workflow
message RequestActivityCancellation {
    string activity_id = 1;
    string reason = 2;
}

message CoreCommand {
    oneof variant {
        temporal.api.query.v1.WorkflowQueryResult respond_to_query = 1;
        RequestActivityCancellation request_activity_cancellation = 2;
    }
}

// Included in successful [WfActivationCompletion]s, indicates what the workflow wishes to do next
message Command {
    oneof variant {
        temporal.api.command.v1.Command api = 1;
        CoreCommand core = 2;
    }
}

message WFActivationSuccess {
    // A list of commands to send back to the temporal server
    repeated Command commands = 1;

    // Other bits from RespondWorkflowTaskCompletedRequest as needed
}

message WFActivationFailure {
    temporal.api.enums.v1.WorkflowTaskFailedCause cause = 1;
    temporal.api.failure.v1.Failure failure = 2;

    // Other bits from RespondWorkflowTaskFailedRequest as needed
}

/// Used in ActivityResult to report cancellation
message ActivityTaskCancelation {
}

/// Used in ActivityResult to report successful completion
message ActivityTaskSuccess {
    temporal.api.common.v1.Payloads result = 1;
    // Other bits from RespondActivityTaskCompletedRequest as needed
}

/// Used in ActivityResult to report failure
message ActivityTaskFailure {
    temporal.api.failure.v1.Failure failure = 1;
    // Other bits from RespondActivityTaskFailedRequest as needed
}

// A request as given to [crate::Core::send_activity_heartbeat]
message ActivityHeartbeat {
    string activity_id = 1;
    temporal.api.common.v1.Payloads details = 2;
}
